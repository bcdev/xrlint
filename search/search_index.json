{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"XRLint - A linter for xarray datasets","text":"<p>XRLint is a linting  tool and library for xarray datasets. Its design is heavily inspired by ESLint.</p> <p>IMPORTANT NOTE: This project just started and is under development,  there is no stable release yet. See to-do list.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Flexible validation for <code>xarray.Dataset</code> objects by configurable rules.</li> <li>Available from CLI and Python API.</li> <li>Custom plugins providing custom rule sets allow addressing    different dataset conventions.</li> <li>Project-specific configurations including configuration of individual    rules and file-specific settings.</li> </ul>"},{"location":"#inbuilt-rules","title":"Inbuilt Rules","text":"<p>The following rule plugins are currently built into the code base:</p> <ul> <li><code>core</code>: Implementing the rules for   tiny data   and the    CF-Conventions.</li> <li><code>xcube</code>: Implementing the rules for    xcube datasets.   Note, this plugin is fully optional. You must manually configure    it to apply its rules. It may be moved into a separate GitHub repo    once XRLint is mature enough. </li> </ul>"},{"location":"about/","title":"About XRLint","text":""},{"location":"about/#changelog","title":"Changelog","text":"<p>You can find the complete XRLint changelog  here. </p>"},{"location":"about/#reporting","title":"Reporting","text":"<p>If you have suggestions, ideas, feature requests, or if you have identified a malfunction or error, then please  post an issue. </p>"},{"location":"about/#contributions","title":"Contributions","text":"<p>The XRLint project welcomes contributions of any form as long as you respect our  code of conduct and follow our  contribution guide.</p> <p>If you'd like to submit code or documentation changes, we ask you to provide a  pull request (PR)  here.  For code and configuration changes, your PR must be linked to a  corresponding issue. </p>"},{"location":"about/#development","title":"Development","text":"<p>To set up development environment, with repository root as current working directory:</p> <pre><code>pip install .[dev,doc]\n</code></pre>"},{"location":"about/#testing-and-coverage","title":"Testing and Coverage","text":"<p>XRLint uses pytest for unit-level testing  and code coverage analysis.</p> <pre><code>pytest --cov=xrlint --cov-report html\n</code></pre>"},{"location":"about/#code-style","title":"Code Style","text":"<p>XRLint source code is formatted using the black tool.</p> <pre><code>black .\n</code></pre>"},{"location":"about/#documentation","title":"Documentation","text":"<p>XRLint documentation is built using the mkdocs tool.</p> <p>With repository root as current working directory:</p> <pre><code>pip install .[doc]\n\nmkdocs build\nmkdocs serve\nmkdocs gh-deploy\n</code></pre>"},{"location":"about/#license","title":"License","text":"<p>XRLint is open source made available under the terms and conditions of the  MIT License.</p> <p>Copyright \u00a9 2025 Brockmann Consult Development</p>"},{"location":"api/","title":"Python API","text":"<p>All described objects can be imported from the <code>xrlint.all</code> module.</p>"},{"location":"api/#function-new_linter","title":"Function <code>new_linter()</code>","text":"<p>Create a new <code>Linter</code>.</p> <p>Parameters:</p> Name Type Description Default <code>recommended</code> <code>bool</code> <p><code>True</code> if the recommended configurations of the builtin rules should be used. If set to <code>False</code> (the default), you should configure the <code>rules</code> option either in <code>config</code> or <code>config_kwargs</code>. Otherwise, calling <code>verify_dataset()</code> without any rule configuration will never succeed for any given dataset.</p> <code>False</code> <code>config</code> <code>Config | dict | None</code> <p>The <code>config</code> keyword argument passed to the <code>Linter</code> class</p> <code>None</code> <code>config_kwargs</code> <code>dict[str, Any]</code> <p>The <code>config_kwargs</code> keyword arguments passed to the <code>Linter</code> class</p> <code>{}</code> <p>Returns:     A new linter instance</p> Source code in <code>xrlint\\linter.py</code> <pre><code>def new_linter(\n    recommended: bool = False,\n    config: Config | dict | None = None,\n    **config_kwargs: dict[str, Any],\n) -&gt; \"Linter\":\n    \"\"\"Create a new `Linter`.\n\n    Args:\n        recommended: `True` if the recommended configurations of the builtin\n            rules should be used.\n            If set to `False` (the default), you should configure the `rules`\n            option either in `config` or `config_kwargs`. Otherwise, calling\n            `verify_dataset()` without any rule configuration will never\n            succeed for any given dataset.\n        config: The `config` keyword argument passed to the `Linter` class\n        config_kwargs: The `config_kwargs` keyword arguments passed to\n            the `Linter` class\n    Returns:\n        A new linter instance\n    \"\"\"\n    return Linter(\n        config=merge_configs(get_core_config(recommended=recommended), config),\n        **config_kwargs,\n    )\n</code></pre>"},{"location":"api/#class-linter","title":"Class <code>Linter</code>","text":"<p>The linter.</p> <p>You should not use the constructor directly. Instead, use the <code>new_linter()</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config | dict[str, Any] | None</code> <p>The linter's configuration.</p> <code>None</code> <code>config_kwargs</code> <code>dict[str, Any]</code> <p>Individual linter configuration options. All options of the <code>Config</code> object are possible. If <code>config</code> is given too, provided given individual linter configuration options merged the ones given in <code>config</code>.</p> <code>{}</code> Source code in <code>xrlint\\linter.py</code> <pre><code>class Linter:\n    \"\"\"The linter.\n\n    You should not use the constructor directly.\n    Instead, use the `new_linter()` function.\n\n    Args:\n        config: The linter's configuration.\n        config_kwargs: Individual linter configuration options.\n            All options of the `Config` object are possible.\n            If `config` is given too, provided\n            given individual linter configuration options\n            merged the ones given in `config`.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: Config | dict[str, Any] | None = None,\n        **config_kwargs: dict[str, Any],\n    ):\n        self._config = merge_configs(config, config_kwargs)\n\n    @property\n    def config(self) -&gt; Config:\n        \"\"\"Get this linter's configuration.\"\"\"\n        return self._config\n\n    def verify_dataset(\n        self,\n        dataset: str | Path | xr.Dataset,\n        *,\n        file_path: str | None = None,\n        config: Config | dict[str, Any] | None = None,\n        **config_kwargs: dict[str, Any],\n    ) -&gt; Result:\n        \"\"\"Verify a dataset.\n\n        Args:\n            dataset: The dataset. Can be a `xr.Dataset` instance\n                or a file path from which the dataset will be opened.\n            file_path: Optional file path used for formatting\n                messages. Useful if `dataset` is not a file path.\n            config: Configuration tbe merged with the linter's\n                configuration.\n            config_kwargs: Individual linter configuration options\n                to be merged with `config` if any. The merged result\n                will be merged with the linter's configuration.\n        Returns:\n            Result of the verification.\n        \"\"\"\n        config = merge_configs(self._config, config)\n        config = merge_configs(config, config_kwargs)\n\n        error: Exception | None = None\n        if not isinstance(dataset, xr.Dataset):\n            ds_source = dataset\n            dataset, error = open_dataset(ds_source, config.opener_options or {})\n            if not file_path and isinstance(ds_source, (str, Path)):\n                file_path = str(ds_source)\n\n        if dataset is not None and not file_path:\n            file_path = _get_file_path_for_dataset(dataset)\n\n        context = RuleContextImpl(config=config, dataset=dataset, file_path=file_path)\n\n        if error:\n            context.report(str(error), fatal=True)\n        elif not config.rules:\n            context.report(\"No rules configured or applicable.\", fatal=True)\n        else:\n            # TODO: validate config,\n            #   e.g., validate any rule options against rule.meta.schema\n            for rule_id, rule_config in config.rules.items():\n                with context.use_state(rule_id=rule_id):\n                    _apply_rule(context, rule_id, rule_config)\n\n        return Result.new(\n            config=config, file_path=context.file_path, messages=context.messages\n        )\n</code></pre>"},{"location":"api/#xrlint.linter.Linter.config","title":"<code>config</code>  <code>property</code>","text":"<p>Get this linter's configuration.</p>"},{"location":"api/#xrlint.linter.Linter.verify_dataset","title":"<code>verify_dataset(dataset, *, file_path=None, config=None, **config_kwargs)</code>","text":"<p>Verify a dataset.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>str | Path | Dataset</code> <p>The dataset. Can be a <code>xr.Dataset</code> instance or a file path from which the dataset will be opened.</p> required <code>file_path</code> <code>str | None</code> <p>Optional file path used for formatting messages. Useful if <code>dataset</code> is not a file path.</p> <code>None</code> <code>config</code> <code>Config | dict[str, Any] | None</code> <p>Configuration tbe merged with the linter's configuration.</p> <code>None</code> <code>config_kwargs</code> <code>dict[str, Any]</code> <p>Individual linter configuration options to be merged with <code>config</code> if any. The merged result will be merged with the linter's configuration.</p> <code>{}</code> <p>Returns:     Result of the verification.</p> Source code in <code>xrlint\\linter.py</code> <pre><code>def verify_dataset(\n    self,\n    dataset: str | Path | xr.Dataset,\n    *,\n    file_path: str | None = None,\n    config: Config | dict[str, Any] | None = None,\n    **config_kwargs: dict[str, Any],\n) -&gt; Result:\n    \"\"\"Verify a dataset.\n\n    Args:\n        dataset: The dataset. Can be a `xr.Dataset` instance\n            or a file path from which the dataset will be opened.\n        file_path: Optional file path used for formatting\n            messages. Useful if `dataset` is not a file path.\n        config: Configuration tbe merged with the linter's\n            configuration.\n        config_kwargs: Individual linter configuration options\n            to be merged with `config` if any. The merged result\n            will be merged with the linter's configuration.\n    Returns:\n        Result of the verification.\n    \"\"\"\n    config = merge_configs(self._config, config)\n    config = merge_configs(config, config_kwargs)\n\n    error: Exception | None = None\n    if not isinstance(dataset, xr.Dataset):\n        ds_source = dataset\n        dataset, error = open_dataset(ds_source, config.opener_options or {})\n        if not file_path and isinstance(ds_source, (str, Path)):\n            file_path = str(ds_source)\n\n    if dataset is not None and not file_path:\n        file_path = _get_file_path_for_dataset(dataset)\n\n    context = RuleContextImpl(config=config, dataset=dataset, file_path=file_path)\n\n    if error:\n        context.report(str(error), fatal=True)\n    elif not config.rules:\n        context.report(\"No rules configured or applicable.\", fatal=True)\n    else:\n        # TODO: validate config,\n        #   e.g., validate any rule options against rule.meta.schema\n        for rule_id, rule_config in config.rules.items():\n            with context.use_state(rule_id=rule_id):\n                _apply_rule(context, rule_id, rule_config)\n\n    return Result.new(\n        config=config, file_path=context.file_path, messages=context.messages\n    )\n</code></pre>"},{"location":"api/#class-config","title":"Class <code>Config</code>","text":"<p>               Bases: <code>ToDictMixin</code></p> <p>Configuration object. A configuration object contains all the information XRLint needs to execute on a set of dataset files.</p> <p>You should not use the class constructor directly. Instead, use the <code>Config.from_value()</code> function.</p> Source code in <code>xrlint\\config.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass Config(ToDictMixin):\n    \"\"\"Configuration object.\n    A configuration object contains all the information XRLint\n    needs to execute on a set of dataset files.\n\n    You should not use the class constructor directly.\n    Instead, use the `Config.from_value()` function.\n    \"\"\"\n\n    name: str | None = None\n    \"\"\"A name for the configuration object. \n    This is used in error messages and config inspector to help identify \n    which configuration object is being used. \n    \"\"\"\n\n    files: list[str] | None = None\n    \"\"\"An array of glob patterns indicating the files that the \n    configuration object should apply to. If not specified, \n    the configuration object applies to all files matched \n    by any other configuration object.\n    \"\"\"\n\n    ignores: list[str] | None = None\n    \"\"\"An array of glob patterns indicating the files that the \n    configuration object should not apply to. If not specified, \n    the configuration object applies to all files matched by `files`. \n    If `ignores` is used without any other keys in the configuration \n    object, then the patterns act as _global ignores_.\n    \"\"\"\n\n    linter_options: dict[str, Any] | None = None\n    \"\"\"A dictionary containing options related to the linting process.\"\"\"\n\n    opener_options: dict[str, Any] | None = None\n    \"\"\"A dictionary containing options that are passed to \n    the dataset opener.\n    \"\"\"\n\n    processor: Union[\"ProcessorOp\", str, None] = None\n    \"\"\"Either an object compatible with the `ProcessorOp` \n    interface or a string indicating the name of a processor inside \n    of a plugin (i.e., `\"pluginName/processorName\"`).\n    \"\"\"\n\n    plugins: dict[str, \"Plugin\"] | None = None\n    \"\"\"A dictionary containing a name-value mapping of plugin names to \n    plugin objects. When `files` is specified, these plugins are only \n    available to the matching files.\n    \"\"\"\n\n    rules: dict[str, \"RuleConfig\"] | None = None\n    \"\"\"A dictionary containing the configured rules. \n    When `files` or `ignores` are specified, these rule configurations \n    are only available to the matching files.\n    \"\"\"\n\n    settings: dict[str, Any] | None = None\n    \"\"\"A dictionary containing name-value pairs of information \n    that should be available to all rules.\n    \"\"\"\n\n    @classmethod\n    def from_value(cls, value: Any) -&gt; \"Config\":\n        \"\"\"Convert given `value` into a `Config` object.\n\n        If `value` is already a `Config` then it is returned as-is.\n\n        Args:\n            value: A `Config` object, a `dict` containing the\n                configuration properties, or `None` which\n                converts into an empty configuration.\n        Returns:\n            A `Config` object.\n        \"\"\"\n        if isinstance(value, Config):\n            return value\n        if value is None:\n            return Config()\n        if not isinstance(value, dict):\n            raise TypeError(format_message_type_of(\"configuration\", value, \"dict\"))\n        if not value:\n            return Config()\n\n        files = cls._parse_pattern_list(value, \"files\")\n        ignores = cls._parse_pattern_list(value, \"ignores\")\n        linter_options = cls._parse_options(\"linter_options\", value)\n        opener_options = cls._parse_options(\"opener_options\", value)\n        processor = cls._parse_processor(value)\n        plugins = cls._parse_plugins(value)\n        rules = cls._parse_rules(value)\n        settings = cls._parse_options(\"settings\", value)\n\n        return Config(\n            name=value.get(\"name\"),\n            files=files,\n            ignores=ignores,\n            linter_options=linter_options,\n            opener_options=opener_options,\n            processor=processor,\n            plugins=plugins,\n            rules=rules,\n            settings=settings,\n        )\n\n    @property\n    def global_ignores(self) -&gt; list[str]:\n        # The list of `ignores` patterns from this configuration which\n        # are _global ignores_.\n        return (\n            self.ignores\n            if self.ignores\n            and not (\n                self.files\n                or self.linter_options\n                or self.opener_options\n                or self.plugins\n                or self.rules\n                or self.settings\n            )\n            else []\n        )\n\n    def get_rule(self, rule_id: str) -&gt; \"Rule\":\n        \"\"\"Get the rule for the given rule identifier `rule_id`.\n\n        Args:\n            rule_id: The rule identifier including plugin namespace, if any.\n                Format `&lt;rule-name&gt;` (builtin rules) or `&lt;plugin-name&gt;/&lt;rule-name&gt;`.\n        Returns:\n            A `Rule` object.\n        Raises:\n            ValueError: If either the plugin is unknown in this configuration\n                or the rule name is unknown.\n        \"\"\"\n        if \"/\" in rule_id:\n            plugin_name, rule_name = rule_id.split(\"/\", maxsplit=1)\n        else:\n            plugin_name, rule_name = CORE_PLUGIN_NAME, rule_id\n\n        from xrlint.plugin import Plugin\n        from xrlint.rule import Rule\n\n        plugin: Plugin | None = (self.plugins or {}).get(plugin_name)\n        if plugin is None:\n            raise ValueError(f\"unknown plugin {plugin_name!r}\")\n\n        rule: Rule | None = (plugin.rules or {}).get(rule_name)\n        if rule is None:\n            raise ValueError(f\"unknown rule {rule_id!r}\")\n\n        return rule\n\n    def merge(self, config: \"Config\", name: str = None) -&gt; \"Config\":\n        return Config(\n            name=name,\n            files=self._merge_pattern_lists(self.files, config.files),\n            ignores=self._merge_pattern_lists(self.ignores, config.ignores),\n            linter_options=self._merge_options(\n                self.linter_options, config.linter_options\n            ),\n            opener_options=self._merge_options(\n                self.opener_options, config.opener_options\n            ),\n            processor=merge_values(self.processor, config.processor),  # TBD!\n            plugins=self._merge_plugin_dicts(self.plugins, config.plugins),\n            rules=self._merge_rule_dicts(self.rules, config.rules),\n            settings=self._merge_options(self.settings, config.settings),\n        )\n\n    @classmethod\n    def _merge_rule_dicts(\n        cls,\n        rules1: dict[str, \"RuleConfig\"] | None,\n        rules2: dict[str, \"RuleConfig\"] | None,\n    ) -&gt; dict[str, \"RuleConfig\"] | None:\n        from xrlint.rule import RuleConfig\n\n        def merge_items(r1: RuleConfig, r2: RuleConfig) -&gt; RuleConfig:\n            if r1.severity == r2.severity:\n                return RuleConfig(\n                    r2.severity,\n                    merge_arrays(r1.args, r2.args),\n                    merge_dicts(r1.kwargs, r2.kwargs),\n                )\n            return r2\n\n        return merge_dicts(rules1, rules2, merge_items=merge_items)\n\n    @classmethod\n    def _merge_pattern_lists(\n        cls, patterns1: list[str] | None, patterns2: list[str] | None\n    ) -&gt; list[str] | None:\n        return merge_set_lists(patterns1, patterns2)\n\n    @classmethod\n    def _merge_options(\n        cls, settings1: dict[str, Any] | None, settings2: dict[str, Any] | None\n    ) -&gt; dict[str, Any] | None:\n        return merge_dicts(settings1, settings2, merge_items=merge_values)\n\n    @classmethod\n    def _merge_plugin_dicts(\n        cls,\n        plugins1: dict[str, \"Plugin\"] | None,\n        plugins2: dict[str, \"Plugin\"] | None,\n    ) -&gt; dict[str, \"RuleConfig\"] | None:\n        from xrlint.plugin import Plugin\n\n        def merge_items(_p1: Plugin, p2: Plugin) -&gt; Plugin:\n            return p2\n\n        return merge_dicts(plugins1, plugins2, merge_items=merge_items)\n\n    @classmethod\n    def _parse_pattern_list(cls, config_dict: dict, name) -&gt; list[str]:\n        patterns = config_dict.get(name)\n        if isinstance(patterns, list):\n            return [cls._parse_pattern(name, v) for v in patterns]\n        if patterns is not None:\n            raise TypeError(\n                format_message_type_of(f\"{name} configuration\", patterns, \"list[str]\")\n            )\n\n    @classmethod\n    def _parse_pattern(cls, name, pattern):\n        if not isinstance(pattern, str):\n            raise TypeError(\n                format_message_type_of(f\"pattern in {name} configuration\", pattern, str)\n            )\n\n    @classmethod\n    def _parse_processor(cls, config_dict: dict) -&gt; Union[\"ProcessorOp\", str, None]:\n        from xrlint.processor import ProcessorOp\n\n        processor = config_dict.get(\"processor\")\n        if processor is None or isinstance(processor, (str, ProcessorOp)):\n            return processor\n        raise TypeError(\n            format_message_type_of(\n                \"processor configuration\", processor, \"ProcessorOp|str|None\"\n            )\n        )\n\n    @classmethod\n    def _parse_plugins(cls, config_dict: dict) -&gt; dict[str, \"Plugin\"]:\n        from xrlint.plugin import Plugin\n\n        plugins = config_dict.get(\"plugins\")\n        if isinstance(plugins, dict):\n            return {k: Plugin.from_value(v) for k, v in plugins.items()}\n        if plugins is not None:\n            raise TypeError(\n                format_message_type_of(\"plugins configuration\", plugins, \"dict\")\n            )\n\n    @classmethod\n    def _parse_rules(cls, config_dict: dict) -&gt; dict[str, \"RuleConfig\"]:\n        from xrlint.rule import RuleConfig\n\n        rules = config_dict.get(\"rules\")\n        if isinstance(rules, dict):\n            return {rn: RuleConfig.from_value(rc) for rn, rc in rules.items()}\n        if rules is not None:\n            raise TypeError(\n                format_message_type_of(\"rules configuration\", rules, \"dict\")\n            )\n\n    @classmethod\n    def _parse_options(cls, name: str, config_dict: dict) -&gt; dict[str, Any]:\n        settings = config_dict.get(\"settings\")\n        if isinstance(settings, dict):\n            for k, v in settings.items():\n                if not isinstance(k, str):\n                    raise TypeError(format_message_type_of(f\"{name} keys\", k, str))\n            return {k: v for k, v in settings.items()}\n        if settings is not None:\n            raise TypeError(format_message_type_of(name, settings, \"dict[str,Any]\"))\n</code></pre>"},{"location":"api/#xrlint.config.Config.name","title":"<code>name = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A name for the configuration object.  This is used in error messages and config inspector to help identify  which configuration object is being used.</p>"},{"location":"api/#xrlint.config.Config.files","title":"<code>files = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An array of glob patterns indicating the files that the  configuration object should apply to. If not specified,  the configuration object applies to all files matched  by any other configuration object.</p>"},{"location":"api/#xrlint.config.Config.ignores","title":"<code>ignores = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An array of glob patterns indicating the files that the  configuration object should not apply to. If not specified,  the configuration object applies to all files matched by <code>files</code>.  If <code>ignores</code> is used without any other keys in the configuration  object, then the patterns act as global ignores.</p>"},{"location":"api/#xrlint.config.Config.linter_options","title":"<code>linter_options = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary containing options related to the linting process.</p>"},{"location":"api/#xrlint.config.Config.opener_options","title":"<code>opener_options = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary containing options that are passed to  the dataset opener.</p>"},{"location":"api/#xrlint.config.Config.processor","title":"<code>processor = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Either an object compatible with the <code>ProcessorOp</code>  interface or a string indicating the name of a processor inside  of a plugin (i.e., <code>\"pluginName/processorName\"</code>).</p>"},{"location":"api/#xrlint.config.Config.plugins","title":"<code>plugins = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary containing a name-value mapping of plugin names to  plugin objects. When <code>files</code> is specified, these plugins are only  available to the matching files.</p>"},{"location":"api/#xrlint.config.Config.rules","title":"<code>rules = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary containing the configured rules.  When <code>files</code> or <code>ignores</code> are specified, these rule configurations  are only available to the matching files.</p>"},{"location":"api/#xrlint.config.Config.settings","title":"<code>settings = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary containing name-value pairs of information  that should be available to all rules.</p>"},{"location":"api/#xrlint.config.Config.from_value","title":"<code>from_value(value)</code>  <code>classmethod</code>","text":"<p>Convert given <code>value</code> into a <code>Config</code> object.</p> <p>If <code>value</code> is already a <code>Config</code> then it is returned as-is.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>A <code>Config</code> object, a <code>dict</code> containing the configuration properties, or <code>None</code> which converts into an empty configuration.</p> required <p>Returns:     A <code>Config</code> object.</p> Source code in <code>xrlint\\config.py</code> <pre><code>@classmethod\ndef from_value(cls, value: Any) -&gt; \"Config\":\n    \"\"\"Convert given `value` into a `Config` object.\n\n    If `value` is already a `Config` then it is returned as-is.\n\n    Args:\n        value: A `Config` object, a `dict` containing the\n            configuration properties, or `None` which\n            converts into an empty configuration.\n    Returns:\n        A `Config` object.\n    \"\"\"\n    if isinstance(value, Config):\n        return value\n    if value is None:\n        return Config()\n    if not isinstance(value, dict):\n        raise TypeError(format_message_type_of(\"configuration\", value, \"dict\"))\n    if not value:\n        return Config()\n\n    files = cls._parse_pattern_list(value, \"files\")\n    ignores = cls._parse_pattern_list(value, \"ignores\")\n    linter_options = cls._parse_options(\"linter_options\", value)\n    opener_options = cls._parse_options(\"opener_options\", value)\n    processor = cls._parse_processor(value)\n    plugins = cls._parse_plugins(value)\n    rules = cls._parse_rules(value)\n    settings = cls._parse_options(\"settings\", value)\n\n    return Config(\n        name=value.get(\"name\"),\n        files=files,\n        ignores=ignores,\n        linter_options=linter_options,\n        opener_options=opener_options,\n        processor=processor,\n        plugins=plugins,\n        rules=rules,\n        settings=settings,\n    )\n</code></pre>"},{"location":"api/#xrlint.config.Config.get_rule","title":"<code>get_rule(rule_id)</code>","text":"<p>Get the rule for the given rule identifier <code>rule_id</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rule_id</code> <code>str</code> <p>The rule identifier including plugin namespace, if any. Format <code>&lt;rule-name&gt;</code> (builtin rules) or <code>&lt;plugin-name&gt;/&lt;rule-name&gt;</code>.</p> required <p>Returns:     A <code>Rule</code> object. Raises:     ValueError: If either the plugin is unknown in this configuration         or the rule name is unknown.</p> Source code in <code>xrlint\\config.py</code> <pre><code>def get_rule(self, rule_id: str) -&gt; \"Rule\":\n    \"\"\"Get the rule for the given rule identifier `rule_id`.\n\n    Args:\n        rule_id: The rule identifier including plugin namespace, if any.\n            Format `&lt;rule-name&gt;` (builtin rules) or `&lt;plugin-name&gt;/&lt;rule-name&gt;`.\n    Returns:\n        A `Rule` object.\n    Raises:\n        ValueError: If either the plugin is unknown in this configuration\n            or the rule name is unknown.\n    \"\"\"\n    if \"/\" in rule_id:\n        plugin_name, rule_name = rule_id.split(\"/\", maxsplit=1)\n    else:\n        plugin_name, rule_name = CORE_PLUGIN_NAME, rule_id\n\n    from xrlint.plugin import Plugin\n    from xrlint.rule import Rule\n\n    plugin: Plugin | None = (self.plugins or {}).get(plugin_name)\n    if plugin is None:\n        raise ValueError(f\"unknown plugin {plugin_name!r}\")\n\n    rule: Rule | None = (plugin.rules or {}).get(rule_name)\n    if rule is None:\n        raise ValueError(f\"unknown rule {rule_id!r}\")\n\n    return rule\n</code></pre>"},{"location":"api/#class-configlist","title":"Class <code>ConfigList</code>","text":"<p>A holder for a list of <code>Config</code> objects.</p> <p>You should not use the class constructor directly. Instead, use the <code>ConfigList.from_value()</code> function.</p> Source code in <code>xrlint\\config.py</code> <pre><code>@dataclass(frozen=True)\nclass ConfigList:\n    \"\"\"A holder for a list of `Config` objects.\n\n    You should not use the class constructor directly.\n    Instead, use the `ConfigList.from_value()` function.\n    \"\"\"\n\n    configs: list[Config] = field(default_factory=list)\n    \"\"\"The list of `Config` objects.\"\"\"\n\n    @classmethod\n    def from_value(cls, value: Any) -&gt; \"ConfigList\":\n        \"\"\"Convert given `value` into a `ConfigList` object.\n\n        If `value` is already a `ConfigList` then it is returned as-is.\n\n        Args:\n            value: A `ConfigList` object or `list` of items which can be\n                converted into `Config` objects including configuration\n                names of tyype `str`. The latter are resolved against\n                the plugin configurations seen so far in the list.\n        Returns:\n            A `ConfigList` object.\n        \"\"\"\n        if isinstance(value, ConfigList):\n            return value\n        if not isinstance(value, list):\n            raise TypeError(\n                format_message_type_of(\n                    \"configuration list\", value, \"ConfigList|list[Config|dict|str]\"\n                )\n            )\n\n        configs = []\n        plugins = {}\n        for item in value:\n            if isinstance(item, str):\n                plugin_name, config_name = (\n                    item.split(\"/\", maxsplit=1)\n                    if \"/\" in item\n                    else (CORE_PLUGIN_NAME, item)\n                )\n                if CORE_PLUGIN_NAME not in plugins:\n                    plugins.update({CORE_PLUGIN_NAME: get_core_plugin()})\n                plugin: Plugin | None = plugins.get(plugin_name)\n                if (\n                    plugin is None\n                    or not plugin.configs\n                    or config_name not in plugin.configs\n                ):\n                    raise ValueError(f\"configuration {item!r} not found\")\n                config = Config.from_value(plugin.configs[config_name])\n            else:\n                config = Config.from_value(item)\n            configs.append(config)\n            plugins.update(config.plugins if config.plugins else {})\n\n        return ConfigList(configs=configs)\n\n    def compute_config(self, file_path: str) -&gt; Config | None:\n        \"\"\"Compute the configuration object for the given file path.\n\n        Args:\n            file_path: A dataset file path.\n        Returns:\n            A `Config` object which may be empty, or `None`\n            if `file_path` is not included by any `files` pattern\n            or intentionally ignored by global `ignores`.\n        \"\"\"\n        # Step 1: Check against global ignores\n        global_ignores = set()\n        effective_configs = []\n        for c in self.configs:\n            ignores = c.global_ignores\n            if ignores:\n                global_ignores.update(ignores)\n            else:\n                effective_configs.append(c)\n        for p in global_ignores:\n            if fnmatch.fnmatch(file_path, p):\n                return None\n\n        # Step 2: Check against global ignores\n        config = None\n        for c in effective_configs:\n            excluded = False\n            if c.ignores:\n                for p in c.ignores:\n                    excluded = fnmatch.fnmatch(file_path, p)\n                    if excluded:\n                        break\n            included = not excluded\n            if included:\n                if c.files:\n                    for p in c.files:\n                        included = fnmatch.fnmatch(file_path, p)\n                        if not included:\n                            break\n            if included:\n                config = config.merge(c) if config is not None else c\n\n        if config is None:\n            return None\n        # Exclude \"files\" and \"ignores\" because they have been used\n        return Config(\n            name=\"&lt;computed&gt;\",\n            linter_options=config.linter_options,\n            opener_options=config.opener_options,\n            processor=config.processor,\n            plugins=config.plugins,\n            rules=config.rules,\n            settings=config.settings,\n        )\n</code></pre>"},{"location":"api/#xrlint.config.ConfigList.configs","title":"<code>configs = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The list of <code>Config</code> objects.</p>"},{"location":"api/#xrlint.config.ConfigList.from_value","title":"<code>from_value(value)</code>  <code>classmethod</code>","text":"<p>Convert given <code>value</code> into a <code>ConfigList</code> object.</p> <p>If <code>value</code> is already a <code>ConfigList</code> then it is returned as-is.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>A <code>ConfigList</code> object or <code>list</code> of items which can be converted into <code>Config</code> objects including configuration names of tyype <code>str</code>. The latter are resolved against the plugin configurations seen so far in the list.</p> required <p>Returns:     A <code>ConfigList</code> object.</p> Source code in <code>xrlint\\config.py</code> <pre><code>@classmethod\ndef from_value(cls, value: Any) -&gt; \"ConfigList\":\n    \"\"\"Convert given `value` into a `ConfigList` object.\n\n    If `value` is already a `ConfigList` then it is returned as-is.\n\n    Args:\n        value: A `ConfigList` object or `list` of items which can be\n            converted into `Config` objects including configuration\n            names of tyype `str`. The latter are resolved against\n            the plugin configurations seen so far in the list.\n    Returns:\n        A `ConfigList` object.\n    \"\"\"\n    if isinstance(value, ConfigList):\n        return value\n    if not isinstance(value, list):\n        raise TypeError(\n            format_message_type_of(\n                \"configuration list\", value, \"ConfigList|list[Config|dict|str]\"\n            )\n        )\n\n    configs = []\n    plugins = {}\n    for item in value:\n        if isinstance(item, str):\n            plugin_name, config_name = (\n                item.split(\"/\", maxsplit=1)\n                if \"/\" in item\n                else (CORE_PLUGIN_NAME, item)\n            )\n            if CORE_PLUGIN_NAME not in plugins:\n                plugins.update({CORE_PLUGIN_NAME: get_core_plugin()})\n            plugin: Plugin | None = plugins.get(plugin_name)\n            if (\n                plugin is None\n                or not plugin.configs\n                or config_name not in plugin.configs\n            ):\n                raise ValueError(f\"configuration {item!r} not found\")\n            config = Config.from_value(plugin.configs[config_name])\n        else:\n            config = Config.from_value(item)\n        configs.append(config)\n        plugins.update(config.plugins if config.plugins else {})\n\n    return ConfigList(configs=configs)\n</code></pre>"},{"location":"api/#xrlint.config.ConfigList.compute_config","title":"<code>compute_config(file_path)</code>","text":"<p>Compute the configuration object for the given file path.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>A dataset file path.</p> required <p>Returns:     A <code>Config</code> object which may be empty, or <code>None</code>     if <code>file_path</code> is not included by any <code>files</code> pattern     or intentionally ignored by global <code>ignores</code>.</p> Source code in <code>xrlint\\config.py</code> <pre><code>def compute_config(self, file_path: str) -&gt; Config | None:\n    \"\"\"Compute the configuration object for the given file path.\n\n    Args:\n        file_path: A dataset file path.\n    Returns:\n        A `Config` object which may be empty, or `None`\n        if `file_path` is not included by any `files` pattern\n        or intentionally ignored by global `ignores`.\n    \"\"\"\n    # Step 1: Check against global ignores\n    global_ignores = set()\n    effective_configs = []\n    for c in self.configs:\n        ignores = c.global_ignores\n        if ignores:\n            global_ignores.update(ignores)\n        else:\n            effective_configs.append(c)\n    for p in global_ignores:\n        if fnmatch.fnmatch(file_path, p):\n            return None\n\n    # Step 2: Check against global ignores\n    config = None\n    for c in effective_configs:\n        excluded = False\n        if c.ignores:\n            for p in c.ignores:\n                excluded = fnmatch.fnmatch(file_path, p)\n                if excluded:\n                    break\n        included = not excluded\n        if included:\n            if c.files:\n                for p in c.files:\n                    included = fnmatch.fnmatch(file_path, p)\n                    if not included:\n                        break\n        if included:\n            config = config.merge(c) if config is not None else c\n\n    if config is None:\n        return None\n    # Exclude \"files\" and \"ignores\" because they have been used\n    return Config(\n        name=\"&lt;computed&gt;\",\n        linter_options=config.linter_options,\n        opener_options=config.opener_options,\n        processor=config.processor,\n        plugins=config.plugins,\n        rules=config.rules,\n        settings=config.settings,\n    )\n</code></pre>"},{"location":"api/#class-ruleconfig","title":"Class <code>RuleConfig</code>","text":"<p>A rule configuration.</p> <p>You should not use the class constructor directly. Instead, use the <code>RuleConfig.from_value()</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>severity</code> <code>Literal[0, 1, 2]</code> <p>rule severity, one of <code>2</code> (error), <code>1</code> (warn), or <code>0</code> (off)</p> required <code>args</code> <code>tuple[Any, ...]</code> <p>rule operation arguments.</p> <code>tuple()</code> <code>kwargs</code> <code>dict[str, Any]</code> <p>rule operation keyword-arguments.</p> <code>dict()</code> Source code in <code>xrlint\\rule.py</code> <pre><code>@dataclass(frozen=True)\nclass RuleConfig:\n    \"\"\"A rule configuration.\n\n    You should not use the class constructor directly.\n    Instead, use the `RuleConfig.from_value()` function.\n\n    Args:\n        severity: rule severity, one of `2` (error), `1` (warn), or `0` (off)\n        args: rule operation arguments.\n        kwargs: rule operation keyword-arguments.\n    \"\"\"\n\n    severity: Literal[0, 1, 2]\n    \"\"\"Rule severity.\"\"\"\n\n    args: tuple[Any, ...] = field(default_factory=tuple)\n    \"\"\"Rule operation arguments.\"\"\"\n\n    kwargs: dict[str, Any] = field(default_factory=dict)\n    \"\"\"Rule operation keyword-arguments.\"\"\"\n\n    @classmethod\n    def from_value(cls, value: Any) -&gt; \"RuleConfig\":\n        \"\"\"Convert `value` into a `RuleConfig` object.\n\n        A rule configuration value can either be a rule _severity_,\n        or a list where the first element is a rule\n        _severity_ and subsequent elements are rule arguments:\n\n        - _severity_\n        - `[`_severity_`]`\n        - `[`_severity_`,` _arg-1 | kwargs_ `]`\n        - `[`_severity_`,` _arg-1_`,` _arg-2_`,` ...`,` _arg-n | kwargs_`]`\n\n        The rule _severity_ is either\n\n        - one of `\"error\"`, `\"warn\"`, `\"off\"` or\n        - one of `2` (error), `1` (warn), `0` (off)\n\n        Args:\n            value: A rule severity or a list where the first element is a rule\n                severity and subsequent elements are rule arguments.\n                If the value is already of type `RuleConfig`it is returned as-is.\n        Returns:\n            A `RuleConfig` object.\n        \"\"\"\n        if isinstance(value, RuleConfig):\n            return value\n\n        if isinstance(value, (int, str)):\n            severity_value, options = value, ()\n        elif isinstance(value, (list, tuple)):\n            severity_value, options = (value[0], value[1:]) if value else (0, ())\n        else:\n            raise TypeError(\n                format_message_type_of(\n                    \"rule configuration\", value, \"int|str|tuple|list\"\n                )\n            )\n\n        try:\n            severity = SEVERITY_ENUM[severity_value]\n        except KeyError:\n            raise ValueError(\n                format_message_one_of(\"severity\", severity_value, SEVERITY_ENUM_TEXT)\n            )\n\n        if not options:\n            args, kwargs = (), {}\n        elif isinstance(options[-1], dict):\n            args, kwargs = options[:-1], options[-1]\n        else:\n            args, kwargs = options, {}\n\n        # noinspection PyTypeChecker\n        return RuleConfig(severity, tuple(args), dict(kwargs))\n</code></pre>"},{"location":"api/#xrlint.rule.RuleConfig.severity","title":"<code>severity</code>  <code>instance-attribute</code>","text":"<p>Rule severity.</p>"},{"location":"api/#xrlint.rule.RuleConfig.args","title":"<code>args = field(default_factory=tuple)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rule operation arguments.</p>"},{"location":"api/#xrlint.rule.RuleConfig.kwargs","title":"<code>kwargs = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rule operation keyword-arguments.</p>"},{"location":"api/#xrlint.rule.RuleConfig.from_value","title":"<code>from_value(value)</code>  <code>classmethod</code>","text":"<p>Convert <code>value</code> into a <code>RuleConfig</code> object.</p> <p>A rule configuration value can either be a rule severity, or a list where the first element is a rule severity and subsequent elements are rule arguments:</p> <ul> <li>severity</li> <li><code>[</code>severity<code>]</code></li> <li><code>[</code>severity<code>,</code> arg-1 | kwargs <code>]</code></li> <li><code>[</code>severity<code>,</code> arg-1<code>,</code> arg-2<code>,</code> ...<code>,</code> arg-n | kwargs<code>]</code></li> </ul> <p>The rule severity is either</p> <ul> <li>one of <code>\"error\"</code>, <code>\"warn\"</code>, <code>\"off\"</code> or</li> <li>one of <code>2</code> (error), <code>1</code> (warn), <code>0</code> (off)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>A rule severity or a list where the first element is a rule severity and subsequent elements are rule arguments. If the value is already of type <code>RuleConfig</code>it is returned as-is.</p> required <p>Returns:     A <code>RuleConfig</code> object.</p> Source code in <code>xrlint\\rule.py</code> <pre><code>@classmethod\ndef from_value(cls, value: Any) -&gt; \"RuleConfig\":\n    \"\"\"Convert `value` into a `RuleConfig` object.\n\n    A rule configuration value can either be a rule _severity_,\n    or a list where the first element is a rule\n    _severity_ and subsequent elements are rule arguments:\n\n    - _severity_\n    - `[`_severity_`]`\n    - `[`_severity_`,` _arg-1 | kwargs_ `]`\n    - `[`_severity_`,` _arg-1_`,` _arg-2_`,` ...`,` _arg-n | kwargs_`]`\n\n    The rule _severity_ is either\n\n    - one of `\"error\"`, `\"warn\"`, `\"off\"` or\n    - one of `2` (error), `1` (warn), `0` (off)\n\n    Args:\n        value: A rule severity or a list where the first element is a rule\n            severity and subsequent elements are rule arguments.\n            If the value is already of type `RuleConfig`it is returned as-is.\n    Returns:\n        A `RuleConfig` object.\n    \"\"\"\n    if isinstance(value, RuleConfig):\n        return value\n\n    if isinstance(value, (int, str)):\n        severity_value, options = value, ()\n    elif isinstance(value, (list, tuple)):\n        severity_value, options = (value[0], value[1:]) if value else (0, ())\n    else:\n        raise TypeError(\n            format_message_type_of(\n                \"rule configuration\", value, \"int|str|tuple|list\"\n            )\n        )\n\n    try:\n        severity = SEVERITY_ENUM[severity_value]\n    except KeyError:\n        raise ValueError(\n            format_message_one_of(\"severity\", severity_value, SEVERITY_ENUM_TEXT)\n        )\n\n    if not options:\n        args, kwargs = (), {}\n    elif isinstance(options[-1], dict):\n        args, kwargs = options[:-1], options[-1]\n    else:\n        args, kwargs = options, {}\n\n    # noinspection PyTypeChecker\n    return RuleConfig(severity, tuple(args), dict(kwargs))\n</code></pre>"},{"location":"api/#class-rule","title":"Class <code>Rule</code>","text":"<p>A rule.</p> Source code in <code>xrlint\\rule.py</code> <pre><code>@dataclass(frozen=True)\nclass Rule:\n    \"\"\"A rule.\"\"\"\n\n    meta: RuleMeta\n    \"\"\"Rule metadata of type `RuleMeta`.\"\"\"\n\n    op_class: Type[RuleOp]\n    \"\"\"The class the implements the rule's verification operation.\n    The class must implement the `RuleOp` interface. \n    \"\"\"\n</code></pre>"},{"location":"api/#xrlint.rule.Rule.meta","title":"<code>meta</code>  <code>instance-attribute</code>","text":"<p>Rule metadata of type <code>RuleMeta</code>.</p>"},{"location":"api/#xrlint.rule.Rule.op_class","title":"<code>op_class</code>  <code>instance-attribute</code>","text":"<p>The class the implements the rule's verification operation. The class must implement the <code>RuleOp</code> interface.</p>"},{"location":"api/#class-rulemeta","title":"Class <code>RuleMeta</code>","text":"<p>               Bases: <code>ToDictMixin</code></p> <p>Rule metadata.</p> Source code in <code>xrlint\\rule.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass RuleMeta(ToDictMixin):\n    \"\"\"Rule metadata.\"\"\"\n\n    name: str\n    \"\"\"Rule name. Mandatory.\"\"\"\n\n    version: str = \"0.0.0\"\n    \"\"\"Rule version. Defaults to `0.0.0`.\"\"\"\n\n    description: str | None = None\n    \"\"\"Rule description.\"\"\"\n\n    docs_url: str | None = None\n    \"\"\"Rule documentation URL.\"\"\"\n\n    schema: dict[str, Any] | list[dict[str, Any]] | bool | None = None\n    \"\"\"JSON Schema used to specify and validate the rule verifier's \n    options.\n\n    It can take the following values:\n\n    - Use `None` (the default) to indicate that the rule verifier \n      as no options at all.\n    - Use a schema to indicate that the rule verifier \n      takes keyword arguments only.  \n      The schema's type must be `\"object\"`.\n    - Use a list of schemas to indicate that the rule verifier\n      takes positional arguments only. \n      If given, the number of schemas in the list specifies the \n      number of positional arguments that must be configured.\n    \"\"\"\n\n    type: Literal[\"problem\", \"suggestion\"] = \"problem\"\n    \"\"\"Rule type. Defaults to `\"problem\"`.\"\"\"\n</code></pre>"},{"location":"api/#xrlint.rule.RuleMeta.name","title":"<code>name</code>  <code>instance-attribute</code>","text":"<p>Rule name. Mandatory.</p>"},{"location":"api/#xrlint.rule.RuleMeta.version","title":"<code>version = '0.0.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rule version. Defaults to <code>0.0.0</code>.</p>"},{"location":"api/#xrlint.rule.RuleMeta.description","title":"<code>description = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rule description.</p>"},{"location":"api/#xrlint.rule.RuleMeta.docs_url","title":"<code>docs_url = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rule documentation URL.</p>"},{"location":"api/#xrlint.rule.RuleMeta.schema","title":"<code>schema = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>JSON Schema used to specify and validate the rule verifier's  options.</p> <p>It can take the following values:</p> <ul> <li>Use <code>None</code> (the default) to indicate that the rule verifier    as no options at all.</li> <li>Use a schema to indicate that the rule verifier    takes keyword arguments only.   The schema's type must be <code>\"object\"</code>.</li> <li>Use a list of schemas to indicate that the rule verifier   takes positional arguments only.    If given, the number of schemas in the list specifies the    number of positional arguments that must be configured.</li> </ul>"},{"location":"api/#xrlint.rule.RuleMeta.type","title":"<code>type = 'problem'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rule type. Defaults to <code>\"problem\"</code>.</p>"},{"location":"api/#class-ruleop","title":"Class <code>RuleOp</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Define the specific rule verification operation.</p> Source code in <code>xrlint\\rule.py</code> <pre><code>class RuleOp(ABC):\n    \"\"\"Define the specific rule verification operation.\"\"\"\n\n    def dataset(self, context: RuleContext, node: DatasetNode) -&gt; None:\n        \"\"\"Verify the given dataset node.\n\n        Args:\n            context: The current rule context.\n            node: The dataset node.\n        \"\"\"\n\n    def data_array(self, context: RuleContext, node: DataArrayNode) -&gt; None:\n        \"\"\"Verify the given data array (variable) node.\n\n        Args:\n            context: The current rule context.\n            node: The data array (variable) node.\n        \"\"\"\n\n    def attrs(self, context: RuleContext, node: AttrsNode) -&gt; None:\n        \"\"\"Verify the given attributes node.\n\n        Args:\n            context: The current rule context.\n            node: The attributes node.\n        \"\"\"\n\n    def attr(self, context: RuleContext, node: AttrNode) -&gt; None:\n        \"\"\"Verify the given attribute node.\n\n        Args:\n            context: The current rule context.\n            node: The attribute node.\n        \"\"\"\n</code></pre>"},{"location":"api/#xrlint.rule.RuleOp.dataset","title":"<code>dataset(context, node)</code>","text":"<p>Verify the given dataset node.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>RuleContext</code> <p>The current rule context.</p> required <code>node</code> <code>DatasetNode</code> <p>The dataset node.</p> required Source code in <code>xrlint\\rule.py</code> <pre><code>def dataset(self, context: RuleContext, node: DatasetNode) -&gt; None:\n    \"\"\"Verify the given dataset node.\n\n    Args:\n        context: The current rule context.\n        node: The dataset node.\n    \"\"\"\n</code></pre>"},{"location":"api/#xrlint.rule.RuleOp.data_array","title":"<code>data_array(context, node)</code>","text":"<p>Verify the given data array (variable) node.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>RuleContext</code> <p>The current rule context.</p> required <code>node</code> <code>DataArrayNode</code> <p>The data array (variable) node.</p> required Source code in <code>xrlint\\rule.py</code> <pre><code>def data_array(self, context: RuleContext, node: DataArrayNode) -&gt; None:\n    \"\"\"Verify the given data array (variable) node.\n\n    Args:\n        context: The current rule context.\n        node: The data array (variable) node.\n    \"\"\"\n</code></pre>"},{"location":"api/#xrlint.rule.RuleOp.attrs","title":"<code>attrs(context, node)</code>","text":"<p>Verify the given attributes node.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>RuleContext</code> <p>The current rule context.</p> required <code>node</code> <code>AttrsNode</code> <p>The attributes node.</p> required Source code in <code>xrlint\\rule.py</code> <pre><code>def attrs(self, context: RuleContext, node: AttrsNode) -&gt; None:\n    \"\"\"Verify the given attributes node.\n\n    Args:\n        context: The current rule context.\n        node: The attributes node.\n    \"\"\"\n</code></pre>"},{"location":"api/#xrlint.rule.RuleOp.attr","title":"<code>attr(context, node)</code>","text":"<p>Verify the given attribute node.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>RuleContext</code> <p>The current rule context.</p> required <code>node</code> <code>AttrNode</code> <p>The attribute node.</p> required Source code in <code>xrlint\\rule.py</code> <pre><code>def attr(self, context: RuleContext, node: AttrNode) -&gt; None:\n    \"\"\"Verify the given attribute node.\n\n    Args:\n        context: The current rule context.\n        node: The attribute node.\n    \"\"\"\n</code></pre>"},{"location":"api/#class-rulecontext","title":"Class <code>RuleContext</code>","text":"<p>               Bases: <code>ABC</code></p> <p>The context passed to the verifier of a rule.</p> <p>You should never create instances of this class yourself. Instances of this interface are passed to the <code>RuleOp</code>'s methods.</p> Source code in <code>xrlint\\rule.py</code> <pre><code>class RuleContext(ABC):\n    \"\"\"The context passed to the verifier of a rule.\n\n    You should never create instances of this class yourself.\n    Instances of this interface are passed to the `RuleOp`'s\n    methods.\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def settings(self) -&gt; dict[str, Any]:\n        \"\"\"Configuration settings.\"\"\"\n\n    @property\n    @abstractmethod\n    def dataset(self) -&gt; xr.Dataset:\n        \"\"\"Get the current dataset.\"\"\"\n\n    @property\n    @abstractmethod\n    def file_path(self) -&gt; str:\n        \"\"\"Get the current dataset's file path.\"\"\"\n\n    @abstractmethod\n    def report(\n        self,\n        message: str,\n        *,\n        fatal: bool | None = None,\n        suggestions: list[Suggestion | str] | None = None,\n    ):\n        \"\"\"Report an issue.\n\n        Args:\n            message: mandatory message text\n            fatal: True, if a fatal error is reported.\n            suggestions: A list of suggestions for the user\n                on how to fix the reported issue. Items may\n                be of type `Suggestion` or `str`.\n        \"\"\"\n</code></pre>"},{"location":"api/#xrlint.rule.RuleContext.settings","title":"<code>settings</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Configuration settings.</p>"},{"location":"api/#xrlint.rule.RuleContext.dataset","title":"<code>dataset</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the current dataset.</p>"},{"location":"api/#xrlint.rule.RuleContext.file_path","title":"<code>file_path</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the current dataset's file path.</p>"},{"location":"api/#xrlint.rule.RuleContext.report","title":"<code>report(message, *, fatal=None, suggestions=None)</code>  <code>abstractmethod</code>","text":"<p>Report an issue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>mandatory message text</p> required <code>fatal</code> <code>bool | None</code> <p>True, if a fatal error is reported.</p> <code>None</code> <code>suggestions</code> <code>list[Suggestion | str] | None</code> <p>A list of suggestions for the user on how to fix the reported issue. Items may be of type <code>Suggestion</code> or <code>str</code>.</p> <code>None</code> Source code in <code>xrlint\\rule.py</code> <pre><code>@abstractmethod\ndef report(\n    self,\n    message: str,\n    *,\n    fatal: bool | None = None,\n    suggestions: list[Suggestion | str] | None = None,\n):\n    \"\"\"Report an issue.\n\n    Args:\n        message: mandatory message text\n        fatal: True, if a fatal error is reported.\n        suggestions: A list of suggestions for the user\n            on how to fix the reported issue. Items may\n            be of type `Suggestion` or `str`.\n    \"\"\"\n</code></pre>"},{"location":"api/#class-result","title":"Class <code>Result</code>","text":"<p>               Bases: <code>ToDictMixin</code></p> <p>The aggregated information of linting a dataset.</p> Source code in <code>xrlint\\result.py</code> <pre><code>@dataclass()\nclass Result(ToDictMixin):\n    \"\"\"The aggregated information of linting a dataset.\"\"\"\n\n    config: Union[\"Config\", None] = None\n    \"\"\"Configuration.\"\"\"\n\n    file_path: str = MISSING_DATASET_FILE_PATH\n    \"\"\"The absolute path to the file of this result. \n    This is the string \"&lt;dataset&gt;\" if the file path is unknown \n    (when you didn't pass the `file_path` option to the \n    `xrlint.lint_dataset()` method).\n    \"\"\"\n\n    messages: list[Message] = field(default_factory=list)\n    \"\"\"The array of message objects.\"\"\"\n\n    fixable_error_count: int = 0\n    \"\"\"The number of errors that can be fixed automatically by the fix constructor option.\"\"\"\n\n    fixable_warning_count: int = 0\n    \"\"\"The number of warnings that can be fixed automatically by the fix constructor option.\"\"\"\n\n    error_count: int = 0\n    \"\"\"The number of errors. This includes fixable errors and fatal errors.\"\"\"\n\n    fatal_error_count: int = 0\n    \"\"\"The number of fatal errors.\"\"\"\n\n    warning_count: int = 0\n    \"\"\"The number of warnings. This includes fixable warnings.\"\"\"\n\n    @classmethod\n    def new(\n        cls,\n        config: Union[\"Config\", None] = None,\n        file_path: str | None = None,\n        messages: list[Message] | None = None,\n    ):\n        result = Result(\n            config=config,\n            file_path=file_path or MISSING_DATASET_FILE_PATH,\n            messages=messages or [],\n        )\n        for m in messages:\n            result.warning_count += 1 if m.severity == SEVERITY_WARN else 0\n            result.error_count += 1 if m.severity == SEVERITY_ERROR else 0\n            result.fatal_error_count += 1 if m.fatal else 0\n        return result\n\n    def to_html(self) -&gt; str:\n        text = []\n        escaped_path = html.escape(self.file_path)\n        if not self.messages:\n            text.append(f'&lt;p role=\"file\"&gt;{escaped_path} - ok&lt;/p&gt;\\n')\n        else:\n            text.append(f'&lt;p role=\"file\"&gt;{escaped_path}:&lt;/p&gt;\\n')\n            table_data = []\n            for m in self.messages:\n                table_data.append(\n                    [\n                        m.node_path,\n                        SEVERITY_CODE_TO_NAME.get(m.severity),\n                        m.message,\n                        m.rule_id,\n                    ]\n                )\n            text.append(tabulate(table_data, headers=(), tablefmt=\"html\"))\n            text.append(\n                '&lt;p role=\"summary\"&gt;'\n                f\"{format_problems(self.error_count, self.warning_count)}\"\n                \"&lt;/p&gt;\\n\"\n            )\n        return \"\".join(text)\n\n    def _repr_html_(self) -&gt; str:\n        return self.to_html()\n</code></pre>"},{"location":"api/#xrlint.result.Result.config","title":"<code>config = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Configuration.</p>"},{"location":"api/#xrlint.result.Result.file_path","title":"<code>file_path = MISSING_DATASET_FILE_PATH</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The absolute path to the file of this result.  This is the string \"\" if the file path is unknown  (when you didn't pass the <code>file_path</code> option to the  <code>xrlint.lint_dataset()</code> method)."},{"location":"api/#xrlint.result.Result.messages","title":"<code>messages = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The array of message objects.</p>"},{"location":"api/#xrlint.result.Result.fixable_error_count","title":"<code>fixable_error_count = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The number of errors that can be fixed automatically by the fix constructor option.</p>"},{"location":"api/#xrlint.result.Result.fixable_warning_count","title":"<code>fixable_warning_count = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The number of warnings that can be fixed automatically by the fix constructor option.</p>"},{"location":"api/#xrlint.result.Result.error_count","title":"<code>error_count = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The number of errors. This includes fixable errors and fatal errors.</p>"},{"location":"api/#xrlint.result.Result.fatal_error_count","title":"<code>fatal_error_count = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The number of fatal errors.</p>"},{"location":"api/#xrlint.result.Result.warning_count","title":"<code>warning_count = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The number of warnings. This includes fixable warnings.</p>"},{"location":"api/#class-message","title":"Class <code>Message</code>","text":"<p>               Bases: <code>ToDictMixin</code></p> Source code in <code>xrlint\\result.py</code> <pre><code>@dataclass(kw_only=True)\nclass Message(ToDictMixin):\n    message: str\n    \"\"\"The error message.\"\"\"\n\n    node_path: str | None = None\n    \"\"\"Node path within the dataset.\n    This property is None if the message does not \n    apply to a certain dataset node.\n    \"\"\"\n\n    rule_id: str | None = None\n    \"\"\"The rule name that generated this lint message. \n    If this message is generated by the xrlint core \n    rather than rules, this is None.\n    \"\"\"\n\n    severity: Literal[1, 2] | None = None\n    \"\"\"The severity of this message. \n    `1` means warning and `2` means error.\n    \"\"\"\n\n    fatal: bool | None = None\n    \"\"\"True if this is a fatal error unrelated to a rule, \n    like a parsing error.\n    \"\"\"\n\n    fix: EditInfo | None = None\n    \"\"\"The EditInfo object of autofix. \n    This property is None if this \n    message is not fixable.\n\n    Not used yet.\n    \"\"\"\n\n    suggestions: list[Suggestion] | None = None\n    \"\"\"The list of suggestions. Each suggestion is the pair \n    of a description and an EditInfo object to fix the dataset. \n    API users such as editor integrations can choose one of them \n    to fix the problem of this message. \n    This property is None if this message does not have any suggestions.\n    \"\"\"\n</code></pre>"},{"location":"api/#xrlint.result.Message.message","title":"<code>message</code>  <code>instance-attribute</code>","text":"<p>The error message.</p>"},{"location":"api/#xrlint.result.Message.node_path","title":"<code>node_path = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Node path within the dataset. This property is None if the message does not  apply to a certain dataset node.</p>"},{"location":"api/#xrlint.result.Message.rule_id","title":"<code>rule_id = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The rule name that generated this lint message.  If this message is generated by the xrlint core  rather than rules, this is None.</p>"},{"location":"api/#xrlint.result.Message.severity","title":"<code>severity = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The severity of this message.  <code>1</code> means warning and <code>2</code> means error.</p>"},{"location":"api/#xrlint.result.Message.fatal","title":"<code>fatal = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>True if this is a fatal error unrelated to a rule,  like a parsing error.</p>"},{"location":"api/#xrlint.result.Message.fix","title":"<code>fix = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The EditInfo object of autofix.  This property is None if this  message is not fixable.</p> <p>Not used yet.</p>"},{"location":"api/#xrlint.result.Message.suggestions","title":"<code>suggestions = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The list of suggestions. Each suggestion is the pair  of a description and an EditInfo object to fix the dataset.  API users such as editor integrations can choose one of them  to fix the problem of this message.  This property is None if this message does not have any suggestions.</p>"},{"location":"api/#class-suggestion","title":"Class <code>Suggestion</code>","text":"<p>               Bases: <code>ToDictMixin</code></p> Source code in <code>xrlint\\result.py</code> <pre><code>@dataclass(frozen=True)\nclass Suggestion(ToDictMixin):\n    desc: str\n    \"\"\"Description of the suggestion.\"\"\"\n\n    data: dict[str, None] | None = None\n    \"\"\"Data that can be referenced in the description.\"\"\"\n\n    fix: EditInfo | None = None\n    \"\"\"Not used yet.\"\"\"\n\n    @classmethod\n    def from_value(cls, value: Any):\n        \"\"\"Convert given `value` into a `Suggestion` object.\n\n        If `value` is already a `Suggestion` then it is returned as-is.\n\n        Args:\n            value: A `Suggestion` object or a `str` containing the\n                suggestion text.\n        Returns:\n            A `Suggestion` object.\n        \"\"\"\n        if isinstance(value, Suggestion):\n            return value\n        if isinstance(value, str):\n            return Suggestion(value)\n        raise TypeError(format_message_type_of(\"value\", value, \"Suggestion|str\"))\n</code></pre>"},{"location":"api/#xrlint.result.Suggestion.desc","title":"<code>desc</code>  <code>instance-attribute</code>","text":"<p>Description of the suggestion.</p>"},{"location":"api/#xrlint.result.Suggestion.data","title":"<code>data = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Data that can be referenced in the description.</p>"},{"location":"api/#xrlint.result.Suggestion.fix","title":"<code>fix = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Not used yet.</p>"},{"location":"api/#xrlint.result.Suggestion.from_value","title":"<code>from_value(value)</code>  <code>classmethod</code>","text":"<p>Convert given <code>value</code> into a <code>Suggestion</code> object.</p> <p>If <code>value</code> is already a <code>Suggestion</code> then it is returned as-is.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>A <code>Suggestion</code> object or a <code>str</code> containing the suggestion text.</p> required <p>Returns:     A <code>Suggestion</code> object.</p> Source code in <code>xrlint\\result.py</code> <pre><code>@classmethod\ndef from_value(cls, value: Any):\n    \"\"\"Convert given `value` into a `Suggestion` object.\n\n    If `value` is already a `Suggestion` then it is returned as-is.\n\n    Args:\n        value: A `Suggestion` object or a `str` containing the\n            suggestion text.\n    Returns:\n        A `Suggestion` object.\n    \"\"\"\n    if isinstance(value, Suggestion):\n        return value\n    if isinstance(value, str):\n        return Suggestion(value)\n    raise TypeError(format_message_type_of(\"value\", value, \"Suggestion|str\"))\n</code></pre>"},{"location":"cli/","title":"Command Line Interface","text":"<p>After installation, the <code>xrlint</code> command can be used from the terminal.  The following are the command's options and arguments:</p> <pre><code>Usage: xrlint [OPTIONS] [FILES]...\n\n  Lint the given dataset FILES.\n\n  Reads configuration from `./xrlint.config.py` if `--no-default-config` is\n  not set and `--config PATH` is not provided, then validates each dataset in\n  FILES against the configuration. The validation result is dumped to standard\n  output if not otherwise stated by `--output-file PATH`. The output format is\n  `simple`. Other inbuilt formats are `json` and `html` which can by setting\n  the `--format NAME` option.\n\nOptions:\n  --no-default-config     Disable use of default configuration from\n                          xrlint.config.*\n  -c, --config PATH       Use this configuration, overriding xrlint.config.*\n                          config options if present\n  -f, --format NAME       Use a specific output format - default: simple\n  -o, --output-file PATH  Specify file to write report to\n  --max-warnings COUNT    Number of warnings to trigger nonzero exit code -\n                          default: -1\n  --version               Show the version and exit.\n  --help                  Show this message and exit.\n</code></pre>"},{"location":"todo/","title":"To Do","text":""},{"location":"todo/#required","title":"Required","text":"<ul> <li>populate <code>core</code> plugin by more rules</li> <li>populate <code>xcube</code> plugin by more rules</li> <li>add <code>docs</code></li> <li>use mkdocstrings ref syntax in docstrings</li> <li>provide configuration examples (use as tests?)</li> <li>generate markdown rule reference for the docs</li> </ul>"},{"location":"todo/#desired","title":"Desired","text":"<ul> <li>add some more tests so we reach 99% coverage</li> <li>introduce <code>dataset_options</code> config:<ul> <li><code>opener: OpenerOp</code></li> <li><code>opener_options: dict[str, Any]</code></li> </ul> </li> <li>implement <code>autofix</code> feature</li> </ul>"},{"location":"todo/#nice-to-have","title":"Nice to have","text":"<p>Currently unused - <code>RuleMeta.type</code> - <code>RuleTest.expected</code> - <code>processor: ProcessorOp</code> </p>"},{"location":"todo/#ideas","title":"Ideas","text":""},{"location":"todo/#other-plugins","title":"Other plugins","text":"<ul> <li><code>sgrid</code>: https://sgrid.github.io/sgrid/</li> <li><code>ugrid</code>: https://ugrid-conventions.github.io/ugrid-conventions/</li> </ul>"},{"location":"todo/#generalize-data-linting","title":"Generalize data linting","text":"<p>Do not limit verification to <code>xr.Dataset</code>. However, this requires new rule sets.</p> <p>To allow for other data models, we need to allow  for a specific verifier type for a given data type.</p> <p>The verifier verifies specific node types that are characteristic for a data type.</p> <p>To do so a traverser must traverse the elements of the data and pass each node to the verifier.</p> <p>Note, this is the Visitor Pattern,  where the verifier is the Visitor and a node refers to Element.</p> <p>To support the CLI mode, we need different data opener  types that can read the data from a file path.</p> <ol> <li>open data, if given data is a file path: </li> <li>find opener for file path</li> <li>open data </li> <li>verify data</li> <li>find root element type and visitor type for data </li> <li>call the root element <code>accept(verifier)</code> that verifies the       root element <code>verify.root()</code> and starts traversal of       child elements.</li> </ol>"}]}