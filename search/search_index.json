{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"XRLint - A linter for xarray datasets","text":"<p>XRLint is a linting  tool and library for xarray datasets. Its design is heavily inspired by ESLint.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Flexible validation for <code>xarray.Dataset</code> objects by configurable rules.</li> <li>Available from CLI and Python API.</li> <li>Custom plugins providing custom rule sets allow addressing    different dataset conventions.</li> <li>Project-specific configurations including configuration of individual    rules and file-specific settings.</li> </ul>"},{"location":"#inbuilt-rules","title":"Inbuilt Rules","text":"<p>The following rule plugins are currently built into the code base:</p> <ul> <li><code>core</code>: Implementing the rules for   tidy data   and the    CF-Conventions.</li> <li><code>xcube</code>: Implementing the rules for    xcube datasets.   Note, this plugin is fully optional. You must manually configure    it to apply its rules. It may be moved into a separate GitHub repo    once XRLint is mature enough. </li> </ul>"},{"location":"about/","title":"About XRLint","text":""},{"location":"about/#changelog","title":"Changelog","text":"<p>You can find the complete XRLint changelog  here. </p>"},{"location":"about/#reporting","title":"Reporting","text":"<p>If you have suggestions, ideas, feature requests, or if you have identified a malfunction or error, then please  post an issue. </p>"},{"location":"about/#contributions","title":"Contributions","text":"<p>The XRLint project welcomes contributions of any form as long as you respect our  code of conduct and follow our  contribution guide.</p> <p>If you'd like to submit code or documentation changes, we ask you to provide a  pull request (PR)  here.  For code and configuration changes, your PR must be linked to a  corresponding issue. </p>"},{"location":"about/#development","title":"Development","text":"<p>To install the XRLint development environment into an existing Python environment</p> <pre><code>pip install .[dev,doc]\n</code></pre> <p>or create a new environment using</p> <pre><code>mamba env create \n</code></pre>"},{"location":"about/#testing-and-coverage","title":"Testing and Coverage","text":"<p>XRLint uses pytest for unit-level testing  and code coverage analysis.</p> <pre><code>pytest --cov=xrlint --cov-report html\n</code></pre>"},{"location":"about/#code-style","title":"Code Style","text":"<p>XRLint source code is formatted using the black tool and  quality-controlled using flake8.</p> <pre><code>black .\nflake8 --max-line-length=88 . \n</code></pre>"},{"location":"about/#documentation","title":"Documentation","text":"<p>XRLint documentation is built using the mkdocs tool.</p> <p>With repository root as current working directory:</p> <pre><code>pip install .[doc]\n\nmkdocs build\nmkdocs serve\nmkdocs gh-deploy\n</code></pre> <p>The rule reference page is generated by a script called <code>mkruleref.py</code>. After changing or adding a rule, make sure you recreate the page:</p> <pre><code>python -m mkruleref\n</code></pre>"},{"location":"about/#license","title":"License","text":"<p>XRLint is open source made available under the terms and conditions of the  MIT License.</p> <p>Copyright \u00a9 2025 Brockmann Consult Development</p>"},{"location":"api/","title":"Python API","text":"<p>All described objects can be imported from the <code>xrlint.all</code> module.</p>"},{"location":"api/#class-xrlint","title":"Class <code>XRLint</code>","text":"<p>               Bases: <code>FormatterContext</code></p> <p>The engine behind the XRLint CLI application.</p> <p>The arguments are mostly 1:1 equivalents of the CLI options.</p> Source code in <code>xrlint\\cli\\engine.py</code> <pre><code>class XRLint(FormatterContext):\n    \"\"\"The engine behind the XRLint CLI application.\n\n    The arguments are mostly 1:1 equivalents of the\n    CLI options.\n    \"\"\"\n\n    # noinspection PyShadowingBuiltins\n    def __init__(\n        self,\n        no_config_lookup: int = False,\n        config_path: str | None = None,\n        plugin_specs: tuple[str, ...] = (),\n        rule_specs: tuple[str, ...] = (),\n        output_format: str = DEFAULT_OUTPUT_FORMAT,\n        output_path: str | None = None,\n        output_styled: bool = True,\n        max_warnings: int = DEFAULT_MAX_WARNINGS,\n    ):\n        self.no_config_lookup = no_config_lookup\n        self.config_path = config_path\n        self.plugin_specs = plugin_specs\n        self.rule_specs = rule_specs\n        self.output_format = output_format\n        self.output_path = output_path\n        self.output_styled = output_styled\n        self.max_warnings = max_warnings\n        self._result_stats = ResultStats()\n        self.config_list = ConfigList()\n\n    @property\n    def max_warnings_exceeded(self) -&gt; bool:\n        \"\"\"`True` if the maximum number of warnings has been exceeded.\"\"\"\n        return self._result_stats.warning_count &gt; self.max_warnings\n\n    @property\n    def result_stats(self) -&gt; ResultStats:\n        \"\"\"Get current result statistics.\"\"\"\n        return self._result_stats\n\n    def load_config_list(self) -&gt; None:\n        \"\"\"Load configuration list.\n        The function considers any `plugin` and `rule`\n        options, the default configuration file names or a specified\n        configuration file.\n        \"\"\"\n        plugins = {}\n        for plugin_spec in self.plugin_specs:\n            plugin = Plugin.from_value(plugin_spec)\n            plugins[plugin.meta.name] = plugin\n\n        rules = {}\n        for rule_spec in self.rule_specs:\n            rule = yaml.load(rule_spec, Loader=yaml.SafeLoader)\n            rules.update(rule)\n\n        config_list = None\n\n        if self.config_path:\n            try:\n                config_list = read_config_list(self.config_path)\n            except (FileNotFoundError, ConfigError) as e:\n                raise click.ClickException(f\"{e}\") from e\n        elif not self.no_config_lookup:\n            for config_path in DEFAULT_CONFIG_FILES:\n                try:\n                    config_list = read_config_list(config_path)\n                    break\n                except FileNotFoundError:\n                    pass\n                except ConfigError as e:\n                    raise click.ClickException(f\"{e}\") from e\n\n        if config_list is None:\n            click.echo(\"Warning: no configuration file found.\")\n\n        core_config = get_core_config()\n        core_config.plugins.update(plugins)\n        configs = [core_config]\n        if config_list is not None:\n            configs += config_list.configs\n        if rules:\n            configs += [{\"rules\": rules}]\n\n        self.config_list = ConfigList.from_value(configs)\n\n    def get_config_for_file(self, file_path: str) -&gt; Config | None:\n        \"\"\"Compute configuration for the given file.\n\n        Args:\n            file_path: A file path.\n        Return:\n            A configuration object or `None` if no item\n            in the configuration list applies.\n        \"\"\"\n        return self.config_list.compute_config(file_path)\n\n    def print_config_for_file(self, file_path: str) -&gt; None:\n        \"\"\"Print computed configuration for the given file.\n\n        Args:\n            file_path: A file path.\n        \"\"\"\n        config = self.get_config_for_file(file_path)\n        config_json_obj = config.to_dict() if config is not None else None\n        click.echo(json.dumps(config_json_obj, indent=2))\n\n    def verify_datasets(self, files: Iterable[str]) -&gt; Iterator[Result]:\n        \"\"\"Verify given files.\n        The function produces a validation result for each file.\n\n        Args:\n            files: Iterable of files.\n        Return:\n            Iterator of reports.\n        \"\"\"\n        global_filter = self.config_list.get_global_filter(\n            default=DEFAULT_GLOBAL_FILTER\n        )\n        linter = Linter()\n        for file_path, is_dir in get_files(files, global_filter):\n            config = self.get_config_for_file(file_path)\n            if config is not None:\n                yield linter.verify_dataset(file_path, config=config)\n            else:\n                yield Result.new(\n                    config=config,\n                    file_path=file_path,\n                    messages=[\n                        Message(\n                            message=\"No configuration matches this file.\",\n                            severity=2,\n                        )\n                    ],\n                )\n\n    def format_results(self, results: Iterable[Result]) -&gt; str:\n        \"\"\"Format the given results.\n\n        Args:\n            results: Iterable of results.\n        Return:\n            A report in plain text.\n        \"\"\"\n        output_format = (\n            self.output_format if self.output_format else DEFAULT_OUTPUT_FORMAT\n        )\n        formatters = export_formatters()\n        formatter = formatters.get(output_format)\n        if formatter is None:\n            raise click.ClickException(\n                f\"unknown format {output_format!r}.\"\n                f\" The available formats are\"\n                f\" {', '.join(repr(k) for k in formatters.keys())}.\"\n            )\n        # TODO: pass and validate format-specific args/kwargs\n        #   against formatter.meta.schema\n        if output_format == \"simple\":\n            formatter_kwargs = {\n                \"styled\": self.output_styled and self.output_path is None,\n                \"output\": self.output_path is None,\n            }\n        else:\n            formatter_kwargs = {}\n        # noinspection PyArgumentList\n        formatter_op = formatter.op_class(**formatter_kwargs)\n        return formatter_op.format(self, self._result_stats.collect(results))\n\n    def write_report(self, report: str) -&gt; None:\n        \"\"\"Write the validation report provided as plain text.\"\"\"\n        if self.output_path:\n            with fsspec.open(self.output_path, mode=\"w\") as f:\n                f.write(report)\n        elif self.output_format != \"simple\":\n            # The simple formatters outputs incrementally to console\n            print(report)\n\n    @classmethod\n    def init_config_file(cls) -&gt; None:\n        \"\"\"Write an initial configuration file.\n        The file is written into the current working directory.\n        \"\"\"\n        file_path = DEFAULT_CONFIG_FILE_YAML\n        if os.path.exists(file_path):\n            raise click.ClickException(f\"file {file_path} already exists.\")\n        with open(file_path, \"w\") as f:\n            f.write(INIT_CONFIG_YAML)\n        click.echo(f\"Configuration template written to {file_path}\")\n</code></pre>"},{"location":"api/#xrlint.cli.engine.XRLint.max_warnings_exceeded","title":"<code>max_warnings_exceeded</code>  <code>property</code>","text":"<p><code>True</code> if the maximum number of warnings has been exceeded.</p>"},{"location":"api/#xrlint.cli.engine.XRLint.result_stats","title":"<code>result_stats</code>  <code>property</code>","text":"<p>Get current result statistics.</p>"},{"location":"api/#xrlint.cli.engine.XRLint.load_config_list","title":"<code>load_config_list()</code>","text":"<p>Load configuration list. The function considers any <code>plugin</code> and <code>rule</code> options, the default configuration file names or a specified configuration file.</p> Source code in <code>xrlint\\cli\\engine.py</code> <pre><code>def load_config_list(self) -&gt; None:\n    \"\"\"Load configuration list.\n    The function considers any `plugin` and `rule`\n    options, the default configuration file names or a specified\n    configuration file.\n    \"\"\"\n    plugins = {}\n    for plugin_spec in self.plugin_specs:\n        plugin = Plugin.from_value(plugin_spec)\n        plugins[plugin.meta.name] = plugin\n\n    rules = {}\n    for rule_spec in self.rule_specs:\n        rule = yaml.load(rule_spec, Loader=yaml.SafeLoader)\n        rules.update(rule)\n\n    config_list = None\n\n    if self.config_path:\n        try:\n            config_list = read_config_list(self.config_path)\n        except (FileNotFoundError, ConfigError) as e:\n            raise click.ClickException(f\"{e}\") from e\n    elif not self.no_config_lookup:\n        for config_path in DEFAULT_CONFIG_FILES:\n            try:\n                config_list = read_config_list(config_path)\n                break\n            except FileNotFoundError:\n                pass\n            except ConfigError as e:\n                raise click.ClickException(f\"{e}\") from e\n\n    if config_list is None:\n        click.echo(\"Warning: no configuration file found.\")\n\n    core_config = get_core_config()\n    core_config.plugins.update(plugins)\n    configs = [core_config]\n    if config_list is not None:\n        configs += config_list.configs\n    if rules:\n        configs += [{\"rules\": rules}]\n\n    self.config_list = ConfigList.from_value(configs)\n</code></pre>"},{"location":"api/#xrlint.cli.engine.XRLint.get_config_for_file","title":"<code>get_config_for_file(file_path)</code>","text":"<p>Compute configuration for the given file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>A file path.</p> required <p>Return:     A configuration object or <code>None</code> if no item     in the configuration list applies.</p> Source code in <code>xrlint\\cli\\engine.py</code> <pre><code>def get_config_for_file(self, file_path: str) -&gt; Config | None:\n    \"\"\"Compute configuration for the given file.\n\n    Args:\n        file_path: A file path.\n    Return:\n        A configuration object or `None` if no item\n        in the configuration list applies.\n    \"\"\"\n    return self.config_list.compute_config(file_path)\n</code></pre>"},{"location":"api/#xrlint.cli.engine.XRLint.print_config_for_file","title":"<code>print_config_for_file(file_path)</code>","text":"<p>Print computed configuration for the given file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>A file path.</p> required Source code in <code>xrlint\\cli\\engine.py</code> <pre><code>def print_config_for_file(self, file_path: str) -&gt; None:\n    \"\"\"Print computed configuration for the given file.\n\n    Args:\n        file_path: A file path.\n    \"\"\"\n    config = self.get_config_for_file(file_path)\n    config_json_obj = config.to_dict() if config is not None else None\n    click.echo(json.dumps(config_json_obj, indent=2))\n</code></pre>"},{"location":"api/#xrlint.cli.engine.XRLint.verify_datasets","title":"<code>verify_datasets(files)</code>","text":"<p>Verify given files. The function produces a validation result for each file.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>Iterable[str]</code> <p>Iterable of files.</p> required <p>Return:     Iterator of reports.</p> Source code in <code>xrlint\\cli\\engine.py</code> <pre><code>def verify_datasets(self, files: Iterable[str]) -&gt; Iterator[Result]:\n    \"\"\"Verify given files.\n    The function produces a validation result for each file.\n\n    Args:\n        files: Iterable of files.\n    Return:\n        Iterator of reports.\n    \"\"\"\n    global_filter = self.config_list.get_global_filter(\n        default=DEFAULT_GLOBAL_FILTER\n    )\n    linter = Linter()\n    for file_path, is_dir in get_files(files, global_filter):\n        config = self.get_config_for_file(file_path)\n        if config is not None:\n            yield linter.verify_dataset(file_path, config=config)\n        else:\n            yield Result.new(\n                config=config,\n                file_path=file_path,\n                messages=[\n                    Message(\n                        message=\"No configuration matches this file.\",\n                        severity=2,\n                    )\n                ],\n            )\n</code></pre>"},{"location":"api/#xrlint.cli.engine.XRLint.format_results","title":"<code>format_results(results)</code>","text":"<p>Format the given results.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>Iterable[Result]</code> <p>Iterable of results.</p> required <p>Return:     A report in plain text.</p> Source code in <code>xrlint\\cli\\engine.py</code> <pre><code>def format_results(self, results: Iterable[Result]) -&gt; str:\n    \"\"\"Format the given results.\n\n    Args:\n        results: Iterable of results.\n    Return:\n        A report in plain text.\n    \"\"\"\n    output_format = (\n        self.output_format if self.output_format else DEFAULT_OUTPUT_FORMAT\n    )\n    formatters = export_formatters()\n    formatter = formatters.get(output_format)\n    if formatter is None:\n        raise click.ClickException(\n            f\"unknown format {output_format!r}.\"\n            f\" The available formats are\"\n            f\" {', '.join(repr(k) for k in formatters.keys())}.\"\n        )\n    # TODO: pass and validate format-specific args/kwargs\n    #   against formatter.meta.schema\n    if output_format == \"simple\":\n        formatter_kwargs = {\n            \"styled\": self.output_styled and self.output_path is None,\n            \"output\": self.output_path is None,\n        }\n    else:\n        formatter_kwargs = {}\n    # noinspection PyArgumentList\n    formatter_op = formatter.op_class(**formatter_kwargs)\n    return formatter_op.format(self, self._result_stats.collect(results))\n</code></pre>"},{"location":"api/#xrlint.cli.engine.XRLint.write_report","title":"<code>write_report(report)</code>","text":"<p>Write the validation report provided as plain text.</p> Source code in <code>xrlint\\cli\\engine.py</code> <pre><code>def write_report(self, report: str) -&gt; None:\n    \"\"\"Write the validation report provided as plain text.\"\"\"\n    if self.output_path:\n        with fsspec.open(self.output_path, mode=\"w\") as f:\n            f.write(report)\n    elif self.output_format != \"simple\":\n        # The simple formatters outputs incrementally to console\n        print(report)\n</code></pre>"},{"location":"api/#xrlint.cli.engine.XRLint.init_config_file","title":"<code>init_config_file()</code>  <code>classmethod</code>","text":"<p>Write an initial configuration file. The file is written into the current working directory.</p> Source code in <code>xrlint\\cli\\engine.py</code> <pre><code>@classmethod\ndef init_config_file(cls) -&gt; None:\n    \"\"\"Write an initial configuration file.\n    The file is written into the current working directory.\n    \"\"\"\n    file_path = DEFAULT_CONFIG_FILE_YAML\n    if os.path.exists(file_path):\n        raise click.ClickException(f\"file {file_path} already exists.\")\n    with open(file_path, \"w\") as f:\n        f.write(INIT_CONFIG_YAML)\n    click.echo(f\"Configuration template written to {file_path}\")\n</code></pre>"},{"location":"api/#function-new_linter","title":"Function <code>new_linter()</code>","text":"<p>Create a new <code>Linter</code> with the given configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config_name</code> <code>Literal['all', 'recommended'] | None</code> <p><code>\"recommended\"</code> if the recommended configuration of the builtin rules should be used, or <code>\"all\"</code> if all rules shall be used. Pass <code>None</code> (the default) if you don't want this. In the latter case, you should configure the <code>rules</code> option either in <code>config</code> or <code>config_kwargs</code>. Otherwise, calling <code>verify_dataset()</code> without any rule configuration will never succeed for any given dataset.</p> <code>None</code> <code>config</code> <code>Config | dict | None</code> <p>The <code>config</code> keyword argument passed to the <code>Linter</code> class</p> <code>None</code> <code>config_kwargs</code> <code>dict[str, Any]</code> <p>The <code>config_kwargs</code> keyword arguments passed to the <code>Linter</code> class</p> <code>{}</code> <p>Returns:     A new linter instance</p> Source code in <code>xrlint\\linter.py</code> <pre><code>def new_linter(\n    config_name: Literal[\"all\", \"recommended\"] | None = None,\n    *,\n    config: Config | dict | None = None,\n    **config_kwargs: dict[str, Any],\n) -&gt; \"Linter\":\n    \"\"\"Create a new `Linter` with the given configuration.\n\n    Args:\n        config_name: `\"recommended\"` if the recommended configuration\n            of the builtin rules should be used, or `\"all\"` if all rules\n            shall be used. Pass `None` (the default) if you don't want this.\n            In the latter case, you should configure the `rules`\n            option either in `config` or `config_kwargs`. Otherwise, calling\n            `verify_dataset()` without any rule configuration will never\n            succeed for any given dataset.\n        config: The `config` keyword argument passed to the `Linter` class\n        config_kwargs: The `config_kwargs` keyword arguments passed to\n            the `Linter` class\n    Returns:\n        A new linter instance\n    \"\"\"\n    return Linter(\n        config=merge_configs(get_core_config(config_name=config_name), config),\n        **config_kwargs,\n    )\n</code></pre>"},{"location":"api/#class-linter","title":"Class <code>Linter</code>","text":"<p>The linter.</p> <p>Using the constructor directly creates an empty linter with no configuration - even without default rules loaded. If you want a linter with core rules loaded use the <code>new_linter()</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config | dict[str, Any] | None</code> <p>The linter's configuration.</p> <code>None</code> <code>config_kwargs</code> <code>dict[str, Any]</code> <p>Individual linter configuration options. All options of the <code>Config</code> object are possible. If <code>config</code> is given too, provided given individual linter configuration options merged the ones given in <code>config</code>.</p> <code>{}</code> Source code in <code>xrlint\\linter.py</code> <pre><code>class Linter:\n    \"\"\"The linter.\n\n    Using the constructor directly creates an empty linter\n    with no configuration - even without default rules loaded.\n    If you want a linter with core rules loaded\n    use the `new_linter()` function.\n\n    Args:\n        config: The linter's configuration.\n        config_kwargs: Individual linter configuration options.\n            All options of the `Config` object are possible.\n            If `config` is given too, provided\n            given individual linter configuration options\n            merged the ones given in `config`.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: Config | dict[str, Any] | None = None,\n        **config_kwargs: dict[str, Any],\n    ):\n        self._config = merge_configs(config, config_kwargs)\n\n    @property\n    def config(self) -&gt; Config:\n        \"\"\"Get this linter's configuration.\"\"\"\n        return self._config\n\n    def verify_dataset(\n        self,\n        dataset: Any,\n        *,\n        file_path: str | None = None,\n        config: Config | dict[str, Any] | None = None,\n        **config_kwargs: dict[str, Any],\n    ) -&gt; Result:\n        \"\"\"Verify a dataset.\n\n        Args:\n            dataset: The dataset. Can be a `xr.Dataset` instance\n                or a file path, or any dataset source that can be opened\n                using `xarray.open_dataset()`.\n            file_path: Optional file path used for formatting\n                messages. Useful if `dataset` is not a file path.\n            config: Configuration tbe merged with the linter's\n                configuration.\n            config_kwargs: Individual linter configuration options\n                to be merged with `config` if any. The merged result\n                will be merged with the linter's configuration.\n        Returns:\n            Result of the verification.\n        \"\"\"\n        config = merge_configs(self._config, config)\n        config = merge_configs(config, config_kwargs)\n        return verify_dataset(config, dataset, file_path)\n</code></pre>"},{"location":"api/#xrlint.linter.Linter.config","title":"<code>config</code>  <code>property</code>","text":"<p>Get this linter's configuration.</p>"},{"location":"api/#xrlint.linter.Linter.verify_dataset","title":"<code>verify_dataset(dataset, *, file_path=None, config=None, **config_kwargs)</code>","text":"<p>Verify a dataset.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>Any</code> <p>The dataset. Can be a <code>xr.Dataset</code> instance or a file path, or any dataset source that can be opened using <code>xarray.open_dataset()</code>.</p> required <code>file_path</code> <code>str | None</code> <p>Optional file path used for formatting messages. Useful if <code>dataset</code> is not a file path.</p> <code>None</code> <code>config</code> <code>Config | dict[str, Any] | None</code> <p>Configuration tbe merged with the linter's configuration.</p> <code>None</code> <code>config_kwargs</code> <code>dict[str, Any]</code> <p>Individual linter configuration options to be merged with <code>config</code> if any. The merged result will be merged with the linter's configuration.</p> <code>{}</code> <p>Returns:     Result of the verification.</p> Source code in <code>xrlint\\linter.py</code> <pre><code>def verify_dataset(\n    self,\n    dataset: Any,\n    *,\n    file_path: str | None = None,\n    config: Config | dict[str, Any] | None = None,\n    **config_kwargs: dict[str, Any],\n) -&gt; Result:\n    \"\"\"Verify a dataset.\n\n    Args:\n        dataset: The dataset. Can be a `xr.Dataset` instance\n            or a file path, or any dataset source that can be opened\n            using `xarray.open_dataset()`.\n        file_path: Optional file path used for formatting\n            messages. Useful if `dataset` is not a file path.\n        config: Configuration tbe merged with the linter's\n            configuration.\n        config_kwargs: Individual linter configuration options\n            to be merged with `config` if any. The merged result\n            will be merged with the linter's configuration.\n    Returns:\n        Result of the verification.\n    \"\"\"\n    config = merge_configs(self._config, config)\n    config = merge_configs(config, config_kwargs)\n    return verify_dataset(config, dataset, file_path)\n</code></pre>"},{"location":"api/#class-config","title":"Class <code>Config</code>","text":"<p>               Bases: <code>ToDictMixin</code></p> <p>Configuration object. A configuration object contains all the information XRLint needs to execute on a set of dataset files.</p> <p>You should not use the class constructor directly. Instead, use the <code>Config.from_value()</code> function.</p> Source code in <code>xrlint\\config.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass Config(ToDictMixin):\n    \"\"\"Configuration object.\n    A configuration object contains all the information XRLint\n    needs to execute on a set of dataset files.\n\n    You should not use the class constructor directly.\n    Instead, use the `Config.from_value()` function.\n    \"\"\"\n\n    name: str | None = None\n    \"\"\"A name for the configuration object.\n    This is used in error messages and config inspector to help identify\n    which configuration object is being used.\n    \"\"\"\n\n    files: list[str] | None = None\n    \"\"\"An array of glob patterns indicating the files that the\n    configuration object should apply to. If not specified,\n    the configuration object applies to all files matched\n    by any other configuration object.\n\n    When a configuration object contains only the files property\n    without accompanying rules or settings, it effectively acts as\n    a _global file filter_. This means that XRLint will recognize\n    and process only the files matching these patterns, thereby\n    limiting its scope to the specified files. The inbuilt\n    global file filters are `[\"**/*.zarr\", \"**/*.nc\"]`.\n    \"\"\"\n\n    ignores: list[str] | None = None\n    \"\"\"An array of glob patterns indicating the files that the\n    configuration object should not apply to. If not specified,\n    the configuration object applies to all files matched by `files`.\n    If `ignores` is used without any other keys in the configuration\n    object, then the patterns act as _global ignores_.\n    \"\"\"\n\n    linter_options: dict[str, Any] | None = None\n    \"\"\"A dictionary containing options related to the linting process.\"\"\"\n\n    opener_options: dict[str, Any] | None = None\n    \"\"\"A dictionary containing options that are passed to\n    the dataset opener.\n    \"\"\"\n\n    processor: Union[\"ProcessorOp\", str, None] = None\n    \"\"\"Either an object compatible with the `ProcessorOp`\n    interface or a string indicating the name of a processor inside\n    of a plugin (i.e., `\"pluginName/processorName\"`).\n    \"\"\"\n\n    plugins: dict[str, \"Plugin\"] | None = None\n    \"\"\"A dictionary containing a name-value mapping of plugin names to\n    plugin objects. When `files` is specified, these plugins are only\n    available to the matching files.\n    \"\"\"\n\n    rules: dict[str, \"RuleConfig\"] | None = None\n    \"\"\"A dictionary containing the configured rules.\n    When `files` or `ignores` are specified, these rule configurations\n    are only available to the matching files.\n    \"\"\"\n\n    settings: dict[str, Any] | None = None\n    \"\"\"A dictionary containing name-value pairs of information\n    that should be available to all rules.\n    \"\"\"\n\n    @classmethod\n    def from_value(cls, value: Any) -&gt; \"Config\":\n        \"\"\"Convert given `value` into a `Config` object.\n\n        If `value` is already a `Config` then it is returned as-is.\n\n        Args:\n            value: A `Config` object, a `dict` containing the\n                configuration properties, or `None` which\n                converts into an empty configuration.\n        Returns:\n            A `Config` object.\n        \"\"\"\n        if isinstance(value, Config):\n            return value\n        if value is None:\n            return Config()\n        if not isinstance(value, dict):\n            raise TypeError(format_message_type_of(\"configuration\", value, \"dict\"))\n        if not value:\n            return Config()\n\n        files = cls._parse_pattern_list(value, \"files\")\n        ignores = cls._parse_pattern_list(value, \"ignores\")\n        linter_options = cls._parse_options(\"linter_options\", value)\n        opener_options = cls._parse_options(\"opener_options\", value)\n        processor = cls._parse_processor(value)\n        plugins = cls._parse_plugins(value)\n        rules = cls._parse_rules(value)\n        settings = cls._parse_options(\"settings\", value)\n\n        return Config(\n            name=value.get(\"name\"),\n            files=files,\n            ignores=ignores,\n            linter_options=linter_options,\n            opener_options=opener_options,\n            processor=processor,\n            plugins=plugins,\n            rules=rules,\n            settings=settings,\n        )\n\n    @cached_property\n    def file_filter(self) -&gt; \"FileFilter\":\n        \"\"\"The file filter specified by this configuration. May be empty.\"\"\"\n        return FileFilter.from_patterns(self.files, self.ignores)\n\n    @cached_property\n    def empty(self) -&gt; bool:\n        \"\"\"`True` if this configuration object does not configure anything.\n        Note, it could still contribute to a global file filter if its\n        `files` and `ignores` options are set.\"\"\"\n        return not (\n            self.linter_options\n            or self.opener_options\n            or self.plugins\n            or self.rules\n            or self.settings\n        )\n\n    def get_plugin(self, plugin_name: str) -&gt; \"Plugin\":\n        \"\"\"Get the plugin for given plugin name `plugin_name`.\"\"\"\n        plugin = (self.plugins or {}).get(plugin_name)\n        if plugin is None:\n            raise ValueError(f\"unknown plugin {plugin_name!r}\")\n        return plugin\n\n    def get_rule(self, rule_id: str) -&gt; \"Rule\":\n        \"\"\"Get the rule for the given rule identifier `rule_id`.\n\n        Args:\n            rule_id: The rule identifier including plugin namespace, if any.\n                Format `&lt;rule-name&gt;` (builtin rules) or `&lt;plugin-name&gt;/&lt;rule-name&gt;`.\n        Returns:\n            A `Rule` object.\n        Raises:\n            ValueError: If either the plugin is unknown in this configuration\n                or the rule name is unknown.\n        \"\"\"\n        plugin_name, rule_name = split_config_spec(rule_id)\n        plugin = self.get_plugin(plugin_name)\n        rule = (plugin.rules or {}).get(rule_name)\n        if rule is None:\n            raise ValueError(f\"unknown rule {rule_id!r}\")\n        return rule\n\n    def get_processor_op(\n        self, processor_spec: Union[\"ProcessorOp\", str]\n    ) -&gt; \"ProcessorOp\":\n        \"\"\"Get the processor operation for the given\n        processor identifier `processor_spec`.\n        \"\"\"\n        from xrlint.processor import Processor\n        from xrlint.processor import ProcessorOp\n\n        if isinstance(processor_spec, ProcessorOp):\n            return processor_spec\n\n        plugin_name, processor_name = split_config_spec(processor_spec)\n        plugin = self.get_plugin(plugin_name)\n        processor: Processor | None = (plugin.processors or {}).get(processor_name)\n        if processor is None:\n            raise ValueError(f\"unknown processor {processor_spec!r}\")\n        return processor.op_class()\n\n    def merge(self, config: \"Config\", name: str = None) -&gt; \"Config\":\n        return Config(\n            name=name,\n            files=self._merge_pattern_lists(self.files, config.files),\n            ignores=self._merge_pattern_lists(self.ignores, config.ignores),\n            linter_options=self._merge_options(\n                self.linter_options, config.linter_options\n            ),\n            opener_options=self._merge_options(\n                self.opener_options, config.opener_options\n            ),\n            processor=merge_values(self.processor, config.processor),\n            plugins=self._merge_plugin_dicts(self.plugins, config.plugins),\n            rules=self._merge_rule_dicts(self.rules, config.rules),\n            settings=self._merge_options(self.settings, config.settings),\n        )\n\n    @classmethod\n    def _merge_rule_dicts(\n        cls,\n        rules1: dict[str, \"RuleConfig\"] | None,\n        rules2: dict[str, \"RuleConfig\"] | None,\n    ) -&gt; dict[str, \"RuleConfig\"] | None:\n        from xrlint.rule import RuleConfig\n\n        def merge_items(r1: RuleConfig, r2: RuleConfig) -&gt; RuleConfig:\n            if r1.severity == r2.severity:\n                return RuleConfig(\n                    r2.severity,\n                    merge_arrays(r1.args, r2.args),\n                    merge_dicts(r1.kwargs, r2.kwargs),\n                )\n            return r2\n\n        return merge_dicts(rules1, rules2, merge_items=merge_items)\n\n    @classmethod\n    def _merge_pattern_lists(\n        cls, patterns1: list[str] | None, patterns2: list[str] | None\n    ) -&gt; list[str] | None:\n        return merge_set_lists(patterns1, patterns2)\n\n    @classmethod\n    def _merge_options(\n        cls, settings1: dict[str, Any] | None, settings2: dict[str, Any] | None\n    ) -&gt; dict[str, Any] | None:\n        return merge_dicts(settings1, settings2, merge_items=merge_values)\n\n    @classmethod\n    def _merge_plugin_dicts(\n        cls,\n        plugins1: dict[str, \"Plugin\"] | None,\n        plugins2: dict[str, \"Plugin\"] | None,\n    ) -&gt; dict[str, \"RuleConfig\"] | None:\n        from xrlint.plugin import Plugin\n\n        def merge_items(_p1: Plugin, p2: Plugin) -&gt; Plugin:\n            return p2\n\n        return merge_dicts(plugins1, plugins2, merge_items=merge_items)\n\n    @classmethod\n    def _parse_pattern_list(cls, config_dict: dict, name) -&gt; list[str]:\n        patterns = config_dict.get(name)\n        if isinstance(patterns, list):\n            return [cls._parse_pattern(name, v) for v in patterns]\n        if patterns is not None:\n            raise TypeError(\n                format_message_type_of(f\"{name} configuration\", patterns, \"list[str]\")\n            )\n\n    @classmethod\n    def _parse_pattern(cls, name, pattern):\n        if not isinstance(pattern, str):\n            raise TypeError(\n                format_message_type_of(f\"pattern in {name} configuration\", pattern, str)\n            )\n        return pattern\n\n    @classmethod\n    def _parse_processor(cls, config_dict: dict) -&gt; Union[\"ProcessorOp\", str, None]:\n        from xrlint.processor import ProcessorOp\n\n        processor = config_dict.get(\"processor\")\n        if processor is None or isinstance(processor, (str, ProcessorOp)):\n            return processor\n        raise TypeError(\n            format_message_type_of(\n                \"processor configuration\", processor, \"ProcessorOp|str|None\"\n            )\n        )\n\n    @classmethod\n    def _parse_plugins(cls, config_dict: dict) -&gt; dict[str, \"Plugin\"]:\n        from xrlint.plugin import Plugin\n\n        plugins = config_dict.get(\"plugins\")\n        if isinstance(plugins, dict):\n            return {k: Plugin.from_value(v) for k, v in plugins.items()}\n        if plugins is not None:\n            raise TypeError(\n                format_message_type_of(\"plugins configuration\", plugins, \"dict\")\n            )\n\n    @classmethod\n    def _parse_rules(cls, config_dict: dict) -&gt; dict[str, \"RuleConfig\"]:\n        from xrlint.rule import RuleConfig\n\n        rules = config_dict.get(\"rules\")\n        if isinstance(rules, dict):\n            return {rn: RuleConfig.from_value(rc) for rn, rc in rules.items()}\n        if rules is not None:\n            raise TypeError(\n                format_message_type_of(\"rules configuration\", rules, \"dict\")\n            )\n\n    @classmethod\n    def _parse_options(cls, name: str, config_dict: dict) -&gt; dict[str, Any]:\n        settings = config_dict.get(name)\n        if isinstance(settings, dict):\n            for k, v in settings.items():\n                if not isinstance(k, str):\n                    raise TypeError(format_message_type_of(f\"{name} keys\", k, str))\n            return {k: v for k, v in settings.items()}\n        if settings is not None:\n            raise TypeError(format_message_type_of(name, settings, \"dict[str,Any]\"))\n\n    def to_dict(self):\n        d = super().to_dict()\n        plugins: dict[str, Plugin] | None = d.get(\"plugins\")\n        if plugins is not None:\n            d[\"plugins\"] = {k: v.meta.module or \"?\" for k, v in plugins.items()}\n        rules: dict[str, RuleConfig] | None = d.get(\"rules\")\n        if rules is not None:\n            d[\"rules\"] = {\n                k: (\n                    v.severity\n                    if not (v.args or v.kwargs)\n                    else [v.severity, v.args, v.kwargs]\n                )\n                for k, v in rules.items()\n            }\n        return d\n</code></pre>"},{"location":"api/#xrlint.config.Config.name","title":"<code>name = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A name for the configuration object. This is used in error messages and config inspector to help identify which configuration object is being used.</p>"},{"location":"api/#xrlint.config.Config.files","title":"<code>files = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An array of glob patterns indicating the files that the configuration object should apply to. If not specified, the configuration object applies to all files matched by any other configuration object.</p> <p>When a configuration object contains only the files property without accompanying rules or settings, it effectively acts as a global file filter. This means that XRLint will recognize and process only the files matching these patterns, thereby limiting its scope to the specified files. The inbuilt global file filters are <code>[\"**/*.zarr\", \"**/*.nc\"]</code>.</p>"},{"location":"api/#xrlint.config.Config.ignores","title":"<code>ignores = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An array of glob patterns indicating the files that the configuration object should not apply to. If not specified, the configuration object applies to all files matched by <code>files</code>. If <code>ignores</code> is used without any other keys in the configuration object, then the patterns act as global ignores.</p>"},{"location":"api/#xrlint.config.Config.linter_options","title":"<code>linter_options = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary containing options related to the linting process.</p>"},{"location":"api/#xrlint.config.Config.opener_options","title":"<code>opener_options = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary containing options that are passed to the dataset opener.</p>"},{"location":"api/#xrlint.config.Config.processor","title":"<code>processor = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Either an object compatible with the <code>ProcessorOp</code> interface or a string indicating the name of a processor inside of a plugin (i.e., <code>\"pluginName/processorName\"</code>).</p>"},{"location":"api/#xrlint.config.Config.plugins","title":"<code>plugins = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary containing a name-value mapping of plugin names to plugin objects. When <code>files</code> is specified, these plugins are only available to the matching files.</p>"},{"location":"api/#xrlint.config.Config.rules","title":"<code>rules = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary containing the configured rules. When <code>files</code> or <code>ignores</code> are specified, these rule configurations are only available to the matching files.</p>"},{"location":"api/#xrlint.config.Config.settings","title":"<code>settings = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary containing name-value pairs of information that should be available to all rules.</p>"},{"location":"api/#xrlint.config.Config.file_filter","title":"<code>file_filter</code>  <code>cached</code> <code>property</code>","text":"<p>The file filter specified by this configuration. May be empty.</p>"},{"location":"api/#xrlint.config.Config.empty","title":"<code>empty</code>  <code>cached</code> <code>property</code>","text":"<p><code>True</code> if this configuration object does not configure anything. Note, it could still contribute to a global file filter if its <code>files</code> and <code>ignores</code> options are set.</p>"},{"location":"api/#xrlint.config.Config.from_value","title":"<code>from_value(value)</code>  <code>classmethod</code>","text":"<p>Convert given <code>value</code> into a <code>Config</code> object.</p> <p>If <code>value</code> is already a <code>Config</code> then it is returned as-is.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>A <code>Config</code> object, a <code>dict</code> containing the configuration properties, or <code>None</code> which converts into an empty configuration.</p> required <p>Returns:     A <code>Config</code> object.</p> Source code in <code>xrlint\\config.py</code> <pre><code>@classmethod\ndef from_value(cls, value: Any) -&gt; \"Config\":\n    \"\"\"Convert given `value` into a `Config` object.\n\n    If `value` is already a `Config` then it is returned as-is.\n\n    Args:\n        value: A `Config` object, a `dict` containing the\n            configuration properties, or `None` which\n            converts into an empty configuration.\n    Returns:\n        A `Config` object.\n    \"\"\"\n    if isinstance(value, Config):\n        return value\n    if value is None:\n        return Config()\n    if not isinstance(value, dict):\n        raise TypeError(format_message_type_of(\"configuration\", value, \"dict\"))\n    if not value:\n        return Config()\n\n    files = cls._parse_pattern_list(value, \"files\")\n    ignores = cls._parse_pattern_list(value, \"ignores\")\n    linter_options = cls._parse_options(\"linter_options\", value)\n    opener_options = cls._parse_options(\"opener_options\", value)\n    processor = cls._parse_processor(value)\n    plugins = cls._parse_plugins(value)\n    rules = cls._parse_rules(value)\n    settings = cls._parse_options(\"settings\", value)\n\n    return Config(\n        name=value.get(\"name\"),\n        files=files,\n        ignores=ignores,\n        linter_options=linter_options,\n        opener_options=opener_options,\n        processor=processor,\n        plugins=plugins,\n        rules=rules,\n        settings=settings,\n    )\n</code></pre>"},{"location":"api/#xrlint.config.Config.get_plugin","title":"<code>get_plugin(plugin_name)</code>","text":"<p>Get the plugin for given plugin name <code>plugin_name</code>.</p> Source code in <code>xrlint\\config.py</code> <pre><code>def get_plugin(self, plugin_name: str) -&gt; \"Plugin\":\n    \"\"\"Get the plugin for given plugin name `plugin_name`.\"\"\"\n    plugin = (self.plugins or {}).get(plugin_name)\n    if plugin is None:\n        raise ValueError(f\"unknown plugin {plugin_name!r}\")\n    return plugin\n</code></pre>"},{"location":"api/#xrlint.config.Config.get_rule","title":"<code>get_rule(rule_id)</code>","text":"<p>Get the rule for the given rule identifier <code>rule_id</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rule_id</code> <code>str</code> <p>The rule identifier including plugin namespace, if any. Format <code>&lt;rule-name&gt;</code> (builtin rules) or <code>&lt;plugin-name&gt;/&lt;rule-name&gt;</code>.</p> required <p>Returns:     A <code>Rule</code> object. Raises:     ValueError: If either the plugin is unknown in this configuration         or the rule name is unknown.</p> Source code in <code>xrlint\\config.py</code> <pre><code>def get_rule(self, rule_id: str) -&gt; \"Rule\":\n    \"\"\"Get the rule for the given rule identifier `rule_id`.\n\n    Args:\n        rule_id: The rule identifier including plugin namespace, if any.\n            Format `&lt;rule-name&gt;` (builtin rules) or `&lt;plugin-name&gt;/&lt;rule-name&gt;`.\n    Returns:\n        A `Rule` object.\n    Raises:\n        ValueError: If either the plugin is unknown in this configuration\n            or the rule name is unknown.\n    \"\"\"\n    plugin_name, rule_name = split_config_spec(rule_id)\n    plugin = self.get_plugin(plugin_name)\n    rule = (plugin.rules or {}).get(rule_name)\n    if rule is None:\n        raise ValueError(f\"unknown rule {rule_id!r}\")\n    return rule\n</code></pre>"},{"location":"api/#xrlint.config.Config.get_processor_op","title":"<code>get_processor_op(processor_spec)</code>","text":"<p>Get the processor operation for the given processor identifier <code>processor_spec</code>.</p> Source code in <code>xrlint\\config.py</code> <pre><code>def get_processor_op(\n    self, processor_spec: Union[\"ProcessorOp\", str]\n) -&gt; \"ProcessorOp\":\n    \"\"\"Get the processor operation for the given\n    processor identifier `processor_spec`.\n    \"\"\"\n    from xrlint.processor import Processor\n    from xrlint.processor import ProcessorOp\n\n    if isinstance(processor_spec, ProcessorOp):\n        return processor_spec\n\n    plugin_name, processor_name = split_config_spec(processor_spec)\n    plugin = self.get_plugin(plugin_name)\n    processor: Processor | None = (plugin.processors or {}).get(processor_name)\n    if processor is None:\n        raise ValueError(f\"unknown processor {processor_spec!r}\")\n    return processor.op_class()\n</code></pre>"},{"location":"api/#class-configlist","title":"Class <code>ConfigList</code>","text":"<p>A holder for a list of <code>Config</code> objects.</p> <p>You should not use the class constructor directly. Instead, use the <code>ConfigList.from_value()</code> function.</p> Source code in <code>xrlint\\config.py</code> <pre><code>@dataclass(frozen=True)\nclass ConfigList:\n    \"\"\"A holder for a list of `Config` objects.\n\n    You should not use the class constructor directly.\n    Instead, use the `ConfigList.from_value()` function.\n    \"\"\"\n\n    configs: list[Config] = field(default_factory=list)\n    \"\"\"The list of `Config` objects.\"\"\"\n\n    @classmethod\n    def from_value(cls, value: Any) -&gt; \"ConfigList\":\n        \"\"\"Convert given `value` into a `ConfigList` object.\n\n        If `value` is already a `ConfigList` then it is returned as-is.\n\n        Args:\n            value: A `ConfigList` object or `list` of items which can be\n                converted into `Config` objects including configuration\n                names of tyype `str`. The latter are resolved against\n                the plugin configurations seen so far in the list.\n        Returns:\n            A `ConfigList` object.\n        \"\"\"\n        if isinstance(value, ConfigList):\n            return value\n\n        if not isinstance(value, list):\n            raise TypeError(\n                format_message_type_of(\n                    \"configuration list\", value, \"ConfigList|list[Config|dict|str]\"\n                )\n            )\n\n        configs: list[Config] = []\n        plugins: dict[str, Plugin] = {}\n        for item in value:\n            if isinstance(item, str):\n                if CORE_PLUGIN_NAME not in plugins:\n                    plugins.update({CORE_PLUGIN_NAME: get_core_plugin()})\n                config = cls._get_named_config(item, plugins)\n            else:\n                config = Config.from_value(item)\n            configs.append(config)\n            plugins.update(config.plugins if config.plugins else {})\n\n        return ConfigList(configs)\n\n    @classmethod\n    def _get_named_config(cls, config_spec: str, plugins: dict[str, \"Plugin\"]):\n        plugin_name, config_name = (\n            config_spec.split(\"/\", maxsplit=1)\n            if \"/\" in config_spec\n            else (CORE_PLUGIN_NAME, config_spec)\n        )\n        plugin: Plugin | None = plugins.get(plugin_name)\n        if plugin is None or not plugin.configs or config_name not in plugin.configs:\n            raise ValueError(f\"configuration {config_spec!r} not found\")\n        config_value = plugin.configs[config_name]\n        return config_value\n\n    def get_global_filter(self, default: FileFilter | None = None) -&gt; \"FileFilter\":\n        \"\"\"Get a global file filter for this configuration list.\"\"\"\n        global_filter = FileFilter(\n            default.files if default else (),\n            default.ignores if default else (),\n        )\n        for c in self.configs:\n            if c.empty and not c.file_filter.empty:\n                global_filter = global_filter.merge(c.file_filter)\n        return global_filter\n\n    def compute_config(self, file_path: str) -&gt; Config | None:\n        \"\"\"Compute the configuration object for the given file path.\n\n        Args:\n            file_path: A dataset file path.\n        Returns:\n            A `Config` object which may be empty, or `None`\n            if `file_path` is not included by any `files` pattern\n            or intentionally ignored by global `ignores`.\n        \"\"\"\n\n        config = None\n        for c in self.configs:\n            if c.file_filter.empty or c.file_filter.accept(file_path):\n                config = config.merge(c) if config is not None else c\n\n        if config is None:\n            return None\n\n        # Note, computed configurations do not have \"files\" and \"ignores\"\n        return Config(\n            name=\"&lt;computed&gt;\",\n            linter_options=config.linter_options,\n            opener_options=config.opener_options,\n            processor=config.processor,\n            plugins=config.plugins,\n            rules=config.rules,\n            settings=config.settings,\n        )\n</code></pre>"},{"location":"api/#xrlint.config.ConfigList.configs","title":"<code>configs = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The list of <code>Config</code> objects.</p>"},{"location":"api/#xrlint.config.ConfigList.from_value","title":"<code>from_value(value)</code>  <code>classmethod</code>","text":"<p>Convert given <code>value</code> into a <code>ConfigList</code> object.</p> <p>If <code>value</code> is already a <code>ConfigList</code> then it is returned as-is.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>A <code>ConfigList</code> object or <code>list</code> of items which can be converted into <code>Config</code> objects including configuration names of tyype <code>str</code>. The latter are resolved against the plugin configurations seen so far in the list.</p> required <p>Returns:     A <code>ConfigList</code> object.</p> Source code in <code>xrlint\\config.py</code> <pre><code>@classmethod\ndef from_value(cls, value: Any) -&gt; \"ConfigList\":\n    \"\"\"Convert given `value` into a `ConfigList` object.\n\n    If `value` is already a `ConfigList` then it is returned as-is.\n\n    Args:\n        value: A `ConfigList` object or `list` of items which can be\n            converted into `Config` objects including configuration\n            names of tyype `str`. The latter are resolved against\n            the plugin configurations seen so far in the list.\n    Returns:\n        A `ConfigList` object.\n    \"\"\"\n    if isinstance(value, ConfigList):\n        return value\n\n    if not isinstance(value, list):\n        raise TypeError(\n            format_message_type_of(\n                \"configuration list\", value, \"ConfigList|list[Config|dict|str]\"\n            )\n        )\n\n    configs: list[Config] = []\n    plugins: dict[str, Plugin] = {}\n    for item in value:\n        if isinstance(item, str):\n            if CORE_PLUGIN_NAME not in plugins:\n                plugins.update({CORE_PLUGIN_NAME: get_core_plugin()})\n            config = cls._get_named_config(item, plugins)\n        else:\n            config = Config.from_value(item)\n        configs.append(config)\n        plugins.update(config.plugins if config.plugins else {})\n\n    return ConfigList(configs)\n</code></pre>"},{"location":"api/#xrlint.config.ConfigList.get_global_filter","title":"<code>get_global_filter(default=None)</code>","text":"<p>Get a global file filter for this configuration list.</p> Source code in <code>xrlint\\config.py</code> <pre><code>def get_global_filter(self, default: FileFilter | None = None) -&gt; \"FileFilter\":\n    \"\"\"Get a global file filter for this configuration list.\"\"\"\n    global_filter = FileFilter(\n        default.files if default else (),\n        default.ignores if default else (),\n    )\n    for c in self.configs:\n        if c.empty and not c.file_filter.empty:\n            global_filter = global_filter.merge(c.file_filter)\n    return global_filter\n</code></pre>"},{"location":"api/#xrlint.config.ConfigList.compute_config","title":"<code>compute_config(file_path)</code>","text":"<p>Compute the configuration object for the given file path.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>A dataset file path.</p> required <p>Returns:     A <code>Config</code> object which may be empty, or <code>None</code>     if <code>file_path</code> is not included by any <code>files</code> pattern     or intentionally ignored by global <code>ignores</code>.</p> Source code in <code>xrlint\\config.py</code> <pre><code>def compute_config(self, file_path: str) -&gt; Config | None:\n    \"\"\"Compute the configuration object for the given file path.\n\n    Args:\n        file_path: A dataset file path.\n    Returns:\n        A `Config` object which may be empty, or `None`\n        if `file_path` is not included by any `files` pattern\n        or intentionally ignored by global `ignores`.\n    \"\"\"\n\n    config = None\n    for c in self.configs:\n        if c.file_filter.empty or c.file_filter.accept(file_path):\n            config = config.merge(c) if config is not None else c\n\n    if config is None:\n        return None\n\n    # Note, computed configurations do not have \"files\" and \"ignores\"\n    return Config(\n        name=\"&lt;computed&gt;\",\n        linter_options=config.linter_options,\n        opener_options=config.opener_options,\n        processor=config.processor,\n        plugins=config.plugins,\n        rules=config.rules,\n        settings=config.settings,\n    )\n</code></pre>"},{"location":"api/#class-plugin","title":"Class <code>Plugin</code>","text":"<p>An XRLint plugin.</p> Source code in <code>xrlint\\plugin.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass Plugin:\n    \"\"\"An XRLint plugin.\"\"\"\n\n    meta: PluginMeta\n    \"\"\"Information about the plugin.\"\"\"\n\n    configs: dict[str, Config] = field(default_factory=dict)\n    \"\"\"A dictionary containing named configurations.\"\"\"\n\n    rules: dict[str, Rule] = field(default_factory=dict)\n    \"\"\"A dictionary containing the definitions of custom rules.\"\"\"\n\n    processors: dict[str, Processor] = field(default_factory=dict)\n    \"\"\"A dictionary containing named processors.\n    \"\"\"\n\n    @classmethod\n    def from_value(cls, value: Any) -&gt; \"Plugin\":\n        if isinstance(value, Plugin):\n            return value\n        if isinstance(value, str):\n            return import_value(value, \"export_plugin\", Plugin.from_value)\n        raise TypeError(format_message_type_of(\"value\", value, \"Plugin|str\"))\n\n    def define_rule(\n        self,\n        name: str,\n        version: str = \"0.0.0\",\n        schema: dict[str, Any] | list[dict[str, Any]] | bool | None = None,\n        type: Literal[\"problem\", \"suggestion\", \"layout\"] | None = None,\n        description: str | None = None,\n        docs_url: str | None = None,\n        op_class: Type[RuleOp] | None = None,\n    ) -&gt; Callable[[Any], Type[RuleOp]] | None:\n        return register_rule(\n            self.rules,\n            name=name,\n            version=version,\n            schema=schema,\n            type=type,\n            description=description,\n            docs_url=docs_url,\n            op_class=op_class,\n        )\n\n    def define_processor(\n        self,\n        name: str,\n        version: str = \"0.0.0\",\n        op_class: Type[ProcessorOp] | None = None,\n    ):\n        return register_processor(\n            self.processors,\n            name=name,\n            version=version,\n            op_class=op_class,\n        )\n</code></pre>"},{"location":"api/#xrlint.plugin.Plugin.meta","title":"<code>meta</code>  <code>instance-attribute</code>","text":"<p>Information about the plugin.</p>"},{"location":"api/#xrlint.plugin.Plugin.configs","title":"<code>configs = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary containing named configurations.</p>"},{"location":"api/#xrlint.plugin.Plugin.rules","title":"<code>rules = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary containing the definitions of custom rules.</p>"},{"location":"api/#xrlint.plugin.Plugin.processors","title":"<code>processors = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary containing named processors.</p>"},{"location":"api/#class-pluginmeta","title":"Class <code>PluginMeta</code>","text":"<p>XRLint plugin metadata.</p> Source code in <code>xrlint\\plugin.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass PluginMeta:\n    \"\"\"XRLint plugin metadata.\"\"\"\n\n    name: str\n    \"\"\"Plugin name.\"\"\"\n\n    version: str = \"0.0.0\"\n    \"\"\"Plugin version.\"\"\"\n\n    module: str | None = None\n    \"\"\"Plugin module.\"\"\"\n</code></pre>"},{"location":"api/#xrlint.plugin.PluginMeta.name","title":"<code>name</code>  <code>instance-attribute</code>","text":"<p>Plugin name.</p>"},{"location":"api/#xrlint.plugin.PluginMeta.version","title":"<code>version = '0.0.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Plugin version.</p>"},{"location":"api/#xrlint.plugin.PluginMeta.module","title":"<code>module = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Plugin module.</p>"},{"location":"api/#class-processor","title":"Class <code>Processor</code>","text":"<p>Processors tell XRLint how to process files other than standard xarray datasets.</p> Source code in <code>xrlint\\processor.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass Processor:\n    \"\"\"Processors tell XRLint how to process files other than\n    standard xarray datasets.\n    \"\"\"\n\n    meta: ProcessorMeta\n    \"\"\"Information about the processor.\"\"\"\n\n    op_class: Type[ProcessorOp]\n    \"\"\"A class that implements the processor operations.\"\"\"\n\n    supports_auto_fix: bool = False\n    \"\"\"`True` if this processor supports auto-fixing of datasets.\"\"\"\n</code></pre>"},{"location":"api/#xrlint.processor.Processor.meta","title":"<code>meta</code>  <code>instance-attribute</code>","text":"<p>Information about the processor.</p>"},{"location":"api/#xrlint.processor.Processor.op_class","title":"<code>op_class</code>  <code>instance-attribute</code>","text":"<p>A class that implements the processor operations.</p>"},{"location":"api/#xrlint.processor.Processor.supports_auto_fix","title":"<code>supports_auto_fix = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p><code>True</code> if this processor supports auto-fixing of datasets.</p>"},{"location":"api/#class-processormeta","title":"Class <code>ProcessorMeta</code>","text":"<p>Processor metadata.</p> Source code in <code>xrlint\\processor.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass ProcessorMeta:\n    \"\"\"Processor metadata.\"\"\"\n\n    name: str\n    \"\"\"Name of the processor.\"\"\"\n\n    version: str = \"0.0.0\"\n    \"\"\"Version of the processor.\"\"\"\n</code></pre>"},{"location":"api/#xrlint.processor.ProcessorMeta.name","title":"<code>name</code>  <code>instance-attribute</code>","text":"<p>Name of the processor.</p>"},{"location":"api/#xrlint.processor.ProcessorMeta.version","title":"<code>version = '0.0.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Version of the processor.</p>"},{"location":"api/#class-processorop","title":"Class <code>ProcessorOp</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Implements the processor operations.</p> Source code in <code>xrlint\\processor.py</code> <pre><code>class ProcessorOp(ABC):\n    \"\"\"Implements the processor operations.\"\"\"\n\n    @abstractmethod\n    def preprocess(\n        self, file_path: str, opener_options: dict[str, Any]\n    ) -&gt; list[tuple[xr.Dataset, str]]:\n        \"\"\"Pre-process a dataset given by its `file_path` and `opener_options`.\n        In this method you use the `file_path` to read zero, one, or more\n        datasets to lint.\n\n        Args:\n            file_path: A file path\n            opener_options: The configuration's `opener_options`.\n        Returns:\n            A list of (dataset, file_path) pairs\n        \"\"\"\n\n    @abstractmethod\n    def postprocess(\n        self, messages: list[list[Message]], file_path: str\n    ) -&gt; list[Message]:\n        \"\"\"Post-process the outputs of each dataset from `preprocess()`.\n\n        Args:\n            messages: contains two-dimensional array of \u00b4Message\u00b4 objects\n                where each top-level array item contains array of lint messages\n                related to the dataset that was returned in array from\n                `preprocess()` method\n            file_path: The corresponding file path\n\n        Returns:\n            A one-dimensional array (list) of the messages you want to keep\n        \"\"\"\n</code></pre>"},{"location":"api/#xrlint.processor.ProcessorOp.preprocess","title":"<code>preprocess(file_path, opener_options)</code>  <code>abstractmethod</code>","text":"<p>Pre-process a dataset given by its <code>file_path</code> and <code>opener_options</code>. In this method you use the <code>file_path</code> to read zero, one, or more datasets to lint.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>A file path</p> required <code>opener_options</code> <code>dict[str, Any]</code> <p>The configuration's <code>opener_options</code>.</p> required <p>Returns:     A list of (dataset, file_path) pairs</p> Source code in <code>xrlint\\processor.py</code> <pre><code>@abstractmethod\ndef preprocess(\n    self, file_path: str, opener_options: dict[str, Any]\n) -&gt; list[tuple[xr.Dataset, str]]:\n    \"\"\"Pre-process a dataset given by its `file_path` and `opener_options`.\n    In this method you use the `file_path` to read zero, one, or more\n    datasets to lint.\n\n    Args:\n        file_path: A file path\n        opener_options: The configuration's `opener_options`.\n    Returns:\n        A list of (dataset, file_path) pairs\n    \"\"\"\n</code></pre>"},{"location":"api/#xrlint.processor.ProcessorOp.postprocess","title":"<code>postprocess(messages, file_path)</code>  <code>abstractmethod</code>","text":"<p>Post-process the outputs of each dataset from <code>preprocess()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list[list[Message]]</code> <p>contains two-dimensional array of \u00b4Message\u00b4 objects where each top-level array item contains array of lint messages related to the dataset that was returned in array from <code>preprocess()</code> method</p> required <code>file_path</code> <code>str</code> <p>The corresponding file path</p> required <p>Returns:</p> Type Description <code>list[Message]</code> <p>A one-dimensional array (list) of the messages you want to keep</p> Source code in <code>xrlint\\processor.py</code> <pre><code>@abstractmethod\ndef postprocess(\n    self, messages: list[list[Message]], file_path: str\n) -&gt; list[Message]:\n    \"\"\"Post-process the outputs of each dataset from `preprocess()`.\n\n    Args:\n        messages: contains two-dimensional array of \u00b4Message\u00b4 objects\n            where each top-level array item contains array of lint messages\n            related to the dataset that was returned in array from\n            `preprocess()` method\n        file_path: The corresponding file path\n\n    Returns:\n        A one-dimensional array (list) of the messages you want to keep\n    \"\"\"\n</code></pre>"},{"location":"api/#class-ruleconfig","title":"Class <code>RuleConfig</code>","text":"<p>A rule configuration.</p> <p>You should not use the class constructor directly. Instead, use the <code>RuleConfig.from_value()</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>severity</code> <code>Literal[0, 1, 2]</code> <p>rule severity, one of <code>2</code> (error), <code>1</code> (warn), or <code>0</code> (off)</p> required <code>args</code> <code>tuple[Any, ...]</code> <p>rule operation arguments.</p> <code>tuple()</code> <code>kwargs</code> <code>dict[str, Any]</code> <p>rule operation keyword-arguments.</p> <code>dict()</code> Source code in <code>xrlint\\rule.py</code> <pre><code>@dataclass(frozen=True)\nclass RuleConfig:\n    \"\"\"A rule configuration.\n\n    You should not use the class constructor directly.\n    Instead, use the `RuleConfig.from_value()` function.\n\n    Args:\n        severity: rule severity, one of `2` (error), `1` (warn), or `0` (off)\n        args: rule operation arguments.\n        kwargs: rule operation keyword-arguments.\n    \"\"\"\n\n    severity: Literal[0, 1, 2]\n    \"\"\"Rule severity, one of `2` (error), `1` (warn), or `0` (off).\"\"\"\n\n    args: tuple[Any, ...] = field(default_factory=tuple)\n    \"\"\"Rule operation arguments.\"\"\"\n\n    kwargs: dict[str, Any] = field(default_factory=dict)\n    \"\"\"Rule operation keyword-arguments.\"\"\"\n\n    @classmethod\n    def from_value(cls, value: Any) -&gt; \"RuleConfig\":\n        \"\"\"Convert `value` into a `RuleConfig` object.\n\n        A rule configuration value can either be a rule _severity_,\n        or a list where the first element is a rule\n        _severity_ and subsequent elements are rule arguments:\n\n        - _severity_\n        - `[`_severity_`]`\n        - `[`_severity_`,` _arg-1 | kwargs_ `]`\n        - `[`_severity_`,` _arg-1_`,` _arg-2_`,` ...`,` _arg-n | kwargs_`]`\n\n        The rule _severity_ is either\n\n        - one of `\"error\"`, `\"warn\"`, `\"off\"` or\n        - one of `2` (error), `1` (warn), `0` (off)\n\n        Args:\n            value: A rule severity or a list where the first element is a rule\n                severity and subsequent elements are rule arguments.\n                If the value is already of type `RuleConfig`it is returned as-is.\n        Returns:\n            A `RuleConfig` object.\n        \"\"\"\n        if isinstance(value, RuleConfig):\n            return value\n\n        if isinstance(value, (int, str)):\n            severity_value, options = value, ()\n        elif isinstance(value, (list, tuple)):\n            severity_value, options = (value[0], value[1:]) if value else (0, ())\n        else:\n            raise TypeError(\n                format_message_type_of(\n                    \"rule configuration\", value, \"int|str|tuple|list\"\n                )\n            )\n\n        try:\n            severity = SEVERITY_ENUM[severity_value]\n        except KeyError:\n            raise ValueError(\n                format_message_one_of(\"severity\", severity_value, SEVERITY_ENUM_TEXT)\n            )\n\n        if not options:\n            args, kwargs = (), {}\n        elif isinstance(options[-1], dict):\n            args, kwargs = options[:-1], options[-1]\n        else:\n            args, kwargs = options, {}\n\n        # noinspection PyTypeChecker\n        return RuleConfig(severity, tuple(args), dict(kwargs))\n</code></pre>"},{"location":"api/#xrlint.rule.RuleConfig.severity","title":"<code>severity</code>  <code>instance-attribute</code>","text":"<p>Rule severity, one of <code>2</code> (error), <code>1</code> (warn), or <code>0</code> (off).</p>"},{"location":"api/#xrlint.rule.RuleConfig.args","title":"<code>args = field(default_factory=tuple)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rule operation arguments.</p>"},{"location":"api/#xrlint.rule.RuleConfig.kwargs","title":"<code>kwargs = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rule operation keyword-arguments.</p>"},{"location":"api/#xrlint.rule.RuleConfig.from_value","title":"<code>from_value(value)</code>  <code>classmethod</code>","text":"<p>Convert <code>value</code> into a <code>RuleConfig</code> object.</p> <p>A rule configuration value can either be a rule severity, or a list where the first element is a rule severity and subsequent elements are rule arguments:</p> <ul> <li>severity</li> <li><code>[</code>severity<code>]</code></li> <li><code>[</code>severity<code>,</code> arg-1 | kwargs <code>]</code></li> <li><code>[</code>severity<code>,</code> arg-1<code>,</code> arg-2<code>,</code> ...<code>,</code> arg-n | kwargs<code>]</code></li> </ul> <p>The rule severity is either</p> <ul> <li>one of <code>\"error\"</code>, <code>\"warn\"</code>, <code>\"off\"</code> or</li> <li>one of <code>2</code> (error), <code>1</code> (warn), <code>0</code> (off)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>A rule severity or a list where the first element is a rule severity and subsequent elements are rule arguments. If the value is already of type <code>RuleConfig</code>it is returned as-is.</p> required <p>Returns:     A <code>RuleConfig</code> object.</p> Source code in <code>xrlint\\rule.py</code> <pre><code>@classmethod\ndef from_value(cls, value: Any) -&gt; \"RuleConfig\":\n    \"\"\"Convert `value` into a `RuleConfig` object.\n\n    A rule configuration value can either be a rule _severity_,\n    or a list where the first element is a rule\n    _severity_ and subsequent elements are rule arguments:\n\n    - _severity_\n    - `[`_severity_`]`\n    - `[`_severity_`,` _arg-1 | kwargs_ `]`\n    - `[`_severity_`,` _arg-1_`,` _arg-2_`,` ...`,` _arg-n | kwargs_`]`\n\n    The rule _severity_ is either\n\n    - one of `\"error\"`, `\"warn\"`, `\"off\"` or\n    - one of `2` (error), `1` (warn), `0` (off)\n\n    Args:\n        value: A rule severity or a list where the first element is a rule\n            severity and subsequent elements are rule arguments.\n            If the value is already of type `RuleConfig`it is returned as-is.\n    Returns:\n        A `RuleConfig` object.\n    \"\"\"\n    if isinstance(value, RuleConfig):\n        return value\n\n    if isinstance(value, (int, str)):\n        severity_value, options = value, ()\n    elif isinstance(value, (list, tuple)):\n        severity_value, options = (value[0], value[1:]) if value else (0, ())\n    else:\n        raise TypeError(\n            format_message_type_of(\n                \"rule configuration\", value, \"int|str|tuple|list\"\n            )\n        )\n\n    try:\n        severity = SEVERITY_ENUM[severity_value]\n    except KeyError:\n        raise ValueError(\n            format_message_one_of(\"severity\", severity_value, SEVERITY_ENUM_TEXT)\n        )\n\n    if not options:\n        args, kwargs = (), {}\n    elif isinstance(options[-1], dict):\n        args, kwargs = options[:-1], options[-1]\n    else:\n        args, kwargs = options, {}\n\n    # noinspection PyTypeChecker\n    return RuleConfig(severity, tuple(args), dict(kwargs))\n</code></pre>"},{"location":"api/#class-rule","title":"Class <code>Rule</code>","text":"<p>A rule comprises rule metadata and a reference to the class that implements the rule's logic.</p> <p>Instances of this class can be easily created and added to a plugin by using the decorator <code>@define_rule</code> of the <code>Plugin</code> class.</p> <p>Parameters:</p> Name Type Description Default <code>meta</code> <code>RuleMeta</code> <p>the rule's metadata</p> required <code>op_class</code> <code>Type[RuleOp]</code> <p>the class that implements the rule's logic</p> required Source code in <code>xrlint\\rule.py</code> <pre><code>@dataclass(frozen=True)\nclass Rule:\n    \"\"\"A rule comprises rule metadata and a reference to the\n    class that implements the rule's logic.\n\n    Instances of this class can be easily created and added to a plugin\n    by using the decorator `@define_rule` of the `Plugin` class.\n\n    Args:\n        meta: the rule's metadata\n        op_class: the class that implements the rule's logic\n    \"\"\"\n\n    meta: RuleMeta\n    \"\"\"Rule metadata of type `RuleMeta`.\"\"\"\n\n    op_class: Type[RuleOp]\n    \"\"\"The class the implements the rule's verification operation.\n    The class must implement the `RuleOp` interface.\n    \"\"\"\n</code></pre>"},{"location":"api/#xrlint.rule.Rule.meta","title":"<code>meta</code>  <code>instance-attribute</code>","text":"<p>Rule metadata of type <code>RuleMeta</code>.</p>"},{"location":"api/#xrlint.rule.Rule.op_class","title":"<code>op_class</code>  <code>instance-attribute</code>","text":"<p>The class the implements the rule's verification operation. The class must implement the <code>RuleOp</code> interface.</p>"},{"location":"api/#class-rulemeta","title":"Class <code>RuleMeta</code>","text":"<p>               Bases: <code>ToDictMixin</code></p> <p>Rule metadata.</p> Source code in <code>xrlint\\rule.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass RuleMeta(ToDictMixin):\n    \"\"\"Rule metadata.\"\"\"\n\n    name: str\n    \"\"\"Rule name. Mandatory.\"\"\"\n\n    version: str = \"0.0.0\"\n    \"\"\"Rule version. Defaults to `0.0.0`.\"\"\"\n\n    description: str | None = None\n    \"\"\"Rule description.\"\"\"\n\n    docs_url: str | None = None\n    \"\"\"Rule documentation URL.\"\"\"\n\n    schema: dict[str, Any] | list[dict[str, Any]] | bool | None = None\n    \"\"\"JSON Schema used to specify and validate the rule verifier's\n    options.\n\n    It can take the following values:\n\n    - Use `None` (the default) to indicate that the rule verifier\n      as no options at all.\n    - Use a schema to indicate that the rule verifier\n      takes keyword arguments only.\n      The schema's type must be `\"object\"`.\n    - Use a list of schemas to indicate that the rule verifier\n      takes positional arguments only.\n      If given, the number of schemas in the list specifies the\n      number of positional arguments that must be configured.\n    \"\"\"\n\n    type: Literal[\"problem\", \"suggestion\", \"layout\"] = \"problem\"\n    \"\"\"Rule type. Defaults to `\"problem\"`.\n\n    The type field can have one of the following values:\n\n    - `\"problem\"`: Indicates that the rule addresses datasets that are\n      likely to cause errors or unexpected behavior during runtime.\n      These issues usually represent real bugs or potential runtime problems.\n    - `\"suggestion\"`: Used for rules that suggest structural improvements\n      or enforce best practices. These issues are not necessarily bugs, but\n      following the suggestions may lead to more readable, maintainable, or\n      consistent datasets.\n    - `\"layout\"`: Specifies that the rule enforces consistent stylistic\n      aspects of dataset formatting, e.g., whitespaces in names.\n      Issues with layout rules are often automatically fixable\n      (not supported yet).\n\n    Primarily serves to categorize the rule's purpose for the benefit\n    of developers and tools that consume XRLint output.\n    It doesn\u2019t directly affect the linting logic - that part is handled\n    by the rule\u2019s implementation and its configured severity.\n    \"\"\"\n</code></pre>"},{"location":"api/#xrlint.rule.RuleMeta.name","title":"<code>name</code>  <code>instance-attribute</code>","text":"<p>Rule name. Mandatory.</p>"},{"location":"api/#xrlint.rule.RuleMeta.version","title":"<code>version = '0.0.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rule version. Defaults to <code>0.0.0</code>.</p>"},{"location":"api/#xrlint.rule.RuleMeta.description","title":"<code>description = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rule description.</p>"},{"location":"api/#xrlint.rule.RuleMeta.docs_url","title":"<code>docs_url = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rule documentation URL.</p>"},{"location":"api/#xrlint.rule.RuleMeta.schema","title":"<code>schema = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>JSON Schema used to specify and validate the rule verifier's options.</p> <p>It can take the following values:</p> <ul> <li>Use <code>None</code> (the default) to indicate that the rule verifier   as no options at all.</li> <li>Use a schema to indicate that the rule verifier   takes keyword arguments only.   The schema's type must be <code>\"object\"</code>.</li> <li>Use a list of schemas to indicate that the rule verifier   takes positional arguments only.   If given, the number of schemas in the list specifies the   number of positional arguments that must be configured.</li> </ul>"},{"location":"api/#xrlint.rule.RuleMeta.type","title":"<code>type = 'problem'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rule type. Defaults to <code>\"problem\"</code>.</p> <p>The type field can have one of the following values:</p> <ul> <li><code>\"problem\"</code>: Indicates that the rule addresses datasets that are   likely to cause errors or unexpected behavior during runtime.   These issues usually represent real bugs or potential runtime problems.</li> <li><code>\"suggestion\"</code>: Used for rules that suggest structural improvements   or enforce best practices. These issues are not necessarily bugs, but   following the suggestions may lead to more readable, maintainable, or   consistent datasets.</li> <li><code>\"layout\"</code>: Specifies that the rule enforces consistent stylistic   aspects of dataset formatting, e.g., whitespaces in names.   Issues with layout rules are often automatically fixable   (not supported yet).</li> </ul> <p>Primarily serves to categorize the rule's purpose for the benefit of developers and tools that consume XRLint output. It doesn\u2019t directly affect the linting logic - that part is handled by the rule\u2019s implementation and its configured severity.</p>"},{"location":"api/#class-ruleop","title":"Class <code>RuleOp</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Define the specific rule verification operation.</p> Source code in <code>xrlint\\rule.py</code> <pre><code>class RuleOp(ABC):\n    \"\"\"Define the specific rule verification operation.\"\"\"\n\n    def dataset(self, context: RuleContext, node: DatasetNode) -&gt; None:\n        \"\"\"Verify the given dataset node.\n\n        Args:\n            context: The current rule context.\n            node: The dataset node.\n        Raises:\n            RuleExit: to exit rule logic and further node traversal\n        \"\"\"\n\n    def data_array(self, context: RuleContext, node: DataArrayNode) -&gt; None:\n        \"\"\"Verify the given data array (variable) node.\n\n        Args:\n            context: The current rule context.\n            node: The data array (variable) node.\n        Raises:\n            RuleExit: to exit rule logic and further node traversal\n        \"\"\"\n\n    def attrs(self, context: RuleContext, node: AttrsNode) -&gt; None:\n        \"\"\"Verify the given attributes node.\n\n        Args:\n            context: The current rule context.\n            node: The attributes node.\n        Raises:\n            RuleExit: to exit rule logic and further node traversal\n        \"\"\"\n\n    def attr(self, context: RuleContext, node: AttrNode) -&gt; None:\n        \"\"\"Verify the given attribute node.\n\n        Args:\n            context: The current rule context.\n            node: The attribute node.\n        Raises:\n            RuleExit: to exit rule logic and further node traversal\n        \"\"\"\n</code></pre>"},{"location":"api/#xrlint.rule.RuleOp.dataset","title":"<code>dataset(context, node)</code>","text":"<p>Verify the given dataset node.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>RuleContext</code> <p>The current rule context.</p> required <code>node</code> <code>DatasetNode</code> <p>The dataset node.</p> required <p>Raises:     RuleExit: to exit rule logic and further node traversal</p> Source code in <code>xrlint\\rule.py</code> <pre><code>def dataset(self, context: RuleContext, node: DatasetNode) -&gt; None:\n    \"\"\"Verify the given dataset node.\n\n    Args:\n        context: The current rule context.\n        node: The dataset node.\n    Raises:\n        RuleExit: to exit rule logic and further node traversal\n    \"\"\"\n</code></pre>"},{"location":"api/#xrlint.rule.RuleOp.data_array","title":"<code>data_array(context, node)</code>","text":"<p>Verify the given data array (variable) node.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>RuleContext</code> <p>The current rule context.</p> required <code>node</code> <code>DataArrayNode</code> <p>The data array (variable) node.</p> required <p>Raises:     RuleExit: to exit rule logic and further node traversal</p> Source code in <code>xrlint\\rule.py</code> <pre><code>def data_array(self, context: RuleContext, node: DataArrayNode) -&gt; None:\n    \"\"\"Verify the given data array (variable) node.\n\n    Args:\n        context: The current rule context.\n        node: The data array (variable) node.\n    Raises:\n        RuleExit: to exit rule logic and further node traversal\n    \"\"\"\n</code></pre>"},{"location":"api/#xrlint.rule.RuleOp.attrs","title":"<code>attrs(context, node)</code>","text":"<p>Verify the given attributes node.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>RuleContext</code> <p>The current rule context.</p> required <code>node</code> <code>AttrsNode</code> <p>The attributes node.</p> required <p>Raises:     RuleExit: to exit rule logic and further node traversal</p> Source code in <code>xrlint\\rule.py</code> <pre><code>def attrs(self, context: RuleContext, node: AttrsNode) -&gt; None:\n    \"\"\"Verify the given attributes node.\n\n    Args:\n        context: The current rule context.\n        node: The attributes node.\n    Raises:\n        RuleExit: to exit rule logic and further node traversal\n    \"\"\"\n</code></pre>"},{"location":"api/#xrlint.rule.RuleOp.attr","title":"<code>attr(context, node)</code>","text":"<p>Verify the given attribute node.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>RuleContext</code> <p>The current rule context.</p> required <code>node</code> <code>AttrNode</code> <p>The attribute node.</p> required <p>Raises:     RuleExit: to exit rule logic and further node traversal</p> Source code in <code>xrlint\\rule.py</code> <pre><code>def attr(self, context: RuleContext, node: AttrNode) -&gt; None:\n    \"\"\"Verify the given attribute node.\n\n    Args:\n        context: The current rule context.\n        node: The attribute node.\n    Raises:\n        RuleExit: to exit rule logic and further node traversal\n    \"\"\"\n</code></pre>"},{"location":"api/#class-rulecontext","title":"Class <code>RuleContext</code>","text":"<p>               Bases: <code>ABC</code></p> <p>The context passed to the verifier of a rule.</p> <p>You should never create instances of this class yourself. Instances of this interface are passed to the <code>RuleOp</code>'s methods.</p> Source code in <code>xrlint\\rule.py</code> <pre><code>class RuleContext(ABC):\n    \"\"\"The context passed to the verifier of a rule.\n\n    You should never create instances of this class yourself.\n    Instances of this interface are passed to the `RuleOp`'s\n    methods.\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def settings(self) -&gt; dict[str, Any]:\n        \"\"\"Configuration settings.\"\"\"\n\n    @property\n    @abstractmethod\n    def dataset(self) -&gt; xr.Dataset:\n        \"\"\"Get the current dataset.\"\"\"\n\n    @property\n    @abstractmethod\n    def file_path(self) -&gt; str:\n        \"\"\"Get the current dataset's file path.\"\"\"\n\n    @abstractmethod\n    def report(\n        self,\n        message: str,\n        *,\n        fatal: bool | None = None,\n        suggestions: list[Suggestion | str] | None = None,\n    ):\n        \"\"\"Report an issue.\n\n        Args:\n            message: mandatory message text\n            fatal: True, if a fatal error is reported.\n            suggestions: A list of suggestions for the user\n                on how to fix the reported issue. Items may\n                be of type `Suggestion` or `str`.\n        \"\"\"\n</code></pre>"},{"location":"api/#xrlint.rule.RuleContext.settings","title":"<code>settings</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Configuration settings.</p>"},{"location":"api/#xrlint.rule.RuleContext.dataset","title":"<code>dataset</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the current dataset.</p>"},{"location":"api/#xrlint.rule.RuleContext.file_path","title":"<code>file_path</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the current dataset's file path.</p>"},{"location":"api/#xrlint.rule.RuleContext.report","title":"<code>report(message, *, fatal=None, suggestions=None)</code>  <code>abstractmethod</code>","text":"<p>Report an issue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>mandatory message text</p> required <code>fatal</code> <code>bool | None</code> <p>True, if a fatal error is reported.</p> <code>None</code> <code>suggestions</code> <code>list[Suggestion | str] | None</code> <p>A list of suggestions for the user on how to fix the reported issue. Items may be of type <code>Suggestion</code> or <code>str</code>.</p> <code>None</code> Source code in <code>xrlint\\rule.py</code> <pre><code>@abstractmethod\ndef report(\n    self,\n    message: str,\n    *,\n    fatal: bool | None = None,\n    suggestions: list[Suggestion | str] | None = None,\n):\n    \"\"\"Report an issue.\n\n    Args:\n        message: mandatory message text\n        fatal: True, if a fatal error is reported.\n        suggestions: A list of suggestions for the user\n            on how to fix the reported issue. Items may\n            be of type `Suggestion` or `str`.\n    \"\"\"\n</code></pre>"},{"location":"api/#class-ruletester","title":"Class <code>RuleTester</code>","text":"<p>Utility that helps to test rules.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any]</code> <p>optional XRLint configuration.</p> <code>{}</code> Source code in <code>xrlint\\testing.py</code> <pre><code>class RuleTester:\n    \"\"\"Utility that helps to test rules.\n\n    Args:\n        config: optional XRLint configuration.\n    \"\"\"\n\n    def __init__(self, **config: dict[str, Any]):\n        self._config = config\n\n    def run(\n        self,\n        rule_name: str,\n        rule_verifier_class: Type[RuleOp],\n        *,\n        valid: list[RuleTest] | None = None,\n        invalid: list[RuleTest] | None = None,\n    ):\n        \"\"\"Run the given tests in `valid` and `invalid`\n        against the given rule.\n\n        Args:\n            rule_name: the rule's name\n            rule_verifier_class: the class derived from `RuleVerifier`\n            valid: list of tests that expect no reported problems\n            invalid: list of tests that expect reported problems\n\n        Raises:\n            AssertionError: if one of the checks fails\n        \"\"\"\n        tests = self._create_tests(\n            rule_name, rule_verifier_class, valid=valid, invalid=invalid\n        )\n        for test in tests.values():\n            print(f\"Rule {rule_name!r}: running {test.__name__}()...\")\n            # noinspection PyTypeChecker\n            test(None)\n\n    @classmethod\n    def define_test(\n        cls,\n        rule_name: str,\n        rule_verifier_class: Type[RuleOp],\n        *,\n        valid: list[RuleTest] | None = None,\n        invalid: list[RuleTest] | None = None,\n        config: dict[str, Any] | None = None,\n    ) -&gt; Type[unittest.TestCase]:\n        \"\"\"Create a `unittest.TestCase` class for the given rule and tests.\n\n        The returned class is derived from `unittest.TestCase`\n        and contains a test method for each of the tests in\n        `valid` and `invalid`.\n\n        Args:\n            rule_name: the rule's name\n            rule_verifier_class: the class derived from `RuleVerifier`\n            valid: list of tests that expect no reported problems\n            invalid: list of tests that expect reported problems\n            config: optional xrlint configuration\n        Returns:\n            A new class derived from `unittest.TestCase`.\n        \"\"\"\n        tester = RuleTester(**(config or {}))\n        tests = tester._create_tests(\n            rule_name, rule_verifier_class, valid=valid, invalid=invalid\n        )\n        # noinspection PyTypeChecker\n        return type(f\"{rule_verifier_class.__name__}Test\", (unittest.TestCase,), tests)\n\n    def _create_tests(\n        self,\n        rule_name: str,\n        rule_verifier_class: Type[RuleOp],\n        valid: list[RuleTest] | None,\n        invalid: list[RuleTest] | None,\n    ) -&gt; dict[str, Callable[[unittest.TestCase | None], None]]:\n        def make_args(tests: list[RuleTest] | None, mode: Literal[\"valid\", \"invalid\"]):\n            return [(test, index, mode) for index, test in enumerate(tests or [])]\n\n        return dict(\n            self._create_test(rule_name, rule_verifier_class, *args)\n            for args in make_args(valid, \"valid\") + make_args(invalid, \"invalid\")\n        )\n\n    def _create_test(\n        self,\n        rule_name: str,\n        rule_verifier_class: Type[RuleOp],\n        test: RuleTest,\n        test_index: int,\n        test_mode: Literal[\"valid\", \"invalid\"],\n    ) -&gt; tuple[str, Callable]:\n        test_id = _format_test_id(test, test_index, test_mode)\n\n        def test_fn(_self: unittest.TestCase):\n            error_message = self._test_rule(\n                rule_name, rule_verifier_class, test, test_id, test_mode\n            )\n            if error_message:\n                raise AssertionError(error_message)\n\n        test_fn.__name__ = test_id\n        return test_id, test_fn\n\n    def _test_rule(\n        self,\n        rule_name: str,\n        rule_op_class: Type[RuleOp],\n        test: RuleTest,\n        test_id: str,\n        test_mode: Literal[\"valid\", \"invalid\"],\n    ) -&gt; str | None:\n        # Note, the rule's code cannot and should not depend\n        # on the currently configured severity.\n        # There is also no way for a rule to obtain the severity.\n        severity = SEVERITY_ERROR\n        linter = Linter(**self._config)\n        result = linter.verify_dataset(\n            test.dataset,\n            plugins={\n                \"test\": (\n                    Plugin(\n                        meta=PluginMeta(name=\"test\"),\n                        rules={\n                            rule_name: Rule(\n                                meta=RuleMeta(name=rule_name), op_class=rule_op_class\n                            )\n                        },\n                    )\n                )\n            },\n            rules={\n                f\"test/{rule_name}\": (\n                    [severity, *(test.args or ()), (test.kwargs or {})]\n                    if test.args or test.kwargs\n                    else severity\n                )\n            },\n        )\n\n        assert_ok = _assert_valid if test_mode == \"valid\" else _assert_invalid\n        if assert_ok(result):\n            return None\n        else:\n            return _format_error_message(rule_name, test_id, test_mode, result)\n</code></pre>"},{"location":"api/#xrlint.testing.RuleTester.run","title":"<code>run(rule_name, rule_verifier_class, *, valid=None, invalid=None)</code>","text":"<p>Run the given tests in <code>valid</code> and <code>invalid</code> against the given rule.</p> <p>Parameters:</p> Name Type Description Default <code>rule_name</code> <code>str</code> <p>the rule's name</p> required <code>rule_verifier_class</code> <code>Type[RuleOp]</code> <p>the class derived from <code>RuleVerifier</code></p> required <code>valid</code> <code>list[RuleTest] | None</code> <p>list of tests that expect no reported problems</p> <code>None</code> <code>invalid</code> <code>list[RuleTest] | None</code> <p>list of tests that expect reported problems</p> <code>None</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>if one of the checks fails</p> Source code in <code>xrlint\\testing.py</code> <pre><code>def run(\n    self,\n    rule_name: str,\n    rule_verifier_class: Type[RuleOp],\n    *,\n    valid: list[RuleTest] | None = None,\n    invalid: list[RuleTest] | None = None,\n):\n    \"\"\"Run the given tests in `valid` and `invalid`\n    against the given rule.\n\n    Args:\n        rule_name: the rule's name\n        rule_verifier_class: the class derived from `RuleVerifier`\n        valid: list of tests that expect no reported problems\n        invalid: list of tests that expect reported problems\n\n    Raises:\n        AssertionError: if one of the checks fails\n    \"\"\"\n    tests = self._create_tests(\n        rule_name, rule_verifier_class, valid=valid, invalid=invalid\n    )\n    for test in tests.values():\n        print(f\"Rule {rule_name!r}: running {test.__name__}()...\")\n        # noinspection PyTypeChecker\n        test(None)\n</code></pre>"},{"location":"api/#xrlint.testing.RuleTester.define_test","title":"<code>define_test(rule_name, rule_verifier_class, *, valid=None, invalid=None, config=None)</code>  <code>classmethod</code>","text":"<p>Create a <code>unittest.TestCase</code> class for the given rule and tests.</p> <p>The returned class is derived from <code>unittest.TestCase</code> and contains a test method for each of the tests in <code>valid</code> and <code>invalid</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rule_name</code> <code>str</code> <p>the rule's name</p> required <code>rule_verifier_class</code> <code>Type[RuleOp]</code> <p>the class derived from <code>RuleVerifier</code></p> required <code>valid</code> <code>list[RuleTest] | None</code> <p>list of tests that expect no reported problems</p> <code>None</code> <code>invalid</code> <code>list[RuleTest] | None</code> <p>list of tests that expect reported problems</p> <code>None</code> <code>config</code> <code>dict[str, Any] | None</code> <p>optional xrlint configuration</p> <code>None</code> <p>Returns:     A new class derived from <code>unittest.TestCase</code>.</p> Source code in <code>xrlint\\testing.py</code> <pre><code>@classmethod\ndef define_test(\n    cls,\n    rule_name: str,\n    rule_verifier_class: Type[RuleOp],\n    *,\n    valid: list[RuleTest] | None = None,\n    invalid: list[RuleTest] | None = None,\n    config: dict[str, Any] | None = None,\n) -&gt; Type[unittest.TestCase]:\n    \"\"\"Create a `unittest.TestCase` class for the given rule and tests.\n\n    The returned class is derived from `unittest.TestCase`\n    and contains a test method for each of the tests in\n    `valid` and `invalid`.\n\n    Args:\n        rule_name: the rule's name\n        rule_verifier_class: the class derived from `RuleVerifier`\n        valid: list of tests that expect no reported problems\n        invalid: list of tests that expect reported problems\n        config: optional xrlint configuration\n    Returns:\n        A new class derived from `unittest.TestCase`.\n    \"\"\"\n    tester = RuleTester(**(config or {}))\n    tests = tester._create_tests(\n        rule_name, rule_verifier_class, valid=valid, invalid=invalid\n    )\n    # noinspection PyTypeChecker\n    return type(f\"{rule_verifier_class.__name__}Test\", (unittest.TestCase,), tests)\n</code></pre>"},{"location":"api/#class-ruletest","title":"Class <code>RuleTest</code>","text":"<p>A rule test case.</p> Source code in <code>xrlint\\testing.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass RuleTest:\n    \"\"\"A rule test case.\"\"\"\n\n    dataset: xr.Dataset\n    \"\"\"The dataset to verify.\"\"\"\n\n    name: str | None = None\n    \"\"\"A name that helps identifying the test case.\"\"\"\n\n    args: tuple | list | None = None\n    \"\"\"Optional positional arguments passed to the rule verifier's constructor.\"\"\"\n\n    kwargs: dict[str, Any] | None = None\n    \"\"\"Optional keyword arguments passed to the rule verifier's constructor.\"\"\"\n\n    expected: list[Message] | int | None = 0\n    \"\"\"Expected messages.\n    Either a list of expected message objects or\n    the number of expected message.\n    Must not be provided for valid checks\n    and must be provided for invalid checks.\n    \"\"\"\n</code></pre>"},{"location":"api/#xrlint.testing.RuleTest.dataset","title":"<code>dataset</code>  <code>instance-attribute</code>","text":"<p>The dataset to verify.</p>"},{"location":"api/#xrlint.testing.RuleTest.name","title":"<code>name = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A name that helps identifying the test case.</p>"},{"location":"api/#xrlint.testing.RuleTest.args","title":"<code>args = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional positional arguments passed to the rule verifier's constructor.</p>"},{"location":"api/#xrlint.testing.RuleTest.kwargs","title":"<code>kwargs = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional keyword arguments passed to the rule verifier's constructor.</p>"},{"location":"api/#xrlint.testing.RuleTest.expected","title":"<code>expected = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Expected messages. Either a list of expected message objects or the number of expected message. Must not be provided for valid checks and must be provided for invalid checks.</p>"},{"location":"api/#class-result","title":"Class <code>Result</code>","text":"<p>               Bases: <code>ToDictMixin</code></p> <p>The aggregated information of linting a dataset.</p> Source code in <code>xrlint\\result.py</code> <pre><code>@dataclass()\nclass Result(ToDictMixin):\n    \"\"\"The aggregated information of linting a dataset.\"\"\"\n\n    config: Union[\"Config\", None] = None\n    \"\"\"Configuration.\"\"\"\n\n    file_path: str = MISSING_DATASET_FILE_PATH\n    \"\"\"The absolute path to the file of this result.\n    This is the string \"&lt;dataset&gt;\" if the file path is unknown\n    (when you didn't pass the `file_path` option to the\n    `xrlint.lint_dataset()` method).\n    \"\"\"\n\n    messages: list[Message] = field(default_factory=list)\n    \"\"\"The array of message objects.\"\"\"\n\n    fixable_error_count: int = 0\n    \"\"\"The number of errors that can be fixed automatically\n     by the fix constructor option.\n     \"\"\"\n\n    fixable_warning_count: int = 0\n    \"\"\"The number of warnings that can be fixed automatically\n     by the fix constructor option.\n     \"\"\"\n\n    error_count: int = 0\n    \"\"\"The number of errors. This includes fixable errors\n     and fatal errors.\n     \"\"\"\n\n    fatal_error_count: int = 0\n    \"\"\"The number of fatal errors.\"\"\"\n\n    warning_count: int = 0\n    \"\"\"The number of warnings. This includes fixable warnings.\"\"\"\n\n    @classmethod\n    def new(\n        cls,\n        config: Union[\"Config\", None] = None,\n        file_path: str | None = None,\n        messages: list[Message] | None = None,\n    ):\n        result = Result(\n            config=config,\n            file_path=file_path or MISSING_DATASET_FILE_PATH,\n            messages=messages or [],\n        )\n        for m in messages:\n            result.warning_count += 1 if m.severity == SEVERITY_WARN else 0\n            result.error_count += 1 if m.severity == SEVERITY_ERROR else 0\n            result.fatal_error_count += 1 if m.fatal else 0\n        return result\n\n    def to_html(self) -&gt; str:\n        text = []\n        escaped_path = html.escape(self.file_path)\n        if not self.messages:\n            text.append(f'&lt;p role=\"file\"&gt;{escaped_path} - ok&lt;/p&gt;\\n')\n        else:\n            text.append(f'&lt;p role=\"file\"&gt;{escaped_path}:&lt;/p&gt;\\n')\n            table_data = []\n            for m in self.messages:\n                table_data.append(\n                    [\n                        m.node_path,\n                        SEVERITY_CODE_TO_NAME.get(m.severity),\n                        m.message,\n                        m.rule_id,\n                    ]\n                )\n            text.append(tabulate(table_data, headers=(), tablefmt=\"html\"))\n            text.append(\n                '&lt;p role=\"summary\"&gt;'\n                f\"{format_problems(self.error_count, self.warning_count)}\"\n                \"&lt;/p&gt;\\n\"\n            )\n        return \"\".join(text)\n\n    def _repr_html_(self) -&gt; str:\n        return self.to_html()\n</code></pre>"},{"location":"api/#xrlint.result.Result.config","title":"<code>config = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Configuration.</p>"},{"location":"api/#xrlint.result.Result.file_path","title":"<code>file_path = MISSING_DATASET_FILE_PATH</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The absolute path to the file of this result. This is the string \"\" if the file path is unknown (when you didn't pass the <code>file_path</code> option to the <code>xrlint.lint_dataset()</code> method)."},{"location":"api/#xrlint.result.Result.messages","title":"<code>messages = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The array of message objects.</p>"},{"location":"api/#xrlint.result.Result.fixable_error_count","title":"<code>fixable_error_count = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The number of errors that can be fixed automatically by the fix constructor option.</p>"},{"location":"api/#xrlint.result.Result.fixable_warning_count","title":"<code>fixable_warning_count = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The number of warnings that can be fixed automatically by the fix constructor option.</p>"},{"location":"api/#xrlint.result.Result.error_count","title":"<code>error_count = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The number of errors. This includes fixable errors and fatal errors.</p>"},{"location":"api/#xrlint.result.Result.fatal_error_count","title":"<code>fatal_error_count = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The number of fatal errors.</p>"},{"location":"api/#xrlint.result.Result.warning_count","title":"<code>warning_count = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The number of warnings. This includes fixable warnings.</p>"},{"location":"api/#class-message","title":"Class <code>Message</code>","text":"<p>               Bases: <code>ToDictMixin</code></p> Source code in <code>xrlint\\result.py</code> <pre><code>@dataclass()\nclass Message(ToDictMixin):\n    message: str\n    \"\"\"The error message.\"\"\"\n\n    node_path: str | None = None\n    \"\"\"Node path within the dataset.\n    This property is None if the message does not\n    apply to a certain dataset node.\n    \"\"\"\n\n    rule_id: str | None = None\n    \"\"\"The rule name that generated this lint message.\n    If this message is generated by the xrlint core\n    rather than rules, this is None.\n    \"\"\"\n\n    severity: Literal[1, 2] | None = None\n    \"\"\"The severity of this message.\n    `1` means warning and `2` means error.\n    \"\"\"\n\n    fatal: bool | None = None\n    \"\"\"True if this is a fatal error unrelated to a rule,\n    like a parsing error.\n    \"\"\"\n\n    fix: EditInfo | None = None\n    \"\"\"The EditInfo object of autofix.\n    This property is None if this\n    message is not fixable.\n\n    Not used yet.\n    \"\"\"\n\n    suggestions: list[Suggestion] | None = None\n    \"\"\"The list of suggestions. Each suggestion is the pair\n    of a description and an EditInfo object to fix the dataset.\n    API users such as editor integrations can choose one of them\n    to fix the problem of this message.\n    This property is None if this message does not have any suggestions.\n    \"\"\"\n</code></pre>"},{"location":"api/#xrlint.result.Message.message","title":"<code>message</code>  <code>instance-attribute</code>","text":"<p>The error message.</p>"},{"location":"api/#xrlint.result.Message.node_path","title":"<code>node_path = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Node path within the dataset. This property is None if the message does not apply to a certain dataset node.</p>"},{"location":"api/#xrlint.result.Message.rule_id","title":"<code>rule_id = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The rule name that generated this lint message. If this message is generated by the xrlint core rather than rules, this is None.</p>"},{"location":"api/#xrlint.result.Message.severity","title":"<code>severity = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The severity of this message. <code>1</code> means warning and <code>2</code> means error.</p>"},{"location":"api/#xrlint.result.Message.fatal","title":"<code>fatal = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>True if this is a fatal error unrelated to a rule, like a parsing error.</p>"},{"location":"api/#xrlint.result.Message.fix","title":"<code>fix = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The EditInfo object of autofix. This property is None if this message is not fixable.</p> <p>Not used yet.</p>"},{"location":"api/#xrlint.result.Message.suggestions","title":"<code>suggestions = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The list of suggestions. Each suggestion is the pair of a description and an EditInfo object to fix the dataset. API users such as editor integrations can choose one of them to fix the problem of this message. This property is None if this message does not have any suggestions.</p>"},{"location":"api/#class-suggestion","title":"Class <code>Suggestion</code>","text":"<p>               Bases: <code>ToDictMixin</code></p> Source code in <code>xrlint\\result.py</code> <pre><code>@dataclass(frozen=True)\nclass Suggestion(ToDictMixin):\n    desc: str\n    \"\"\"Description of the suggestion.\"\"\"\n\n    data: dict[str, None] | None = None\n    \"\"\"Data that can be referenced in the description.\"\"\"\n\n    fix: EditInfo | None = None\n    \"\"\"Not used yet.\"\"\"\n\n    @classmethod\n    def from_value(cls, value: Any):\n        \"\"\"Convert given `value` into a `Suggestion` object.\n\n        If `value` is already a `Suggestion` then it is returned as-is.\n\n        Args:\n            value: A `Suggestion` object or a `str` containing the\n                suggestion text.\n        Returns:\n            A `Suggestion` object.\n        \"\"\"\n        if isinstance(value, Suggestion):\n            return value\n        if isinstance(value, str):\n            return Suggestion(value)\n        raise TypeError(format_message_type_of(\"value\", value, \"Suggestion|str\"))\n</code></pre>"},{"location":"api/#xrlint.result.Suggestion.desc","title":"<code>desc</code>  <code>instance-attribute</code>","text":"<p>Description of the suggestion.</p>"},{"location":"api/#xrlint.result.Suggestion.data","title":"<code>data = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Data that can be referenced in the description.</p>"},{"location":"api/#xrlint.result.Suggestion.fix","title":"<code>fix = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Not used yet.</p>"},{"location":"api/#xrlint.result.Suggestion.from_value","title":"<code>from_value(value)</code>  <code>classmethod</code>","text":"<p>Convert given <code>value</code> into a <code>Suggestion</code> object.</p> <p>If <code>value</code> is already a <code>Suggestion</code> then it is returned as-is.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>A <code>Suggestion</code> object or a <code>str</code> containing the suggestion text.</p> required <p>Returns:     A <code>Suggestion</code> object.</p> Source code in <code>xrlint\\result.py</code> <pre><code>@classmethod\ndef from_value(cls, value: Any):\n    \"\"\"Convert given `value` into a `Suggestion` object.\n\n    If `value` is already a `Suggestion` then it is returned as-is.\n\n    Args:\n        value: A `Suggestion` object or a `str` containing the\n            suggestion text.\n    Returns:\n        A `Suggestion` object.\n    \"\"\"\n    if isinstance(value, Suggestion):\n        return value\n    if isinstance(value, str):\n        return Suggestion(value)\n    raise TypeError(format_message_type_of(\"value\", value, \"Suggestion|str\"))\n</code></pre>"},{"location":"cli/","title":"Command Line Interface","text":"<p>After installation, the <code>xrlint</code> command can be used from the terminal.  The following are the command's options and arguments:</p> <pre><code>Usage: xrlint [OPTIONS] [FILES]...\n\n  Validate the given dataset FILES.\n\n  Reads configuration from `./xrlint_config.*` if such file exists and unless\n  `--no_config_lookup` is set or `--config` is provided. Then validates each\n  dataset in FILES against the configuration. The default dataset patters are\n  `**/*.zarr` and `**/.nc`. FILES may comprise also directories. If a\n  directory is not matched by any file pattern, it will be traversed\n  recursively. The validation result is dumped to standard output if not\n  otherwise stated by `--output-file`. The output format is `simple` by\n  default. Other inbuilt formats are `json` and `html` which you can specify\n  using the `--format` option.\n\nOptions:\n  --no-config-lookup      Disable use of default configuration from\n                          xrlint_config.*\n  -c, --config FILE       Use this configuration, overriding xrlint_config.*\n                          config options if present\n  --print-config FILE     Print the configuration for the given file\n  --plugin MODULE         Specify plugins. MODULE is the name of Python module\n                          that defines an 'export_plugin()' function.\n  --rule SPEC             Specify rules. SPEC must have format '&lt;rule-name&gt;:\n                          &lt;rule-config&gt;' (note the space character).\n  -o, --output-file FILE  Specify file to write report to\n  -f, --format NAME       Use a specific output format - default: simple\n  --color / --no-color    Force enabling/disabling of color\n  --max-warnings COUNT    Number of warnings to trigger nonzero exit code -\n                          default: 5\n  --init                  Write initial configuration file and exit.\n  --version               Show the version and exit.\n  --help                  Show this message and exit.\n</code></pre>"},{"location":"config/","title":"Configure XRLint","text":"<p>Note: this chapter's material is based on the documentation of how to configure ESLint. Many parts have been copied and adjusted as it applies in many similar ways to XRLint. </p>"},{"location":"config/#configuration-file","title":"Configuration File","text":"<p>The XRLint configuration file may be named any of the following:</p> <ul> <li><code>xrlint_config.yaml</code></li> <li><code>xrlint_config.json</code></li> <li><code>xrlint_config.py</code></li> </ul> <p>It should be placed in the root directory of your project and export  an array of configuration objects or  references to predefined configuration objects. </p> <p>Here\u2019s a YAML example:</p> <pre><code>- files: [\"**/*.zarr\", \"**/*.nc\"]\n- plugins:\n    xcube: xrlint.plugins.xcube\n- recommended\n- xcube/recommended\n</code></pre> <p>Same using JSON:</p> <pre><code>[\n  {\"files\": [\"**/*.zarr\", \"**/*.nc\"]},\n  {\n    \"plugins\": {\n      \"xcube\": \"xrlint.plugins.xcube\"\n    }\n  },\n  \"recommended\",\n  \"xcube/recommended\"\n]\n</code></pre> <p>And as Python script:</p> <pre><code>def export_configs():\n    return [\n      {\"files\": [\"**/*.zarr\", \"**/*.nc\"]},\n      {\n        \"plugins\": {\n          \"xcube\": \"xrlint.plugins.xcube\"\n        }\n      },\n      \"recommended\",\n      \"xcube/recommended\"\n    ]\n</code></pre>"},{"location":"config/#configuration-objects","title":"Configuration Objects","text":"<p>Each configuration object contains all of the information XRLint needs  to execute on a set of files. Each configuration object is made up of  these properties:</p> <ul> <li><code>name</code> - A name for the configuration object.    This is used in error messages and config inspector to help identify which    configuration object is being used.</li> <li><code>files</code> - A list of glob patterns indicating the files that the    configuration object should apply to. If not specified, the configuration    object applies to all files matched by any other configuration object.</li> <li><code>ignores</code> - A list of glob patterns indicating the files that the    configuration object should not apply to. If not specified, the configuration    object applies to all files matched by files. If ignores is used without any    other keys in the configuration object, then the patterns act as global ignores.</li> <li><code>opener_options</code> - A dictionary specifying keyword-arguments that are passed    directly to the <code>xarray.open_dataset()</code> function. The available options are    dependent on the xarray backend selected by the <code>engine</code> option.</li> <li><code>linter_options</code> - A dictionary containing settings related to    the linting process. (Currently not used.)</li> <li><code>processor</code> - A string indicating the name of a processor inside of a plugin,    i.e., <code>\"&lt;plugin-name&gt;/&lt;processor-name&gt;\"</code>. In Python configurations    it can also be an object of type <code>ProcessorOp</code> containing   <code>preprocess()</code> and <code>postprocess()</code> methods.</li> <li><code>plugins</code> - A dictionary containing a name-value mapping of plugin names    to either plugin module names or <code>Plugin</code> objects. When <code>files</code> is specified,    these plugins are only available to the matching files.</li> <li><code>rules</code> - An object containing the configured rules.    When <code>files</code> or <code>ignores</code> are specified, these rule configurations are only    available to the matching files.</li> <li><code>settings</code> - An object containing name-value pairs of information that should    be available to all rules.</li> </ul>"},{"location":"rule-ref/","title":"Rule Reference","text":""},{"location":"rule-ref/#core-rules","title":"Core Rules","text":""},{"location":"rule-ref/#coords-for-dims","title":"<code>coords-for-dims</code>","text":"<p>Dimensions of data variables should have corresponding coordinates.</p> <p>Contained in:  <code>all</code>- <code>recommended</code>-</p>"},{"location":"rule-ref/#dataset-title-attr","title":"<code>dataset-title-attr</code>","text":"<p>Datasets should be given a non-empty title.</p> <p>Contained in:  <code>all</code>- <code>recommended</code>-</p>"},{"location":"rule-ref/#grid-mappings","title":"<code>grid-mappings</code>","text":"<p>Grid mappings, if any, shall have valid grid mapping coordinate variables.</p> <p>Contained in:  <code>all</code>- <code>recommended</code>-</p>"},{"location":"rule-ref/#no-empty-attrs","title":"<code>no-empty-attrs</code>","text":"<p>Every dataset element should have metadata that describes it.</p> <p>Contained in:  <code>all</code>- <code>recommended</code>-</p>"},{"location":"rule-ref/#var-units-attr","title":"<code>var-units-attr</code>","text":"<p>Every variable should have a valid 'units' attribute.</p> <p>Contained in:  <code>all</code>- <code>recommended</code>-</p>"},{"location":"rule-ref/#xcube-rules","title":"xcube Rules","text":""},{"location":"rule-ref/#any-spatial-data-var","title":"<code>any-spatial-data-var</code>","text":"<p>A datacube should have spatial data variables.</p> <p>Contained in:  <code>all</code>- <code>recommended</code>-</p>"},{"location":"rule-ref/#cube-dims-order","title":"<code>cube-dims-order</code>","text":"<p>Order of dimensions in spatio-temporal datacube variables should be [time, ..., y, x].</p> <p>Contained in:  <code>all</code>- <code>recommended</code>-</p>"},{"location":"rule-ref/#data-var-colors","title":"<code>data-var-colors</code>","text":"<p>Spatial data variables should encode xcube color mappings in their metadata. More information.</p> <p>Contained in:  <code>all</code>- <code>recommended</code>-</p>"},{"location":"rule-ref/#grid-mapping-naming","title":"<code>grid-mapping-naming</code>","text":"<p>Grid mapping variables should be called 'spatial_ref' or 'crs' for compatibility with rioxarray and other packages.</p> <p>Contained in:  <code>all</code>- <code>recommended</code>-</p>"},{"location":"rule-ref/#increasing-time","title":"<code>increasing-time</code>","text":"<p>Time coordinate labels should be monotonically increasing.</p> <p>Contained in:  <code>all</code>- <code>recommended</code>-</p>"},{"location":"rule-ref/#lat-lon-naming","title":"<code>lat-lon-naming</code>","text":"<p>Latitude and longitude coordinates and dimensions should be called 'lat' and 'lon'.</p> <p>Contained in:  <code>all</code>- <code>recommended</code>-</p>"},{"location":"rule-ref/#single-grid-mapping","title":"<code>single-grid-mapping</code>","text":"<p>A single grid mapping shall be used for all spatial data variables of a datacube.</p> <p>Contained in:  <code>all</code>- <code>recommended</code>-</p>"},{"location":"start/","title":"Getting Started","text":""},{"location":"start/#installation","title":"Installation","text":"<pre><code>pip install xrlint\n</code></pre> <p>or</p> <pre><code>conda install -c conda-forge xrlint\n</code></pre>"},{"location":"start/#command-line-interface","title":"Command line interface","text":"<p>Get basic help:</p> <pre><code>xrlint --help\n</code></pre> <p>Initializing a new project with</p> <pre><code>xrlint --init\n</code></pre> <p>writes a configuration file <code>xrlint.config.yaml</code>  into the current working directory:</p> <pre><code>- recommended\n</code></pre> <p>This configuration file tells XRLint to use the predefined configuration named <code>recommeded</code>.  </p> <p>Create a dataset to test XRLint:</p> <pre><code>python\n&gt;&gt;&gt; import xarray as xr\n&gt;&gt;&gt; test_ds = xr.Dataset(attrs={\"title\": \"Test Dataset\"})\n&gt;&gt;&gt; test_ds.to_zarr(\"test.zarr\") \n&gt;&gt;&gt; exit()\n</code></pre> <p>And run XRLint:</p> <pre><code>xrlint test.zarr \n</code></pre> <p>You can now override the predefined settings by adding your custom rule configurations:</p> <pre><code>- recommended\n- rules:\n    no-empty-attrs: off\n    var-units-attr: warn\n    grid-mappings: error\n</code></pre> <p>You can add rules from plugins as well:</p> <pre><code>- recommended\n- plugins:\n    xcube: xrlint.plugins.xcube\n- xcube/recommended  \n</code></pre> <p>And customize its rules, if desired:</p> <pre><code>- recommended\n- plugins:\n    xcube: xrlint.plugins.xcube\n- xcube/recommended  \n- rules:\n    xcube/grid-mapping-naming: off\n    xcube/lat-lon-naming: warn\n</code></pre> <p>Note the prefix <code>xcube/</code> used for the rule names.</p>"},{"location":"start/#python-api","title":"Python API","text":"<p>The easiest approach to use the Python API is to import <code>xrlint.all</code>. It contains all the public definitions from the <code>xrlint</code> package.</p> <pre><code>import xrlint.all as xrl\n</code></pre> <p>Start by creating a linter with recommended settings  using the <code>new_linter()</code> function .</p> <pre><code>import xarray as xr\nimport xrlint.all as xrl\n\ntest_ds = xr.Dataset(attrs={\"title\": \"Test Dataset\"})\n\nlinter = xrl.new_linter(\"recommended\")\nlinter.verify_dataset(test_ds)\n</code></pre>"},{"location":"todo/","title":"To Do","text":""},{"location":"todo/#required","title":"Required","text":"<ul> <li>populate <code>core</code> plugin by more rules, see CF site and <code>cf-check</code> tool</li> <li>populate <code>xcube</code> plugin by more rules</li> <li>add <code>docs</code></li> <li>use mkdocstrings ref syntax in docstrings</li> <li>provide configuration examples (use as tests?)</li> </ul>"},{"location":"todo/#desired","title":"Desired","text":"<ul> <li>project logo</li> <li>if configuration for given FILE is empty,   report an error, see TODO in CLI main tests</li> <li>use <code>RuleMeta.docs_url</code> in formatters to create links</li> <li>implement xarray backend for xcube 'levels' format   so can validate them too</li> <li>add some more tests so we reach 99% coverage</li> <li>support rule op args/kwargs schema validation</li> <li>Support <code>RuleTest.expected</code>, it is currently unused</li> </ul>"},{"location":"todo/#nice-to-have","title":"Nice to have","text":"<ul> <li>support <code>autofix</code> feature</li> <li>support <code>md</code> (markdown) output format</li> <li>support formatter op args/kwargs schema validation</li> </ul>"},{"location":"todo/#ideas","title":"Ideas","text":""},{"location":"todo/#allow-for-different-dataset-openers","title":"Allow for different dataset openers","text":"<ul> <li>introduce <code>dataset_options</code> config:</li> <li><code>opener: OpenerOp</code></li> <li><code>opener_options: dict[str, Any]</code></li> </ul>"},{"location":"todo/#other-plugins","title":"Other plugins","text":"<ul> <li><code>sgrid</code>: https://sgrid.github.io/sgrid/</li> <li><code>ugrid</code>: https://ugrid-conventions.github.io/ugrid-conventions/</li> </ul>"},{"location":"todo/#generalize-data-linting","title":"Generalize data linting","text":"<p>Do not limit verification to <code>xr.Dataset</code>. However, this requires new rule sets.</p> <p>To allow for other data models, we need to allow  for a specific verifier type for a given data type.</p> <p>The verifier verifies specific node types that are characteristic for a data type.</p> <p>To do so a traverser must traverse the elements of the data and pass each node to the verifier.</p> <p>Note, this is the Visitor Pattern,  where the verifier is the Visitor and a node refers to Element.</p> <p>To support the CLI mode, we need different data opener  types that can read the data from a file path.</p> <ol> <li>open data, if given data is a file path: </li> <li>find opener for file path</li> <li>open data </li> <li>verify data</li> <li>find root element type and visitor type for data </li> <li>call the root element <code>accept(verifier)</code> that verifies the       root element <code>verify.root()</code> and starts traversal of       child elements.</li> </ol>"}]}