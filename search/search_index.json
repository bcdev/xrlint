{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"XRLint - A linter for xarray datasets","text":"<p>XRLint is a linting  tool and library for xarray datasets. Its design is heavily inspired by the awesome ESLint.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Flexible validation for <code>xarray.Dataset</code> objects by configurable rules.</li> <li>Available from CLI and Python API.</li> <li>Custom plugins providing custom rule sets allow addressing    different dataset conventions.</li> <li>Project-specific configurations including configuration of individual    rules and file-specific settings.</li> </ul>"},{"location":"#inbuilt-rules","title":"Inbuilt Rules","text":"<p>The following plugins provide XRLint's inbuilt rules:</p> <ul> <li><code>core</code>: implementing the rules for   tidy data   and the    CF-Conventions.</li> <li><code>xcube</code>: implementing the rules for    xcube datasets.   Note, this plugin is fully optional. You must manually configure    it to apply its rules. It may be moved into a separate GitHub repo    once XRLint is mature enough. </li> </ul>"},{"location":"about/","title":"About XRLint","text":""},{"location":"about/#changelog","title":"Changelog","text":"<p>You can find the complete XRLint changelog  here. </p>"},{"location":"about/#reporting","title":"Reporting","text":"<p>If you have suggestions, ideas, feature requests, or if you have identified a malfunction or error, then please  post an issue. </p>"},{"location":"about/#contributions","title":"Contributions","text":"<p>The XRLint project welcomes contributions of any form as long as you respect our  code of conduct and follow our  contribution guide.</p> <p>If you'd like to submit code or documentation changes, we ask you to provide a  pull request (PR)  here.  For code and configuration changes, your PR must be linked to a  corresponding issue. </p>"},{"location":"about/#development","title":"Development","text":"<p>To install the XRLint development environment into an existing Python environment</p> <pre><code>pip install .[dev,doc]\n</code></pre> <p>or create a new environment using</p> <pre><code>mamba env create \n</code></pre>"},{"location":"about/#testing-and-coverage","title":"Testing and Coverage","text":"<p>XRLint uses pytest for unit-level testing  and code coverage analysis.</p> <pre><code>pytest --cov=xrlint --cov-report html\n</code></pre>"},{"location":"about/#code-style","title":"Code Style","text":"<p>XRLint source code is formatted using the black tool and  quality-controlled using flake8.</p> <pre><code>black .\nflake8 --max-line-length=88 . \n</code></pre>"},{"location":"about/#documentation","title":"Documentation","text":"<p>XRLint documentation is built using the mkdocs tool.</p> <p>With repository root as current working directory:</p> <pre><code>pip install .[doc]\n\nmkdocs build\nmkdocs serve\nmkdocs gh-deploy\n</code></pre> <p>The rule reference page is generated by a script called <code>mkruleref.py</code>. After changing or adding a rule, make sure you recreate the page:</p> <pre><code>python -m mkruleref\n</code></pre>"},{"location":"about/#license","title":"License","text":"<p>XRLint is open source made available under the terms and conditions of the  MIT License.</p> <p>Copyright \u00a9 2025 Brockmann Consult Development</p>"},{"location":"api/","title":"Python API","text":"<p>This chapter provides a plain reference for the XRLint Python API.</p>"},{"location":"api/#overview","title":"Overview","text":"<ul> <li>The top-level API component is the class XRLint   which encapsulates the functionality of the XRLint CLI.</li> <li>The <code>linter</code> module provides the functionality for linting a single    dataset:   new_linter() factory function and the   Linter class.</li> <li>The <code>plugin</code> module provides plugin related classes:   Plugin and its    metadata PluginMeta.</li> <li>The <code>config</code> module provides classes that represent    configuration information and provide related functionality:   Config and ConfigList.</li> <li>The <code>rule</code> module provides rule related classes and functions:   Rule comprising rule metadata    RuleMeta and the rule operation    RuleOp, as well as related to the latter   RuleContext and RuleExit.   Decorator define_rule allows defining rules.</li> <li>The <code>node</code> module defines the nodes passed to [xrlint.rule.RuleOp]:   base classes None, XarrayNode   and the specific DatasetNode,   DataArray, AttrsNode,    and AttrNode nodes.</li> <li>The <code>processor</code> module provides processor related classes and functions:   Processor comprising processor metadata   ProcessorMeta    and the processor operation ProcessorOp.   Decorator define_processor allows defining    processors.</li> <li>The <code>result</code> module provides data classes that are used to    represent validation results:   Result composed of Messages,   which again may contain Suggestions.</li> <li>Finally, the <code>testing</code> module provides classes for rule testing:   RuleTester that is made up    of RuleTests.</li> </ul> <p>Note: the <code>xrlint.all</code> convenience module exports all of the above from a    single module.</p>"},{"location":"api/#xrlint.cli.engine.XRLint","title":"<code>xrlint.cli.engine.XRLint</code>","text":"<p>               Bases: <code>FormatterContext</code></p> <p>This class provides the engine behind the XRLint CLI application. It represents the highest level component in the Python API.</p> Source code in <code>xrlint\\cli\\engine.py</code> <pre><code>class XRLint(FormatterContext):\n    \"\"\"This class provides the engine behind the XRLint\n    CLI application.\n    It represents the highest level component in the Python API.\n    \"\"\"\n\n    # noinspection PyShadowingBuiltins\n    def __init__(\n        self,\n        no_config_lookup: int = False,\n        config_path: str | None = None,\n        plugin_specs: tuple[str, ...] = (),\n        rule_specs: tuple[str, ...] = (),\n        output_format: str = DEFAULT_OUTPUT_FORMAT,\n        output_path: str | None = None,\n        output_styled: bool = True,\n        max_warnings: int = DEFAULT_MAX_WARNINGS,\n    ):\n        self.no_config_lookup = no_config_lookup\n        self.config_path = config_path\n        self.plugin_specs = plugin_specs\n        self.rule_specs = rule_specs\n        self.output_format = output_format\n        self.output_path = output_path\n        self.output_styled = output_styled\n        self.max_warnings = max_warnings\n        self._result_stats = ResultStats()\n        self.config_list = ConfigList()\n\n    @property\n    def max_warnings_exceeded(self) -&gt; bool:\n        \"\"\"`True` if the maximum number of warnings has been exceeded.\"\"\"\n        return self._result_stats.warning_count &gt; self.max_warnings\n\n    @property\n    def result_stats(self) -&gt; ResultStats:\n        \"\"\"Get current result statistics.\"\"\"\n        return self._result_stats\n\n    def load_config_list(self) -&gt; None:\n        \"\"\"Load configuration list.\n        The function considers any `plugin` and `rule`\n        options, the default configuration file names or a specified\n        configuration file.\n        \"\"\"\n        plugins = {}\n        for plugin_spec in self.plugin_specs:\n            plugin = Plugin.from_value(plugin_spec)\n            plugins[plugin.meta.name] = plugin\n\n        rules = {}\n        for rule_spec in self.rule_specs:\n            rule = yaml.load(rule_spec, Loader=yaml.SafeLoader)\n            rules.update(rule)\n\n        config_list = None\n\n        if self.config_path:\n            try:\n                config_list = read_config_list(self.config_path)\n            except (FileNotFoundError, ConfigError) as e:\n                raise click.ClickException(f\"{e}\") from e\n        elif not self.no_config_lookup:\n            for config_path in DEFAULT_CONFIG_FILES:\n                try:\n                    config_list = read_config_list(config_path)\n                    break\n                except FileNotFoundError:\n                    pass\n                except ConfigError as e:\n                    raise click.ClickException(f\"{e}\") from e\n\n        if config_list is None:\n            click.echo(\"Warning: no configuration file found.\")\n\n        core_config = get_core_config()\n        core_config.plugins.update(plugins)\n        configs = [core_config]\n        if config_list is not None:\n            configs += config_list.configs\n        if rules:\n            configs += [{\"rules\": rules}]\n\n        self.config_list = ConfigList.from_value(configs)\n\n    def get_config_for_file(self, file_path: str) -&gt; Config | None:\n        \"\"\"Compute configuration for the given file.\n\n        Args:\n            file_path: A file path.\n\n        Returns:\n            A configuration object or `None` if no item\n                in the configuration list applies.\n        \"\"\"\n        return self.config_list.compute_config(file_path)\n\n    def print_config_for_file(self, file_path: str) -&gt; None:\n        \"\"\"Print computed configuration for the given file.\n\n        Args:\n            file_path: A file path.\n        \"\"\"\n        config = self.get_config_for_file(file_path)\n        config_json_obj = config.to_json() if config is not None else None\n        click.echo(json.dumps(config_json_obj, indent=2))\n\n    def verify_datasets(self, files: Iterable[str]) -&gt; Iterator[Result]:\n        \"\"\"Verify given files.\n        The function produces a validation result for each file.\n\n        Args:\n            files: Iterable of files.\n\n        Returns:\n            Iterator of reports.\n        \"\"\"\n        global_filter = self.config_list.get_global_filter(\n            default=DEFAULT_GLOBAL_FILTER\n        )\n        linter = Linter()\n        for file_path, is_dir in get_files(files, global_filter):\n            config = self.get_config_for_file(file_path)\n            if config is not None:\n                yield linter.verify_dataset(file_path, config=config)\n            else:\n                yield Result.new(\n                    config=config,\n                    file_path=file_path,\n                    messages=[\n                        Message(\n                            message=\"No configuration matches this file.\",\n                            severity=2,\n                        )\n                    ],\n                )\n\n    def format_results(self, results: Iterable[Result]) -&gt; str:\n        \"\"\"Format the given results.\n\n        Args:\n            results: Iterable of results.\n\n        Returns:\n            A report in plain text.\n        \"\"\"\n        output_format = (\n            self.output_format if self.output_format else DEFAULT_OUTPUT_FORMAT\n        )\n        formatters = export_formatters()\n        formatter = formatters.get(output_format)\n        if formatter is None:\n            raise click.ClickException(\n                f\"unknown format {output_format!r}.\"\n                f\" The available formats are\"\n                f\" {', '.join(repr(k) for k in formatters.keys())}.\"\n            )\n        # TODO: pass and validate format-specific args/kwargs\n        #   against formatter.meta.schema\n        if output_format == \"simple\":\n            formatter_kwargs = {\n                \"styled\": self.output_styled and self.output_path is None,\n                \"output\": self.output_path is None,\n            }\n        else:\n            formatter_kwargs = {}\n        # noinspection PyArgumentList\n        formatter_op = formatter.op_class(**formatter_kwargs)\n        return formatter_op.format(self, self._result_stats.collect(results))\n\n    def write_report(self, report: str) -&gt; None:\n        \"\"\"Write the validation report provided as plain text.\"\"\"\n        if self.output_path:\n            with fsspec.open(self.output_path, mode=\"w\") as f:\n                f.write(report)\n        elif self.output_format != \"simple\":\n            # The simple formatters outputs incrementally to console\n            print(report)\n\n    @classmethod\n    def init_config_file(cls) -&gt; None:\n        \"\"\"Write an initial configuration file.\n        The file is written into the current working directory.\n        \"\"\"\n        file_path = DEFAULT_CONFIG_FILE_YAML\n        if os.path.exists(file_path):\n            raise click.ClickException(f\"file {file_path} already exists.\")\n        with open(file_path, \"w\") as f:\n            f.write(INIT_CONFIG_YAML)\n        click.echo(f\"Configuration template written to {file_path}\")\n</code></pre>"},{"location":"api/#xrlint.cli.engine.XRLint.max_warnings_exceeded","title":"<code>max_warnings_exceeded</code>  <code>property</code>","text":"<p><code>True</code> if the maximum number of warnings has been exceeded.</p>"},{"location":"api/#xrlint.cli.engine.XRLint.result_stats","title":"<code>result_stats</code>  <code>property</code>","text":"<p>Get current result statistics.</p>"},{"location":"api/#xrlint.cli.engine.XRLint.load_config_list","title":"<code>load_config_list()</code>","text":"<p>Load configuration list. The function considers any <code>plugin</code> and <code>rule</code> options, the default configuration file names or a specified configuration file.</p> Source code in <code>xrlint\\cli\\engine.py</code> <pre><code>def load_config_list(self) -&gt; None:\n    \"\"\"Load configuration list.\n    The function considers any `plugin` and `rule`\n    options, the default configuration file names or a specified\n    configuration file.\n    \"\"\"\n    plugins = {}\n    for plugin_spec in self.plugin_specs:\n        plugin = Plugin.from_value(plugin_spec)\n        plugins[plugin.meta.name] = plugin\n\n    rules = {}\n    for rule_spec in self.rule_specs:\n        rule = yaml.load(rule_spec, Loader=yaml.SafeLoader)\n        rules.update(rule)\n\n    config_list = None\n\n    if self.config_path:\n        try:\n            config_list = read_config_list(self.config_path)\n        except (FileNotFoundError, ConfigError) as e:\n            raise click.ClickException(f\"{e}\") from e\n    elif not self.no_config_lookup:\n        for config_path in DEFAULT_CONFIG_FILES:\n            try:\n                config_list = read_config_list(config_path)\n                break\n            except FileNotFoundError:\n                pass\n            except ConfigError as e:\n                raise click.ClickException(f\"{e}\") from e\n\n    if config_list is None:\n        click.echo(\"Warning: no configuration file found.\")\n\n    core_config = get_core_config()\n    core_config.plugins.update(plugins)\n    configs = [core_config]\n    if config_list is not None:\n        configs += config_list.configs\n    if rules:\n        configs += [{\"rules\": rules}]\n\n    self.config_list = ConfigList.from_value(configs)\n</code></pre>"},{"location":"api/#xrlint.cli.engine.XRLint.get_config_for_file","title":"<code>get_config_for_file(file_path)</code>","text":"<p>Compute configuration for the given file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>A file path.</p> required <p>Returns:</p> Type Description <code>Config | None</code> <p>A configuration object or <code>None</code> if no item in the configuration list applies.</p> Source code in <code>xrlint\\cli\\engine.py</code> <pre><code>def get_config_for_file(self, file_path: str) -&gt; Config | None:\n    \"\"\"Compute configuration for the given file.\n\n    Args:\n        file_path: A file path.\n\n    Returns:\n        A configuration object or `None` if no item\n            in the configuration list applies.\n    \"\"\"\n    return self.config_list.compute_config(file_path)\n</code></pre>"},{"location":"api/#xrlint.cli.engine.XRLint.print_config_for_file","title":"<code>print_config_for_file(file_path)</code>","text":"<p>Print computed configuration for the given file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>A file path.</p> required Source code in <code>xrlint\\cli\\engine.py</code> <pre><code>def print_config_for_file(self, file_path: str) -&gt; None:\n    \"\"\"Print computed configuration for the given file.\n\n    Args:\n        file_path: A file path.\n    \"\"\"\n    config = self.get_config_for_file(file_path)\n    config_json_obj = config.to_json() if config is not None else None\n    click.echo(json.dumps(config_json_obj, indent=2))\n</code></pre>"},{"location":"api/#xrlint.cli.engine.XRLint.verify_datasets","title":"<code>verify_datasets(files)</code>","text":"<p>Verify given files. The function produces a validation result for each file.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>Iterable[str]</code> <p>Iterable of files.</p> required <p>Returns:</p> Type Description <code>Iterator[Result]</code> <p>Iterator of reports.</p> Source code in <code>xrlint\\cli\\engine.py</code> <pre><code>def verify_datasets(self, files: Iterable[str]) -&gt; Iterator[Result]:\n    \"\"\"Verify given files.\n    The function produces a validation result for each file.\n\n    Args:\n        files: Iterable of files.\n\n    Returns:\n        Iterator of reports.\n    \"\"\"\n    global_filter = self.config_list.get_global_filter(\n        default=DEFAULT_GLOBAL_FILTER\n    )\n    linter = Linter()\n    for file_path, is_dir in get_files(files, global_filter):\n        config = self.get_config_for_file(file_path)\n        if config is not None:\n            yield linter.verify_dataset(file_path, config=config)\n        else:\n            yield Result.new(\n                config=config,\n                file_path=file_path,\n                messages=[\n                    Message(\n                        message=\"No configuration matches this file.\",\n                        severity=2,\n                    )\n                ],\n            )\n</code></pre>"},{"location":"api/#xrlint.cli.engine.XRLint.format_results","title":"<code>format_results(results)</code>","text":"<p>Format the given results.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>Iterable[Result]</code> <p>Iterable of results.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A report in plain text.</p> Source code in <code>xrlint\\cli\\engine.py</code> <pre><code>def format_results(self, results: Iterable[Result]) -&gt; str:\n    \"\"\"Format the given results.\n\n    Args:\n        results: Iterable of results.\n\n    Returns:\n        A report in plain text.\n    \"\"\"\n    output_format = (\n        self.output_format if self.output_format else DEFAULT_OUTPUT_FORMAT\n    )\n    formatters = export_formatters()\n    formatter = formatters.get(output_format)\n    if formatter is None:\n        raise click.ClickException(\n            f\"unknown format {output_format!r}.\"\n            f\" The available formats are\"\n            f\" {', '.join(repr(k) for k in formatters.keys())}.\"\n        )\n    # TODO: pass and validate format-specific args/kwargs\n    #   against formatter.meta.schema\n    if output_format == \"simple\":\n        formatter_kwargs = {\n            \"styled\": self.output_styled and self.output_path is None,\n            \"output\": self.output_path is None,\n        }\n    else:\n        formatter_kwargs = {}\n    # noinspection PyArgumentList\n    formatter_op = formatter.op_class(**formatter_kwargs)\n    return formatter_op.format(self, self._result_stats.collect(results))\n</code></pre>"},{"location":"api/#xrlint.cli.engine.XRLint.write_report","title":"<code>write_report(report)</code>","text":"<p>Write the validation report provided as plain text.</p> Source code in <code>xrlint\\cli\\engine.py</code> <pre><code>def write_report(self, report: str) -&gt; None:\n    \"\"\"Write the validation report provided as plain text.\"\"\"\n    if self.output_path:\n        with fsspec.open(self.output_path, mode=\"w\") as f:\n            f.write(report)\n    elif self.output_format != \"simple\":\n        # The simple formatters outputs incrementally to console\n        print(report)\n</code></pre>"},{"location":"api/#xrlint.cli.engine.XRLint.init_config_file","title":"<code>init_config_file()</code>  <code>classmethod</code>","text":"<p>Write an initial configuration file. The file is written into the current working directory.</p> Source code in <code>xrlint\\cli\\engine.py</code> <pre><code>@classmethod\ndef init_config_file(cls) -&gt; None:\n    \"\"\"Write an initial configuration file.\n    The file is written into the current working directory.\n    \"\"\"\n    file_path = DEFAULT_CONFIG_FILE_YAML\n    if os.path.exists(file_path):\n        raise click.ClickException(f\"file {file_path} already exists.\")\n    with open(file_path, \"w\") as f:\n        f.write(INIT_CONFIG_YAML)\n    click.echo(f\"Configuration template written to {file_path}\")\n</code></pre>"},{"location":"api/#xrlint.linter.new_linter","title":"<code>xrlint.linter.new_linter(config_name=None, *, config=None, **config_kwargs)</code>","text":"<p>Create a new <code>Linter</code> with the given configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config_name</code> <code>Literal['all', 'recommended'] | None</code> <p><code>\"recommended\"</code> if the recommended configuration of the builtin rules should be used, or <code>\"all\"</code> if all rules shall be used. Pass <code>None</code> (the default) if you don't want this. In the latter case, you should configure the <code>rules</code> option either in <code>config</code> or <code>config_kwargs</code>. Otherwise, calling <code>verify_dataset()</code> without any rule configuration will never succeed for any given dataset.</p> <code>None</code> <code>config</code> <code>Config | dict | None</code> <p>The <code>config</code> keyword argument passed to the <code>Linter</code> class</p> <code>None</code> <code>config_kwargs</code> <code>dict[str, Any]</code> <p>The <code>config_kwargs</code> keyword arguments passed to the <code>Linter</code> class</p> <code>{}</code> <p>Returns:</p> Type Description <code>Linter</code> <p>A new linter instance</p> Source code in <code>xrlint\\linter.py</code> <pre><code>def new_linter(\n    config_name: Literal[\"all\", \"recommended\"] | None = None,\n    *,\n    config: Config | dict | None = None,\n    **config_kwargs: dict[str, Any],\n) -&gt; \"Linter\":\n    \"\"\"Create a new `Linter` with the given configuration.\n\n    Args:\n        config_name: `\"recommended\"` if the recommended configuration\n            of the builtin rules should be used, or `\"all\"` if all rules\n            shall be used. Pass `None` (the default) if you don't want this.\n            In the latter case, you should configure the `rules`\n            option either in `config` or `config_kwargs`. Otherwise, calling\n            `verify_dataset()` without any rule configuration will never\n            succeed for any given dataset.\n        config: The `config` keyword argument passed to the `Linter` class\n        config_kwargs: The `config_kwargs` keyword arguments passed to\n            the `Linter` class\n\n    Returns:\n        A new linter instance\n    \"\"\"\n    return Linter(\n        config=merge_configs(get_core_config(config_name=config_name), config),\n        **config_kwargs,\n    )\n</code></pre>"},{"location":"api/#xrlint.linter.Linter","title":"<code>xrlint.linter.Linter</code>","text":"<p>The linter.</p> <p>Using the constructor directly creates an empty linter with no configuration - even without default rules loaded. If you want a linter with core rules loaded use the <code>new_linter()</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config | dict[str, Any] | None</code> <p>The linter's configuration.</p> <code>None</code> <code>config_kwargs</code> <code>dict[str, Any]</code> <p>Individual linter configuration options. All options of the <code>Config</code> object are possible. If <code>config</code> is given too, provided given individual linter configuration options merged the ones given in <code>config</code>.</p> <code>{}</code> Source code in <code>xrlint\\linter.py</code> <pre><code>class Linter:\n    \"\"\"The linter.\n\n    Using the constructor directly creates an empty linter\n    with no configuration - even without default rules loaded.\n    If you want a linter with core rules loaded\n    use the `new_linter()` function.\n\n    Args:\n        config: The linter's configuration.\n        config_kwargs: Individual linter configuration options.\n            All options of the `Config` object are possible.\n            If `config` is given too, provided\n            given individual linter configuration options\n            merged the ones given in `config`.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: Config | dict[str, Any] | None = None,\n        **config_kwargs: dict[str, Any],\n    ):\n        self._config = merge_configs(config, config_kwargs)\n\n    @property\n    def config(self) -&gt; Config:\n        \"\"\"Get this linter's configuration.\"\"\"\n        return self._config\n\n    def verify_dataset(\n        self,\n        dataset: Any,\n        *,\n        file_path: str | None = None,\n        config: Config | dict[str, Any] | None = None,\n        **config_kwargs: dict[str, Any],\n    ) -&gt; Result:\n        \"\"\"Verify a dataset.\n\n        Args:\n            dataset: The dataset. Can be a `xr.Dataset` instance\n                or a file path, or any dataset source that can be opened\n                using `xarray.open_dataset()`.\n            file_path: Optional file path used for formatting\n                messages. Useful if `dataset` is not a file path.\n            config: Configuration tbe merged with the linter's\n                configuration.\n            config_kwargs: Individual linter configuration options\n                to be merged with `config` if any. The merged result\n                will be merged with the linter's configuration.\n\n        Returns:\n            Result of the verification.\n        \"\"\"\n        config = merge_configs(self._config, config)\n        config = merge_configs(config, config_kwargs)\n        return verify_dataset(config, dataset, file_path)\n</code></pre>"},{"location":"api/#xrlint.linter.Linter.config","title":"<code>config</code>  <code>property</code>","text":"<p>Get this linter's configuration.</p>"},{"location":"api/#xrlint.linter.Linter.verify_dataset","title":"<code>verify_dataset(dataset, *, file_path=None, config=None, **config_kwargs)</code>","text":"<p>Verify a dataset.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>Any</code> <p>The dataset. Can be a <code>xr.Dataset</code> instance or a file path, or any dataset source that can be opened using <code>xarray.open_dataset()</code>.</p> required <code>file_path</code> <code>str | None</code> <p>Optional file path used for formatting messages. Useful if <code>dataset</code> is not a file path.</p> <code>None</code> <code>config</code> <code>Config | dict[str, Any] | None</code> <p>Configuration tbe merged with the linter's configuration.</p> <code>None</code> <code>config_kwargs</code> <code>dict[str, Any]</code> <p>Individual linter configuration options to be merged with <code>config</code> if any. The merged result will be merged with the linter's configuration.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result</code> <p>Result of the verification.</p> Source code in <code>xrlint\\linter.py</code> <pre><code>def verify_dataset(\n    self,\n    dataset: Any,\n    *,\n    file_path: str | None = None,\n    config: Config | dict[str, Any] | None = None,\n    **config_kwargs: dict[str, Any],\n) -&gt; Result:\n    \"\"\"Verify a dataset.\n\n    Args:\n        dataset: The dataset. Can be a `xr.Dataset` instance\n            or a file path, or any dataset source that can be opened\n            using `xarray.open_dataset()`.\n        file_path: Optional file path used for formatting\n            messages. Useful if `dataset` is not a file path.\n        config: Configuration tbe merged with the linter's\n            configuration.\n        config_kwargs: Individual linter configuration options\n            to be merged with `config` if any. The merged result\n            will be merged with the linter's configuration.\n\n    Returns:\n        Result of the verification.\n    \"\"\"\n    config = merge_configs(self._config, config)\n    config = merge_configs(config, config_kwargs)\n    return verify_dataset(config, dataset, file_path)\n</code></pre>"},{"location":"api/#xrlint.config.Config","title":"<code>xrlint.config.Config</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MappingConstructible</code>, <code>JsonSerializable</code></p> <p>Configuration object. A configuration object contains all the information XRLint needs to execute on a set of dataset files.</p> <p>You should not use the class constructor directly. Instead, use the <code>Config.from_value()</code> function.</p> Source code in <code>xrlint\\config.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass Config(MappingConstructible, JsonSerializable):\n    \"\"\"Configuration object.\n    A configuration object contains all the information XRLint\n    needs to execute on a set of dataset files.\n\n    You should not use the class constructor directly.\n    Instead, use the `Config.from_value()` function.\n    \"\"\"\n\n    name: str | None = None\n    \"\"\"A name for the configuration object.\n    This is used in error messages and config inspector to help identify\n    which configuration object is being used.\n    \"\"\"\n\n    files: list[str] | None = None\n    \"\"\"An array of glob patterns indicating the files that the\n    configuration object should apply to. If not specified,\n    the configuration object applies to all files matched\n    by any other configuration object.\n\n    When a configuration object contains only the files property\n    without accompanying rules or settings, it effectively acts as\n    a _global file filter_. This means that XRLint will recognize\n    and process only the files matching these patterns, thereby\n    limiting its scope to the specified files. The inbuilt\n    global file filters are `[\"**/*.zarr\", \"**/*.nc\"]`.\n    \"\"\"\n\n    ignores: list[str] | None = None\n    \"\"\"An array of glob patterns indicating the files that the\n    configuration object should not apply to. If not specified,\n    the configuration object applies to all files matched by `files`.\n    If `ignores` is used without any other keys in the configuration\n    object, then the patterns act as _global ignores_.\n    \"\"\"\n\n    linter_options: dict[str, Any] | None = None\n    \"\"\"A dictionary containing options related to the linting process.\"\"\"\n\n    opener_options: dict[str, Any] | None = None\n    \"\"\"A dictionary containing options that are passed to\n    the dataset opener.\n    \"\"\"\n\n    processor: Union[\"ProcessorOp\", str, None] = None\n    \"\"\"Either an object compatible with the `ProcessorOp`\n    interface or a string indicating the name of a processor inside\n    of a plugin (i.e., `\"pluginName/processorName\"`).\n    \"\"\"\n\n    plugins: dict[str, \"Plugin\"] | None = None\n    \"\"\"A dictionary containing a name-value mapping of plugin names to\n    plugin objects. When `files` is specified, these plugins are only\n    available to the matching files.\n    \"\"\"\n\n    rules: dict[str, \"RuleConfig\"] | None = None\n    \"\"\"A dictionary containing the configured rules.\n    When `files` or `ignores` are specified, these rule configurations\n    are only available to the matching files.\n    \"\"\"\n\n    settings: dict[str, Any] | None = None\n    \"\"\"A dictionary containing name-value pairs of information\n    that should be available to all rules.\n    \"\"\"\n\n    @cached_property\n    def file_filter(self) -&gt; FileFilter:\n        \"\"\"The file filter specified by this configuration. May be empty.\"\"\"\n        return FileFilter.from_patterns(self.files, self.ignores)\n\n    @cached_property\n    def empty(self) -&gt; bool:\n        \"\"\"`True` if this configuration object does not configure anything.\n        Note, it could still contribute to a global file filter if its\n        `files` and `ignores` options are set.\"\"\"\n        return not (\n            self.linter_options\n            or self.opener_options\n            or self.plugins\n            or self.rules\n            or self.settings\n        )\n\n    def get_plugin(self, plugin_name: str) -&gt; \"Plugin\":\n        \"\"\"Get the plugin for given plugin name `plugin_name`.\"\"\"\n        plugin = (self.plugins or {}).get(plugin_name)\n        if plugin is None:\n            raise ValueError(f\"unknown plugin {plugin_name!r}\")\n        return plugin\n\n    def get_rule(self, rule_id: str) -&gt; \"Rule\":\n        \"\"\"Get the rule for the given rule identifier `rule_id`.\n\n        Args:\n            rule_id: The rule identifier including plugin namespace,\n                if any. Format `&lt;rule-name&gt;` (builtin rules) or\n                `&lt;plugin-name&gt;/&lt;rule-name&gt;`.\n\n        Returns:\n            A `Rule` object.\n\n        Raises:\n            ValueError: If either the plugin is unknown in this\n                configuration or the rule name is unknown.\n        \"\"\"\n        plugin_name, rule_name = split_config_spec(rule_id)\n        plugin = self.get_plugin(plugin_name)\n        rule = (plugin.rules or {}).get(rule_name)\n        if rule is None:\n            raise ValueError(f\"unknown rule {rule_id!r}\")\n        return rule\n\n    def get_processor_op(\n        self, processor_spec: Union[\"ProcessorOp\", str]\n    ) -&gt; \"ProcessorOp\":\n        \"\"\"Get the processor operation for the given\n        processor identifier `processor_spec`.\n        \"\"\"\n        from xrlint.processor import Processor\n        from xrlint.processor import ProcessorOp\n\n        if isinstance(processor_spec, ProcessorOp):\n            return processor_spec\n\n        plugin_name, processor_name = split_config_spec(processor_spec)\n        plugin = self.get_plugin(plugin_name)\n        processor: Processor | None = (plugin.processors or {}).get(processor_name)\n        if processor is None:\n            raise ValueError(f\"unknown processor {processor_spec!r}\")\n        return processor.op_class()\n\n    def merge(self, config: \"Config\", name: str = None) -&gt; \"Config\":\n        return Config(\n            name=name,\n            files=self._merge_pattern_lists(self.files, config.files),\n            ignores=self._merge_pattern_lists(self.ignores, config.ignores),\n            linter_options=self._merge_options(\n                self.linter_options, config.linter_options\n            ),\n            opener_options=self._merge_options(\n                self.opener_options, config.opener_options\n            ),\n            processor=merge_values(self.processor, config.processor),\n            plugins=self._merge_plugin_dicts(self.plugins, config.plugins),\n            rules=self._merge_rule_dicts(self.rules, config.rules),\n            settings=self._merge_options(self.settings, config.settings),\n        )\n\n    @classmethod\n    def _merge_rule_dicts(\n        cls,\n        rules1: dict[str, \"RuleConfig\"] | None,\n        rules2: dict[str, \"RuleConfig\"] | None,\n    ) -&gt; dict[str, \"RuleConfig\"] | None:\n        from xrlint.rule import RuleConfig\n\n        def merge_items(r1: RuleConfig, r2: RuleConfig) -&gt; RuleConfig:\n            if r1.severity == r2.severity:\n                return RuleConfig(\n                    r2.severity,\n                    merge_arrays(r1.args, r2.args),\n                    merge_dicts(r1.kwargs, r2.kwargs),\n                )\n            return r2\n\n        return merge_dicts(rules1, rules2, merge_items=merge_items)\n\n    @classmethod\n    def _merge_pattern_lists(\n        cls, patterns1: list[str] | None, patterns2: list[str] | None\n    ) -&gt; list[str] | None:\n        return merge_set_lists(patterns1, patterns2)\n\n    @classmethod\n    def _merge_options(\n        cls, settings1: dict[str, Any] | None, settings2: dict[str, Any] | None\n    ) -&gt; dict[str, Any] | None:\n        return merge_dicts(settings1, settings2, merge_items=merge_values)\n\n    @classmethod\n    def _merge_plugin_dicts(\n        cls,\n        plugins1: dict[str, \"Plugin\"] | None,\n        plugins2: dict[str, \"Plugin\"] | None,\n    ) -&gt; dict[str, \"RuleConfig\"] | None:\n        from xrlint.plugin import Plugin\n\n        def merge_items(_p1: Plugin, p2: Plugin) -&gt; Plugin:\n            return p2\n\n        return merge_dicts(plugins1, plugins2, merge_items=merge_items)\n\n    @classmethod\n    def _from_none(cls, value_name: str) -&gt; \"Config\":\n        return Config()\n\n    @classmethod\n    def _get_forward_refs(cls) -&gt; dict[str, type]:\n        from xrlint.processor import ProcessorOp\n        from xrlint.plugin import Plugin\n        from xrlint.rule import Rule\n        from xrlint.rule import RuleConfig\n\n        return {\n            \"ProcessorOp\": ProcessorOp,\n            \"Plugin\": Plugin,\n            \"Rule\": Rule,\n            \"RuleConfig\": RuleConfig,\n        }\n\n    @classmethod\n    def _get_value_name(cls) -&gt; str:\n        return \"config\"\n\n    @classmethod\n    def _get_value_type_name(cls) -&gt; str:\n        return \"Config | dict | None\"\n\n    def to_dict(self, value_name: str | None = None) -&gt; dict[str, JsonValue]:\n        return {k: v for k, v in super().to_dict().items() if v is not None}\n</code></pre>"},{"location":"api/#xrlint.config.Config.name","title":"<code>name = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A name for the configuration object. This is used in error messages and config inspector to help identify which configuration object is being used.</p>"},{"location":"api/#xrlint.config.Config.files","title":"<code>files = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An array of glob patterns indicating the files that the configuration object should apply to. If not specified, the configuration object applies to all files matched by any other configuration object.</p> <p>When a configuration object contains only the files property without accompanying rules or settings, it effectively acts as a global file filter. This means that XRLint will recognize and process only the files matching these patterns, thereby limiting its scope to the specified files. The inbuilt global file filters are <code>[\"**/*.zarr\", \"**/*.nc\"]</code>.</p>"},{"location":"api/#xrlint.config.Config.ignores","title":"<code>ignores = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An array of glob patterns indicating the files that the configuration object should not apply to. If not specified, the configuration object applies to all files matched by <code>files</code>. If <code>ignores</code> is used without any other keys in the configuration object, then the patterns act as global ignores.</p>"},{"location":"api/#xrlint.config.Config.linter_options","title":"<code>linter_options = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary containing options related to the linting process.</p>"},{"location":"api/#xrlint.config.Config.opener_options","title":"<code>opener_options = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary containing options that are passed to the dataset opener.</p>"},{"location":"api/#xrlint.config.Config.processor","title":"<code>processor = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Either an object compatible with the <code>ProcessorOp</code> interface or a string indicating the name of a processor inside of a plugin (i.e., <code>\"pluginName/processorName\"</code>).</p>"},{"location":"api/#xrlint.config.Config.plugins","title":"<code>plugins = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary containing a name-value mapping of plugin names to plugin objects. When <code>files</code> is specified, these plugins are only available to the matching files.</p>"},{"location":"api/#xrlint.config.Config.rules","title":"<code>rules = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary containing the configured rules. When <code>files</code> or <code>ignores</code> are specified, these rule configurations are only available to the matching files.</p>"},{"location":"api/#xrlint.config.Config.settings","title":"<code>settings = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary containing name-value pairs of information that should be available to all rules.</p>"},{"location":"api/#xrlint.config.Config.file_filter","title":"<code>file_filter</code>  <code>cached</code> <code>property</code>","text":"<p>The file filter specified by this configuration. May be empty.</p>"},{"location":"api/#xrlint.config.Config.empty","title":"<code>empty</code>  <code>cached</code> <code>property</code>","text":"<p><code>True</code> if this configuration object does not configure anything. Note, it could still contribute to a global file filter if its <code>files</code> and <code>ignores</code> options are set.</p>"},{"location":"api/#xrlint.config.Config.get_plugin","title":"<code>get_plugin(plugin_name)</code>","text":"<p>Get the plugin for given plugin name <code>plugin_name</code>.</p> Source code in <code>xrlint\\config.py</code> <pre><code>def get_plugin(self, plugin_name: str) -&gt; \"Plugin\":\n    \"\"\"Get the plugin for given plugin name `plugin_name`.\"\"\"\n    plugin = (self.plugins or {}).get(plugin_name)\n    if plugin is None:\n        raise ValueError(f\"unknown plugin {plugin_name!r}\")\n    return plugin\n</code></pre>"},{"location":"api/#xrlint.config.Config.get_rule","title":"<code>get_rule(rule_id)</code>","text":"<p>Get the rule for the given rule identifier <code>rule_id</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rule_id</code> <code>str</code> <p>The rule identifier including plugin namespace, if any. Format <code>&lt;rule-name&gt;</code> (builtin rules) or <code>&lt;plugin-name&gt;/&lt;rule-name&gt;</code>.</p> required <p>Returns:</p> Type Description <code>Rule</code> <p>A <code>Rule</code> object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If either the plugin is unknown in this configuration or the rule name is unknown.</p> Source code in <code>xrlint\\config.py</code> <pre><code>def get_rule(self, rule_id: str) -&gt; \"Rule\":\n    \"\"\"Get the rule for the given rule identifier `rule_id`.\n\n    Args:\n        rule_id: The rule identifier including plugin namespace,\n            if any. Format `&lt;rule-name&gt;` (builtin rules) or\n            `&lt;plugin-name&gt;/&lt;rule-name&gt;`.\n\n    Returns:\n        A `Rule` object.\n\n    Raises:\n        ValueError: If either the plugin is unknown in this\n            configuration or the rule name is unknown.\n    \"\"\"\n    plugin_name, rule_name = split_config_spec(rule_id)\n    plugin = self.get_plugin(plugin_name)\n    rule = (plugin.rules or {}).get(rule_name)\n    if rule is None:\n        raise ValueError(f\"unknown rule {rule_id!r}\")\n    return rule\n</code></pre>"},{"location":"api/#xrlint.config.Config.get_processor_op","title":"<code>get_processor_op(processor_spec)</code>","text":"<p>Get the processor operation for the given processor identifier <code>processor_spec</code>.</p> Source code in <code>xrlint\\config.py</code> <pre><code>def get_processor_op(\n    self, processor_spec: Union[\"ProcessorOp\", str]\n) -&gt; \"ProcessorOp\":\n    \"\"\"Get the processor operation for the given\n    processor identifier `processor_spec`.\n    \"\"\"\n    from xrlint.processor import Processor\n    from xrlint.processor import ProcessorOp\n\n    if isinstance(processor_spec, ProcessorOp):\n        return processor_spec\n\n    plugin_name, processor_name = split_config_spec(processor_spec)\n    plugin = self.get_plugin(plugin_name)\n    processor: Processor | None = (plugin.processors or {}).get(processor_name)\n    if processor is None:\n        raise ValueError(f\"unknown processor {processor_spec!r}\")\n    return processor.op_class()\n</code></pre>"},{"location":"api/#xrlint.config.ConfigList","title":"<code>xrlint.config.ConfigList</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ValueConstructible</code>, <code>JsonSerializable</code></p> <p>A holder for a list of configuration objects of type Config.</p> <p>You should not use the class constructor directly. Instead, use the <code>ConfigList.from_value()</code> function.</p> Source code in <code>xrlint\\config.py</code> <pre><code>@dataclass(frozen=True)\nclass ConfigList(ValueConstructible, JsonSerializable):\n    \"\"\"A holder for a list of configuration objects of\n    type [Config][xrlint.config.Config].\n\n    You should not use the class constructor directly.\n    Instead, use the `ConfigList.from_value()` function.\n    \"\"\"\n\n    configs: list[Config] = field(default_factory=list)\n    \"\"\"The list of configuration objects.\"\"\"\n\n    def get_global_filter(self, default: FileFilter | None = None) -&gt; FileFilter:\n        \"\"\"Get a global file filter for this configuration list.\"\"\"\n        global_filter = FileFilter(\n            default.files if default else (),\n            default.ignores if default else (),\n        )\n        for c in self.configs:\n            if c.empty and not c.file_filter.empty:\n                global_filter = global_filter.merge(c.file_filter)\n        return global_filter\n\n    def compute_config(self, file_path: str) -&gt; Config | None:\n        \"\"\"Compute the configuration object for the given file path.\n\n        Args:\n            file_path: A dataset file path.\n\n        Returns:\n            A `Config` object which may be empty, or `None`\n                if `file_path` is not included by any `files` pattern\n                or intentionally ignored by global `ignores`.\n        \"\"\"\n\n        config = None\n        for c in self.configs:\n            if c.file_filter.empty or c.file_filter.accept(file_path):\n                config = config.merge(c) if config is not None else c\n\n        if config is None:\n            return None\n\n        # Note, computed configurations do not have \"files\" and \"ignores\"\n        return Config(\n            name=\"&lt;computed&gt;\",\n            linter_options=config.linter_options,\n            opener_options=config.opener_options,\n            processor=config.processor,\n            plugins=config.plugins,\n            rules=config.rules,\n            settings=config.settings,\n        )\n\n    @classmethod\n    def from_value(cls, value: Any, value_name: str | None = None) -&gt; \"ConfigList\":\n        \"\"\"Convert given `value` into a `ConfigList` object.\n\n        If `value` is already a `ConfigList` then it is returned as-is.\n\n        Args:\n            value: A `ConfigList` object or `list` of items which can be\n                converted into `Config` objects including configuration\n                names of tyype `str`. The latter are resolved against\n                the plugin configurations seen so far in the list.\n            value_name: A value's name.\n        Returns:\n            A `ConfigList` object.\n        \"\"\"\n        return super().from_value(value, value_name=value_name)\n\n    @classmethod\n    def _from_sequence(cls, value: Sequence, value_name: str) -&gt; \"ConfigList\":\n        configs: list[Config] = []\n        plugins: dict[str, Plugin] = {}\n        for item in value:\n            if isinstance(item, str):\n                if CORE_PLUGIN_NAME not in plugins:\n                    plugins.update({CORE_PLUGIN_NAME: get_core_plugin()})\n                config = cls._get_named_config(item, plugins)\n            else:\n                config = Config.from_value(item)\n            configs.append(config)\n            plugins.update(config.plugins if config.plugins else {})\n        return ConfigList(configs)\n\n    @classmethod\n    def _get_value_name(cls) -&gt; str:\n        return \"config_list\"\n\n    @classmethod\n    def _get_value_type_name(cls) -&gt; str:\n        return \"ConfigList | list[Config | dict]\"\n\n    @classmethod\n    def _get_named_config(cls, config_spec: str, plugins: dict[str, \"Plugin\"]):\n        plugin_name, config_name = (\n            config_spec.split(\"/\", maxsplit=1)\n            if \"/\" in config_spec\n            else (CORE_PLUGIN_NAME, config_spec)\n        )\n        plugin: Plugin | None = plugins.get(plugin_name)\n        if plugin is None or not plugin.configs or config_name not in plugin.configs:\n            raise ValueError(f\"configuration {config_spec!r} not found\")\n        config_value = plugin.configs[config_name]\n        return config_value\n</code></pre>"},{"location":"api/#xrlint.config.ConfigList.configs","title":"<code>configs = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The list of configuration objects.</p>"},{"location":"api/#xrlint.config.ConfigList.get_global_filter","title":"<code>get_global_filter(default=None)</code>","text":"<p>Get a global file filter for this configuration list.</p> Source code in <code>xrlint\\config.py</code> <pre><code>def get_global_filter(self, default: FileFilter | None = None) -&gt; FileFilter:\n    \"\"\"Get a global file filter for this configuration list.\"\"\"\n    global_filter = FileFilter(\n        default.files if default else (),\n        default.ignores if default else (),\n    )\n    for c in self.configs:\n        if c.empty and not c.file_filter.empty:\n            global_filter = global_filter.merge(c.file_filter)\n    return global_filter\n</code></pre>"},{"location":"api/#xrlint.config.ConfigList.compute_config","title":"<code>compute_config(file_path)</code>","text":"<p>Compute the configuration object for the given file path.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>A dataset file path.</p> required <p>Returns:</p> Type Description <code>Config | None</code> <p>A <code>Config</code> object which may be empty, or <code>None</code> if <code>file_path</code> is not included by any <code>files</code> pattern or intentionally ignored by global <code>ignores</code>.</p> Source code in <code>xrlint\\config.py</code> <pre><code>def compute_config(self, file_path: str) -&gt; Config | None:\n    \"\"\"Compute the configuration object for the given file path.\n\n    Args:\n        file_path: A dataset file path.\n\n    Returns:\n        A `Config` object which may be empty, or `None`\n            if `file_path` is not included by any `files` pattern\n            or intentionally ignored by global `ignores`.\n    \"\"\"\n\n    config = None\n    for c in self.configs:\n        if c.file_filter.empty or c.file_filter.accept(file_path):\n            config = config.merge(c) if config is not None else c\n\n    if config is None:\n        return None\n\n    # Note, computed configurations do not have \"files\" and \"ignores\"\n    return Config(\n        name=\"&lt;computed&gt;\",\n        linter_options=config.linter_options,\n        opener_options=config.opener_options,\n        processor=config.processor,\n        plugins=config.plugins,\n        rules=config.rules,\n        settings=config.settings,\n    )\n</code></pre>"},{"location":"api/#xrlint.config.ConfigList.from_value","title":"<code>from_value(value, value_name=None)</code>  <code>classmethod</code>","text":"<p>Convert given <code>value</code> into a <code>ConfigList</code> object.</p> <p>If <code>value</code> is already a <code>ConfigList</code> then it is returned as-is.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>A <code>ConfigList</code> object or <code>list</code> of items which can be converted into <code>Config</code> objects including configuration names of tyype <code>str</code>. The latter are resolved against the plugin configurations seen so far in the list.</p> required <code>value_name</code> <code>str | None</code> <p>A value's name.</p> <code>None</code> <p>Returns:     A <code>ConfigList</code> object.</p> Source code in <code>xrlint\\config.py</code> <pre><code>@classmethod\ndef from_value(cls, value: Any, value_name: str | None = None) -&gt; \"ConfigList\":\n    \"\"\"Convert given `value` into a `ConfigList` object.\n\n    If `value` is already a `ConfigList` then it is returned as-is.\n\n    Args:\n        value: A `ConfigList` object or `list` of items which can be\n            converted into `Config` objects including configuration\n            names of tyype `str`. The latter are resolved against\n            the plugin configurations seen so far in the list.\n        value_name: A value's name.\n    Returns:\n        A `ConfigList` object.\n    \"\"\"\n    return super().from_value(value, value_name=value_name)\n</code></pre>"},{"location":"api/#xrlint.rule.define_rule","title":"<code>xrlint.rule.define_rule(name=None, version='0.0.0', schema=None, type=None, description=None, docs_url=None, registry=None, op_class=None)</code>","text":"<p>Define a rule.</p> <p>This function can be used to decorate your rule operation class definitions. When used as a decorator, the decorated operator class will receive a <code>meta</code> attribute of type RuleMeta. In addition, the <code>registry</code> if given, will be updated using <code>name</code> as key and a new Rule as value.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Rule name, see RuleMeta.</p> <code>None</code> <code>version</code> <code>str</code> <p>Rule version, see RuleMeta.</p> <code>'0.0.0'</code> <code>schema</code> <code>dict[str, Any] | list[dict[str, Any]] | bool | None</code> <p>Rule operation arguments schema, see RuleMeta.</p> <code>None</code> <code>type</code> <code>Literal['problem', 'suggestion', 'layout'] | None</code> <p>Rule type, see RuleMeta.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Rule description, see RuleMeta.</p> <code>None</code> <code>docs_url</code> <code>str | None</code> <p>Rule documentation URL, see RuleMeta.</p> <code>None</code> <code>registry</code> <code>MutableMapping[str, Rule] | None</code> <p>Rule registry. Can be provided to register the defined rule using its <code>name</code>.</p> <code>None</code> <code>op_class</code> <code>Type[RuleOp] | None</code> <p>Rule operation class. Must not be provided if this function is used as a class decorator.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[Any], Type[RuleOp]] | Rule</code> <p>A decorator function, if <code>op_class</code> is <code>None</code> otherwise the value of <code>op_class</code>.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If either <code>op_class</code> or the decorated object is not a class derived from RuleOp.</p> Source code in <code>xrlint\\rule.py</code> <pre><code>def define_rule(\n    name: str | None = None,\n    version: str = \"0.0.0\",\n    schema: dict[str, Any] | list[dict[str, Any]] | bool | None = None,\n    type: Literal[\"problem\", \"suggestion\", \"layout\"] | None = None,\n    description: str | None = None,\n    docs_url: str | None = None,\n    registry: MutableMapping[str, Rule] | None = None,\n    op_class: Type[RuleOp] | None = None,\n) -&gt; Callable[[Any], Type[RuleOp]] | Rule:\n    \"\"\"Define a rule.\n\n    This function can be used to decorate your rule operation class\n    definitions. When used as a decorator, the decorated operator class\n    will receive a `meta` attribute of type [RuleMeta][xrlint.rule.RuleMeta].\n    In addition, the `registry` if given, will be updated using `name`\n    as key and a new [Rule][xrlint.rule.Rule] as value.\n\n    Args:\n        name: Rule name, see [RuleMeta][xrlint.rule.RuleMeta].\n        version: Rule version, see [RuleMeta][xrlint.rule.RuleMeta].\n        schema: Rule operation arguments schema,\n            see [RuleMeta][xrlint.rule.RuleMeta].\n        type: Rule type, see [RuleMeta][xrlint.rule.RuleMeta].\n        description: Rule description,\n            see [RuleMeta][xrlint.rule.RuleMeta].\n        docs_url: Rule documentation URL,\n            see [RuleMeta][xrlint.rule.RuleMeta].\n        registry: Rule registry. Can be provided to register the\n            defined rule using its `name`.\n        op_class: Rule operation class. Must not be provided\n            if this function is used as a class decorator.\n\n    Returns:\n        A decorator function, if `op_class` is `None` otherwise\n            the value of `op_class`.\n\n    Raises:\n        TypeError: If either `op_class` or the decorated object is not\n            a class derived from [RuleOp][xrlint.rule.RuleOp].\n    \"\"\"\n\n    def _define_rule(_op_class: Type[RuleOp], no_deco=False) -&gt; Type[RuleOp] | Rule:\n        if not isclass(_op_class) or not issubclass(_op_class, RuleOp):\n            raise TypeError(\n                f\"component decorated by define_rule()\"\n                f\" must be a subclass of {RuleOp.__name__}\"\n            )\n        meta = RuleMeta(\n            name=name or to_kebab_case(_op_class.__name__),\n            version=version,\n            description=description or _op_class.__doc__,\n            docs_url=docs_url,\n            type=type if type is not None else \"problem\",\n            # TODO: if schema not given,\n            #   derive it from _op_class' ctor arguments\n            schema=schema,\n        )\n        # Register rule metadata in rule operation class\n        setattr(_op_class, \"meta\", meta)\n        rule = Rule(meta=meta, op_class=_op_class)\n        if registry is not None:\n            # Register rule in rule registry\n            registry[meta.name] = rule\n        return rule if no_deco else _op_class\n\n    if op_class is None:\n        # decorator case: return decorated class\n        return _define_rule\n    else:\n        # called as function: return new rule\n        return _define_rule(op_class, no_deco=True)\n</code></pre>"},{"location":"api/#xrlint.rule.Rule","title":"<code>xrlint.rule.Rule</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MappingConstructible</code>, <code>JsonSerializable</code></p> <p>A rule comprises rule metadata and a reference to the class that implements the rule's logic.</p> <p>Instances of this class can be easily created and added to a plugin by using the decorator <code>@define_rule</code> of the <code>Plugin</code> class.</p> <p>Parameters:</p> Name Type Description Default <code>meta</code> <code>RuleMeta</code> <p>the rule's metadata</p> required <code>op_class</code> <code>Type[RuleOp]</code> <p>the class that implements the rule's logic</p> required Source code in <code>xrlint\\rule.py</code> <pre><code>@dataclass(frozen=True)\nclass Rule(MappingConstructible, JsonSerializable):\n    \"\"\"A rule comprises rule metadata and a reference to the\n    class that implements the rule's logic.\n\n    Instances of this class can be easily created and added to a plugin\n    by using the decorator `@define_rule` of the `Plugin` class.\n\n    Args:\n        meta: the rule's metadata\n        op_class: the class that implements the rule's logic\n    \"\"\"\n\n    meta: RuleMeta\n    \"\"\"Rule metadata of type `RuleMeta`.\"\"\"\n\n    op_class: Type[RuleOp]\n    \"\"\"The class the implements the rule's verification operation.\n    The class must implement the `RuleOp` interface.\n    \"\"\"\n\n    @classmethod\n    def _from_str(cls, value: str, value_name: str) -&gt; \"Rule\":\n        rule, rule_ref = import_value(value, \"export_rule\", factory=Rule.from_value)\n        rule.meta.ref = rule_ref\n        return rule\n\n    @classmethod\n    def _from_type(cls, value: Type, value_name: str) -&gt; \"Rule\":\n        if issubclass(value, RuleOp):\n            op_class = value\n            try:\n                # noinspection PyUnresolvedReferences\n                # Note, the value.meta attribute is set by\n                # the define_rule() function.\n                meta = value.meta\n            except AttributeError:\n                raise ValueError(\n                    f\"missing rule metadata, apply define_rule()\"\n                    f\" to class {value.__name__}\"\n                )\n            return Rule(meta=meta, op_class=op_class)\n        super()._from_type(value, value_name)\n\n    @classmethod\n    def _get_value_type_name(cls) -&gt; str:\n        return \"Rule | dict | str\"\n\n    # noinspection PyUnusedLocal\n    def to_json(self, value_name: str | None = None) -&gt; str:\n        if self.meta.ref:\n            return self.meta.ref\n        return super().to_json(value_name=value_name)\n</code></pre>"},{"location":"api/#xrlint.rule.Rule.meta","title":"<code>meta</code>  <code>instance-attribute</code>","text":"<p>Rule metadata of type <code>RuleMeta</code>.</p>"},{"location":"api/#xrlint.rule.Rule.op_class","title":"<code>op_class</code>  <code>instance-attribute</code>","text":"<p>The class the implements the rule's verification operation. The class must implement the <code>RuleOp</code> interface.</p>"},{"location":"api/#xrlint.rule.RuleMeta","title":"<code>xrlint.rule.RuleMeta</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MappingConstructible</code>, <code>JsonSerializable</code></p> <p>Rule metadata.</p> Source code in <code>xrlint\\rule.py</code> <pre><code>@dataclass(kw_only=True)\nclass RuleMeta(MappingConstructible, JsonSerializable):\n    \"\"\"Rule metadata.\"\"\"\n\n    name: str\n    \"\"\"Rule name. Mandatory.\"\"\"\n\n    version: str = \"0.0.0\"\n    \"\"\"Rule version. Defaults to `0.0.0`.\"\"\"\n\n    description: str | None = None\n    \"\"\"Rule description.\"\"\"\n\n    docs_url: str | None = None\n    \"\"\"Rule documentation URL.\"\"\"\n\n    schema: dict[str, Any] | list[dict[str, Any]] | bool | None = None\n    \"\"\"JSON Schema used to specify and validate the rule operation\n    options.\n\n    It can take the following values:\n\n    - Use `None` (the default) to indicate that the rule operation\n      as no options at all.\n    - Use a schema to indicate that the rule operation\n      takes keyword arguments only.\n      The schema's type must be `\"object\"`.\n    - Use a list of schemas to indicate that the rule operation\n      takes positional arguments only.\n      If given, the number of schemas in the list specifies the\n      number of positional arguments that must be configured.\n    \"\"\"\n\n    type: Literal[\"problem\", \"suggestion\", \"layout\"] = \"problem\"\n    \"\"\"Rule type. Defaults to `\"problem\"`.\n\n    The type field can have one of the following values:\n\n    - `\"problem\"`: Indicates that the rule addresses datasets that are\n      likely to cause errors or unexpected behavior during runtime.\n      These issues usually represent real bugs or potential runtime problems.\n    - `\"suggestion\"`: Used for rules that suggest structural improvements\n      or enforce best practices. These issues are not necessarily bugs, but\n      following the suggestions may lead to more readable, maintainable, or\n      consistent datasets.\n    - `\"layout\"`: Specifies that the rule enforces consistent stylistic\n      aspects of dataset formatting, e.g., whitespaces in names.\n      Issues with layout rules are often automatically fixable\n      (not supported yet).\n\n    Primarily serves to categorize the rule's purpose for the benefit\n    of developers and tools that consume XRLint output.\n    It doesn\u2019t directly affect the linting logic - that part is handled\n    by the rule\u2019s implementation and its configured severity.\n    \"\"\"\n\n    ref: str | None = None\n    \"\"\"Rule reference.\n    Specifies the location from where the rule can be\n    dynamically imported.\n    Must have the form \"&lt;module&gt;:&lt;attr&gt;\", if given.\n    \"\"\"\n\n    @classmethod\n    def _get_value_type_name(cls) -&gt; str:\n        return \"RuleMeta | dict\"\n\n    def to_dict(self, value_name: str | None = None) -&gt; dict[str, str]:\n        return {\n            k: v\n            for k, v in super().to_dict(value_name=value_name).items()\n            if v is not None\n        }\n</code></pre>"},{"location":"api/#xrlint.rule.RuleMeta.name","title":"<code>name</code>  <code>instance-attribute</code>","text":"<p>Rule name. Mandatory.</p>"},{"location":"api/#xrlint.rule.RuleMeta.version","title":"<code>version = '0.0.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rule version. Defaults to <code>0.0.0</code>.</p>"},{"location":"api/#xrlint.rule.RuleMeta.description","title":"<code>description = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rule description.</p>"},{"location":"api/#xrlint.rule.RuleMeta.docs_url","title":"<code>docs_url = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rule documentation URL.</p>"},{"location":"api/#xrlint.rule.RuleMeta.schema","title":"<code>schema = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>JSON Schema used to specify and validate the rule operation options.</p> <p>It can take the following values:</p> <ul> <li>Use <code>None</code> (the default) to indicate that the rule operation   as no options at all.</li> <li>Use a schema to indicate that the rule operation   takes keyword arguments only.   The schema's type must be <code>\"object\"</code>.</li> <li>Use a list of schemas to indicate that the rule operation   takes positional arguments only.   If given, the number of schemas in the list specifies the   number of positional arguments that must be configured.</li> </ul>"},{"location":"api/#xrlint.rule.RuleMeta.type","title":"<code>type = 'problem'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rule type. Defaults to <code>\"problem\"</code>.</p> <p>The type field can have one of the following values:</p> <ul> <li><code>\"problem\"</code>: Indicates that the rule addresses datasets that are   likely to cause errors or unexpected behavior during runtime.   These issues usually represent real bugs or potential runtime problems.</li> <li><code>\"suggestion\"</code>: Used for rules that suggest structural improvements   or enforce best practices. These issues are not necessarily bugs, but   following the suggestions may lead to more readable, maintainable, or   consistent datasets.</li> <li><code>\"layout\"</code>: Specifies that the rule enforces consistent stylistic   aspects of dataset formatting, e.g., whitespaces in names.   Issues with layout rules are often automatically fixable   (not supported yet).</li> </ul> <p>Primarily serves to categorize the rule's purpose for the benefit of developers and tools that consume XRLint output. It doesn\u2019t directly affect the linting logic - that part is handled by the rule\u2019s implementation and its configured severity.</p>"},{"location":"api/#xrlint.rule.RuleMeta.ref","title":"<code>ref = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rule reference. Specifies the location from where the rule can be dynamically imported. Must have the form \":\", if given."},{"location":"api/#xrlint.rule.RuleOp","title":"<code>xrlint.rule.RuleOp</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Define the specific rule verification operation.</p> Source code in <code>xrlint\\rule.py</code> <pre><code>class RuleOp(ABC):\n    \"\"\"Define the specific rule verification operation.\"\"\"\n\n    def dataset(self, context: RuleContext, node: DatasetNode) -&gt; None:\n        \"\"\"Verify the given dataset node.\n\n        Args:\n            context: The current rule context.\n            node: The dataset node.\n\n        Raises:\n            RuleExit: to exit rule logic and further node traversal\n        \"\"\"\n\n    def data_array(self, context: RuleContext, node: DataArrayNode) -&gt; None:\n        \"\"\"Verify the given data array (variable) node.\n\n        Args:\n            context: The current rule context.\n            node: The data array (variable) node.\n\n        Raises:\n            RuleExit: to exit rule logic and further node traversal\n        \"\"\"\n\n    def attrs(self, context: RuleContext, node: AttrsNode) -&gt; None:\n        \"\"\"Verify the given attributes node.\n\n        Args:\n            context: The current rule context.\n            node: The attributes node.\n\n        Raises:\n            RuleExit: to exit rule logic and further node traversal\n        \"\"\"\n\n    def attr(self, context: RuleContext, node: AttrNode) -&gt; None:\n        \"\"\"Verify the given attribute node.\n\n        Args:\n            context: The current rule context.\n            node: The attribute node.\n\n        Raises:\n            RuleExit: to exit rule logic and further node traversal\n        \"\"\"\n</code></pre>"},{"location":"api/#xrlint.rule.RuleOp.dataset","title":"<code>dataset(context, node)</code>","text":"<p>Verify the given dataset node.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>RuleContext</code> <p>The current rule context.</p> required <code>node</code> <code>DatasetNode</code> <p>The dataset node.</p> required <p>Raises:</p> Type Description <code>RuleExit</code> <p>to exit rule logic and further node traversal</p> Source code in <code>xrlint\\rule.py</code> <pre><code>def dataset(self, context: RuleContext, node: DatasetNode) -&gt; None:\n    \"\"\"Verify the given dataset node.\n\n    Args:\n        context: The current rule context.\n        node: The dataset node.\n\n    Raises:\n        RuleExit: to exit rule logic and further node traversal\n    \"\"\"\n</code></pre>"},{"location":"api/#xrlint.rule.RuleOp.data_array","title":"<code>data_array(context, node)</code>","text":"<p>Verify the given data array (variable) node.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>RuleContext</code> <p>The current rule context.</p> required <code>node</code> <code>DataArrayNode</code> <p>The data array (variable) node.</p> required <p>Raises:</p> Type Description <code>RuleExit</code> <p>to exit rule logic and further node traversal</p> Source code in <code>xrlint\\rule.py</code> <pre><code>def data_array(self, context: RuleContext, node: DataArrayNode) -&gt; None:\n    \"\"\"Verify the given data array (variable) node.\n\n    Args:\n        context: The current rule context.\n        node: The data array (variable) node.\n\n    Raises:\n        RuleExit: to exit rule logic and further node traversal\n    \"\"\"\n</code></pre>"},{"location":"api/#xrlint.rule.RuleOp.attrs","title":"<code>attrs(context, node)</code>","text":"<p>Verify the given attributes node.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>RuleContext</code> <p>The current rule context.</p> required <code>node</code> <code>AttrsNode</code> <p>The attributes node.</p> required <p>Raises:</p> Type Description <code>RuleExit</code> <p>to exit rule logic and further node traversal</p> Source code in <code>xrlint\\rule.py</code> <pre><code>def attrs(self, context: RuleContext, node: AttrsNode) -&gt; None:\n    \"\"\"Verify the given attributes node.\n\n    Args:\n        context: The current rule context.\n        node: The attributes node.\n\n    Raises:\n        RuleExit: to exit rule logic and further node traversal\n    \"\"\"\n</code></pre>"},{"location":"api/#xrlint.rule.RuleOp.attr","title":"<code>attr(context, node)</code>","text":"<p>Verify the given attribute node.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>RuleContext</code> <p>The current rule context.</p> required <code>node</code> <code>AttrNode</code> <p>The attribute node.</p> required <p>Raises:</p> Type Description <code>RuleExit</code> <p>to exit rule logic and further node traversal</p> Source code in <code>xrlint\\rule.py</code> <pre><code>def attr(self, context: RuleContext, node: AttrNode) -&gt; None:\n    \"\"\"Verify the given attribute node.\n\n    Args:\n        context: The current rule context.\n        node: The attribute node.\n\n    Raises:\n        RuleExit: to exit rule logic and further node traversal\n    \"\"\"\n</code></pre>"},{"location":"api/#xrlint.rule.RuleContext","title":"<code>xrlint.rule.RuleContext</code>","text":"<p>               Bases: <code>ABC</code></p> <p>The context passed to a RuleOp instance.</p> <p>Instances of this interface are passed to the validation methods of your <code>RuleOp</code>. There should be no reason to create instances of this class yourself.</p> Source code in <code>xrlint\\rule.py</code> <pre><code>class RuleContext(ABC):\n    \"\"\"The context passed to a [RuleOp][xrlint.rule.RuleOp] instance.\n\n    Instances of this interface are passed to the validation\n    methods of your `RuleOp`.\n    There should be no reason to create instances of this class\n    yourself.\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def file_path(self) -&gt; str:\n        \"\"\"The current dataset's file path.\"\"\"\n\n    @property\n    @abstractmethod\n    def settings(self) -&gt; dict[str, Any]:\n        \"\"\"Applicable subset of settings from configuration `settings`.\"\"\"\n\n    @property\n    @abstractmethod\n    def dataset(self) -&gt; xr.Dataset:\n        \"\"\"The current dataset.\"\"\"\n\n    @abstractmethod\n    def report(\n        self,\n        message: str,\n        *,\n        fatal: bool | None = None,\n        suggestions: list[Suggestion | str] | None = None,\n    ):\n        \"\"\"Report an issue.\n\n        Args:\n            message: mandatory message text\n            fatal: True, if a fatal error is reported.\n            suggestions: A list of suggestions for the user\n                on how to fix the reported issue. Items may\n                be of type `Suggestion` or `str`.\n        \"\"\"\n</code></pre>"},{"location":"api/#xrlint.rule.RuleContext.file_path","title":"<code>file_path</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>The current dataset's file path.</p>"},{"location":"api/#xrlint.rule.RuleContext.settings","title":"<code>settings</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Applicable subset of settings from configuration <code>settings</code>.</p>"},{"location":"api/#xrlint.rule.RuleContext.dataset","title":"<code>dataset</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>The current dataset.</p>"},{"location":"api/#xrlint.rule.RuleContext.report","title":"<code>report(message, *, fatal=None, suggestions=None)</code>  <code>abstractmethod</code>","text":"<p>Report an issue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>mandatory message text</p> required <code>fatal</code> <code>bool | None</code> <p>True, if a fatal error is reported.</p> <code>None</code> <code>suggestions</code> <code>list[Suggestion | str] | None</code> <p>A list of suggestions for the user on how to fix the reported issue. Items may be of type <code>Suggestion</code> or <code>str</code>.</p> <code>None</code> Source code in <code>xrlint\\rule.py</code> <pre><code>@abstractmethod\ndef report(\n    self,\n    message: str,\n    *,\n    fatal: bool | None = None,\n    suggestions: list[Suggestion | str] | None = None,\n):\n    \"\"\"Report an issue.\n\n    Args:\n        message: mandatory message text\n        fatal: True, if a fatal error is reported.\n        suggestions: A list of suggestions for the user\n            on how to fix the reported issue. Items may\n            be of type `Suggestion` or `str`.\n    \"\"\"\n</code></pre>"},{"location":"api/#xrlint.rule.RuleExit","title":"<code>xrlint.rule.RuleExit</code>","text":"<p>               Bases: <code>Exception</code></p> <p>The <code>RuleExit</code> is an exception that can be raised to immediately cancel dataset node validation with the current rule.</p> <p>Raise it from any of your <code>RuleOp</code> method implementations if further node traversal doesn't make sense. Typical usage:</p> <pre><code>if something_is_not_ok:\n    ctx.report(\"Something is not ok.\")\n    raise RuleExit\n</code></pre> Source code in <code>xrlint\\rule.py</code> <pre><code>class RuleExit(Exception):\n    \"\"\"The `RuleExit` is an exception that can be raised to\n    immediately cancel dataset node validation with the current rule.\n\n    Raise it from any of your `RuleOp` method implementations if further\n    node traversal doesn't make sense. Typical usage:\n\n    ```python\n    if something_is_not_ok:\n        ctx.report(\"Something is not ok.\")\n        raise RuleExit\n    ```\n    \"\"\"\n</code></pre>"},{"location":"api/#xrlint.node.Node","title":"<code>xrlint.node.Node</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for nodes passed to the methods of a rule operation xrlint.rule.RuleOp.</p> Source code in <code>xrlint\\node.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass Node(ABC):\n    \"\"\"Abstract base class for nodes passed to the methods of a\n    rule operation [xrlint.rule.RuleOp][].\"\"\"\n\n    path: str\n    \"\"\"Node path. So users find where in the tree the issue occurred.\"\"\"\n\n    parent: Union[\"Node\", None]\n    \"\"\"Node parent. `None` for root nodes.\"\"\"\n</code></pre>"},{"location":"api/#xrlint.node.Node.path","title":"<code>path</code>  <code>instance-attribute</code>","text":"<p>Node path. So users find where in the tree the issue occurred.</p>"},{"location":"api/#xrlint.node.Node.parent","title":"<code>parent</code>  <code>instance-attribute</code>","text":"<p>Node parent. <code>None</code> for root nodes.</p>"},{"location":"api/#xrlint.node.XarrayNode","title":"<code>xrlint.node.XarrayNode</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Node</code></p> <p>Base class for <code>xr.Dataset</code> nodes.</p> Source code in <code>xrlint\\node.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass XarrayNode(Node):\n    \"\"\"Base class for `xr.Dataset` nodes.\"\"\"\n\n    def in_coords(self) -&gt; bool:\n        \"\"\"Return `True` if this node is in `xr.Dataset.coords`.\"\"\"\n        return \".coords[\" in self.path\n\n    def in_data_vars(self) -&gt; bool:\n        \"\"\"Return `True` if this node is a `xr.Dataset.data_vars`.\"\"\"\n        return \".data_vars[\" in self.path\n\n    def in_root(self) -&gt; bool:\n        \"\"\"Return `True` if this node is a direct child of the dataset.\"\"\"\n        return not self.in_coords() and not self.in_data_vars()\n</code></pre>"},{"location":"api/#xrlint.node.XarrayNode.in_coords","title":"<code>in_coords()</code>","text":"<p>Return <code>True</code> if this node is in <code>xr.Dataset.coords</code>.</p> Source code in <code>xrlint\\node.py</code> <pre><code>def in_coords(self) -&gt; bool:\n    \"\"\"Return `True` if this node is in `xr.Dataset.coords`.\"\"\"\n    return \".coords[\" in self.path\n</code></pre>"},{"location":"api/#xrlint.node.XarrayNode.in_data_vars","title":"<code>in_data_vars()</code>","text":"<p>Return <code>True</code> if this node is a <code>xr.Dataset.data_vars</code>.</p> Source code in <code>xrlint\\node.py</code> <pre><code>def in_data_vars(self) -&gt; bool:\n    \"\"\"Return `True` if this node is a `xr.Dataset.data_vars`.\"\"\"\n    return \".data_vars[\" in self.path\n</code></pre>"},{"location":"api/#xrlint.node.XarrayNode.in_root","title":"<code>in_root()</code>","text":"<p>Return <code>True</code> if this node is a direct child of the dataset.</p> Source code in <code>xrlint\\node.py</code> <pre><code>def in_root(self) -&gt; bool:\n    \"\"\"Return `True` if this node is a direct child of the dataset.\"\"\"\n    return not self.in_coords() and not self.in_data_vars()\n</code></pre>"},{"location":"api/#xrlint.node.DatasetNode","title":"<code>xrlint.node.DatasetNode</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XarrayNode</code></p> <p>Dataset node.</p> Source code in <code>xrlint\\node.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass DatasetNode(XarrayNode):\n    \"\"\"Dataset node.\"\"\"\n\n    dataset: xr.Dataset\n    \"\"\"The `xarray.Dataset` instance.\"\"\"\n</code></pre>"},{"location":"api/#xrlint.node.DatasetNode.dataset","title":"<code>dataset</code>  <code>instance-attribute</code>","text":"<p>The <code>xarray.Dataset</code> instance.</p>"},{"location":"api/#xrlint.node.DataArrayNode","title":"<code>xrlint.node.DataArrayNode</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XarrayNode</code></p> <p>Data array node.</p> Source code in <code>xrlint\\node.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass DataArrayNode(XarrayNode):\n    \"\"\"Data array node.\"\"\"\n\n    name: Hashable\n    \"\"\"The name of the data array.\"\"\"\n\n    data_array: xr.DataArray\n    \"\"\"The `xarray.DataArray` instance.\"\"\"\n</code></pre>"},{"location":"api/#xrlint.node.DataArrayNode.name","title":"<code>name</code>  <code>instance-attribute</code>","text":"<p>The name of the data array.</p>"},{"location":"api/#xrlint.node.DataArrayNode.data_array","title":"<code>data_array</code>  <code>instance-attribute</code>","text":"<p>The <code>xarray.DataArray</code> instance.</p>"},{"location":"api/#xrlint.node.AttrsNode","title":"<code>xrlint.node.AttrsNode</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XarrayNode</code></p> <p>Attributes node.</p> Source code in <code>xrlint\\node.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass AttrsNode(XarrayNode):\n    \"\"\"Attributes node.\"\"\"\n\n    attrs: dict[str, Any]\n    \"\"\"Attributes dictionary.\"\"\"\n</code></pre>"},{"location":"api/#xrlint.node.AttrsNode.attrs","title":"<code>attrs</code>  <code>instance-attribute</code>","text":"<p>Attributes dictionary.</p>"},{"location":"api/#xrlint.node.AttrNode","title":"<code>xrlint.node.AttrNode</code>  <code>dataclass</code>","text":"<p>               Bases: <code>XarrayNode</code></p> <p>Attribute node.</p> Source code in <code>xrlint\\node.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass AttrNode(XarrayNode):\n    \"\"\"Attribute node.\"\"\"\n\n    name: str\n    \"\"\"Attribute name.\"\"\"\n\n    value: Any\n    \"\"\"Attribute value.\"\"\"\n</code></pre>"},{"location":"api/#xrlint.node.AttrNode.name","title":"<code>name</code>  <code>instance-attribute</code>","text":"<p>Attribute name.</p>"},{"location":"api/#xrlint.node.AttrNode.value","title":"<code>value</code>  <code>instance-attribute</code>","text":"<p>Attribute value.</p>"},{"location":"api/#xrlint.plugin.Plugin","title":"<code>xrlint.plugin.Plugin</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MappingConstructible</code>, <code>JsonSerializable</code></p> <p>An XRLint plugin.</p> Source code in <code>xrlint\\plugin.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass Plugin(MappingConstructible, JsonSerializable):\n    \"\"\"An XRLint plugin.\"\"\"\n\n    meta: PluginMeta\n    \"\"\"Information about the plugin.\"\"\"\n\n    configs: dict[str, Config] = field(default_factory=dict)\n    \"\"\"A dictionary containing named configurations.\"\"\"\n\n    rules: dict[str, Rule] = field(default_factory=dict)\n    \"\"\"A dictionary containing the definitions of custom rules.\"\"\"\n\n    processors: dict[str, Processor] = field(default_factory=dict)\n    \"\"\"A dictionary containing named processors.\n    \"\"\"\n\n    def define_rule(\n        self,\n        name: str,\n        version: str = \"0.0.0\",\n        schema: dict[str, Any] | list[dict[str, Any]] | bool | None = None,\n        type: Literal[\"problem\", \"suggestion\", \"layout\"] | None = None,\n        description: str | None = None,\n        docs_url: str | None = None,\n        op_class: Type[RuleOp] | None = None,\n    ) -&gt; Callable[[Any], Type[RuleOp]] | None:\n        \"\"\"Decorator to define a plugin rule.\n        The method registers a new rule with the plugin.\n\n        Refer to [define_rule][xrlint.rule.define_rule]\n        for details.\n        \"\"\"\n        return define_rule(\n            name=name,\n            version=version,\n            schema=schema,\n            type=type,\n            description=description,\n            docs_url=docs_url,\n            op_class=op_class,\n            registry=self.rules,\n        )\n\n    def define_processor(\n        self,\n        name: str | None = None,\n        version: str = \"0.0.0\",\n        op_class: Type[ProcessorOp] | None = None,\n    ):\n        \"\"\"Decorator to define a plugin processor.\n        The method registers a new processor with the plugin.\n\n        Refer to [define_processor][xrlint.processor.define_processor]\n        for details.\n        \"\"\"\n        return define_processor(\n            name=name,\n            version=version,\n            op_class=op_class,\n            registry=self.processors,\n        )\n\n    @classmethod\n    def _from_str(cls, value: str, value_name: str) -&gt; \"Plugin\":\n        plugin, plugin_ref = import_value(\n            value, \"export_plugin\", factory=Plugin.from_value\n        )\n        plugin.meta.ref = plugin_ref\n        return plugin\n\n    @classmethod\n    def _get_value_type_name(cls) -&gt; str:\n        return \"Plugin | dict | str\"\n\n    def to_json(self, value_name: str | None = None) -&gt; JsonValue:\n        if self.meta.ref:\n            return self.meta.ref\n        return super().to_json(value_name=value_name)\n</code></pre>"},{"location":"api/#xrlint.plugin.Plugin.meta","title":"<code>meta</code>  <code>instance-attribute</code>","text":"<p>Information about the plugin.</p>"},{"location":"api/#xrlint.plugin.Plugin.configs","title":"<code>configs = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary containing named configurations.</p>"},{"location":"api/#xrlint.plugin.Plugin.rules","title":"<code>rules = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary containing the definitions of custom rules.</p>"},{"location":"api/#xrlint.plugin.Plugin.processors","title":"<code>processors = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary containing named processors.</p>"},{"location":"api/#xrlint.plugin.Plugin.define_rule","title":"<code>define_rule(name, version='0.0.0', schema=None, type=None, description=None, docs_url=None, op_class=None)</code>","text":"<p>Decorator to define a plugin rule. The method registers a new rule with the plugin.</p> <p>Refer to define_rule for details.</p> Source code in <code>xrlint\\plugin.py</code> <pre><code>def define_rule(\n    self,\n    name: str,\n    version: str = \"0.0.0\",\n    schema: dict[str, Any] | list[dict[str, Any]] | bool | None = None,\n    type: Literal[\"problem\", \"suggestion\", \"layout\"] | None = None,\n    description: str | None = None,\n    docs_url: str | None = None,\n    op_class: Type[RuleOp] | None = None,\n) -&gt; Callable[[Any], Type[RuleOp]] | None:\n    \"\"\"Decorator to define a plugin rule.\n    The method registers a new rule with the plugin.\n\n    Refer to [define_rule][xrlint.rule.define_rule]\n    for details.\n    \"\"\"\n    return define_rule(\n        name=name,\n        version=version,\n        schema=schema,\n        type=type,\n        description=description,\n        docs_url=docs_url,\n        op_class=op_class,\n        registry=self.rules,\n    )\n</code></pre>"},{"location":"api/#xrlint.plugin.Plugin.define_processor","title":"<code>define_processor(name=None, version='0.0.0', op_class=None)</code>","text":"<p>Decorator to define a plugin processor. The method registers a new processor with the plugin.</p> <p>Refer to define_processor for details.</p> Source code in <code>xrlint\\plugin.py</code> <pre><code>def define_processor(\n    self,\n    name: str | None = None,\n    version: str = \"0.0.0\",\n    op_class: Type[ProcessorOp] | None = None,\n):\n    \"\"\"Decorator to define a plugin processor.\n    The method registers a new processor with the plugin.\n\n    Refer to [define_processor][xrlint.processor.define_processor]\n    for details.\n    \"\"\"\n    return define_processor(\n        name=name,\n        version=version,\n        op_class=op_class,\n        registry=self.processors,\n    )\n</code></pre>"},{"location":"api/#xrlint.plugin.PluginMeta","title":"<code>xrlint.plugin.PluginMeta</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MappingConstructible</code>, <code>JsonSerializable</code></p> <p>XRLint plugin metadata.</p> Source code in <code>xrlint\\plugin.py</code> <pre><code>@dataclass(kw_only=True)\nclass PluginMeta(MappingConstructible, JsonSerializable):\n    \"\"\"XRLint plugin metadata.\"\"\"\n\n    name: str\n    \"\"\"Plugin name.\"\"\"\n\n    version: str = \"0.0.0\"\n    \"\"\"Plugin version.\"\"\"\n\n    ref: str | None = None\n    \"\"\"Plugin reference.\n    Specifies the location from where the plugin can be\n    dynamically imported.\n    Must have the form \"&lt;module&gt;:&lt;attr&gt;\", if given.\n    \"\"\"\n\n    @classmethod\n    def _get_value_type_name(cls) -&gt; str:\n        return \"PluginMeta | dict\"\n</code></pre>"},{"location":"api/#xrlint.plugin.PluginMeta.name","title":"<code>name</code>  <code>instance-attribute</code>","text":"<p>Plugin name.</p>"},{"location":"api/#xrlint.plugin.PluginMeta.version","title":"<code>version = '0.0.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Plugin version.</p>"},{"location":"api/#xrlint.plugin.PluginMeta.ref","title":"<code>ref = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Plugin reference. Specifies the location from where the plugin can be dynamically imported. Must have the form \":\", if given."},{"location":"api/#xrlint.processor.define_processor","title":"<code>xrlint.processor.define_processor(name=None, version='0.0.0', registry=None, op_class=None)</code>","text":"<p>Define a processor.</p> <p>This function can be used to decorate your processor operation class definitions. When used as a decorator, the decorated operator class will receive a <code>meta</code> attribute of type ProcessorMeta. In addition, the <code>registry</code> if given, will be updated using <code>name</code> as key and a new Processor as value.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Processor name, see ProcessorMeta.</p> <code>None</code> <code>version</code> <code>str</code> <p>Processor version, see ProcessorMeta.</p> <code>'0.0.0'</code> <code>registry</code> <code>dict[str, Processor] | None</code> <p>Processor registry. Can be provided to register the defined processor using its <code>name</code>.</p> <code>None</code> <code>op_class</code> <code>Type[ProcessorOp] | None</code> <p>Processor operation class. Must not be provided if this function is used as a class decorator.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[Any], Type[ProcessorOp]] | Processor</code> <p>A decorator function, if <code>op_class</code> is <code>None</code> otherwise the value of <code>op_class</code>.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If either <code>op_class</code> or the decorated object is not a a class derived from ProcessorOp.</p> Source code in <code>xrlint\\processor.py</code> <pre><code>def define_processor(\n    name: str | None = None,\n    version: str = \"0.0.0\",\n    registry: dict[str, Processor] | None = None,\n    op_class: Type[ProcessorOp] | None = None,\n) -&gt; Callable[[Any], Type[ProcessorOp]] | Processor:\n    \"\"\"Define a processor.\n\n    This function can be used to decorate your processor operation class\n    definitions. When used as a decorator, the decorated operator class\n    will receive a `meta` attribute of type\n    [ProcessorMeta][xrlint.processor.ProcessorMeta].\n    In addition, the `registry` if given, will be updated using `name`\n    as key and a new [Processor][xrlint.processor.Processor] as value.\n\n    Args:\n        name: Processor name,\n            see [ProcessorMeta][xrlint.processor.ProcessorMeta].\n        version: Processor version,\n            see [ProcessorMeta][xrlint.processor.ProcessorMeta].\n        registry: Processor registry. Can be provided to register the\n            defined processor using its `name`.\n        op_class: Processor operation class. Must not be provided\n            if this function is used as a class decorator.\n\n    Returns:\n        A decorator function, if `op_class` is `None` otherwise\n            the value of `op_class`.\n\n    Raises:\n        TypeError: If either `op_class` or the decorated object is not a\n            a class derived from [ProcessorOp][xrlint.processor.ProcessorOp].\n    \"\"\"\n\n    def _define_processor(\n        _op_class: Any, no_deco=False\n    ) -&gt; Type[ProcessorOp] | Processor:\n        if not isclass(_op_class) or not issubclass(_op_class, ProcessorOp):\n            raise TypeError(\n                f\"component decorated by define_processor()\"\n                f\" must be a subclass of {ProcessorOp.__name__}\"\n            )\n        meta = ProcessorMeta(\n            name=name or to_kebab_case(_op_class.__name__),\n            version=version,\n        )\n        setattr(_op_class, \"meta\", meta)\n        processor = Processor(meta=meta, op_class=_op_class)\n        if registry is not None:\n            registry[meta.name] = processor\n        return processor if no_deco else _op_class\n\n    if op_class is None:\n        # decorator case\n        return _define_processor\n    else:\n        return _define_processor(op_class, no_deco=True)\n</code></pre>"},{"location":"api/#xrlint.processor.Processor","title":"<code>xrlint.processor.Processor</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MappingConstructible</code></p> <p>Processors tell XRLint how to process files other than standard xarray datasets.</p> Source code in <code>xrlint\\processor.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass Processor(MappingConstructible):\n    \"\"\"Processors tell XRLint how to process files other than\n    standard xarray datasets.\n    \"\"\"\n\n    meta: ProcessorMeta\n    \"\"\"Information about the processor.\"\"\"\n\n    op_class: Type[ProcessorOp]\n    \"\"\"A class that implements the processor operations.\"\"\"\n\n    # Not yet:\n    # supports_auto_fix: bool = False\n    # \"\"\"`True` if this processor supports auto-fixing of datasets.\"\"\"\n\n    @classmethod\n    def _from_type(cls, value: Type[ProcessorOp], value_name: str) -&gt; \"Processor\":\n        # TODO: no test covers Processor._from_type\n        if issubclass(value, ProcessorOp):\n            # TODO: fix code duplication in Rule._from_class()\n            try:\n                # Note, the value.meta attribute is set by\n                # the define_rule\n                # noinspection PyUnresolvedReferences\n                return Processor(meta=value.meta, op_class=value)\n            except AttributeError:\n                raise ValueError(\n                    f\"missing processor metadata, apply define_processor()\"\n                    f\" to class {value.__name__}\"\n                )\n        return super()._from_type(value, value_name)\n\n    @classmethod\n    def _from_str(cls, value: str, value_name: str) -&gt; \"Processor\":\n        processor, processor_ref = import_value(\n            value,\n            \"export_processor\",\n            factory=Processor.from_value,\n        )\n        # noinspection PyUnresolvedReferences\n        processor.meta.ref = processor_ref\n        return processor\n\n    @classmethod\n    def _get_value_type_name(cls) -&gt; str:\n        return \"str | dict | Processor | Type[ProcessorOp]\"\n</code></pre>"},{"location":"api/#xrlint.processor.Processor.meta","title":"<code>meta</code>  <code>instance-attribute</code>","text":"<p>Information about the processor.</p>"},{"location":"api/#xrlint.processor.Processor.op_class","title":"<code>op_class</code>  <code>instance-attribute</code>","text":"<p>A class that implements the processor operations.</p>"},{"location":"api/#xrlint.processor.ProcessorMeta","title":"<code>xrlint.processor.ProcessorMeta</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MappingConstructible</code></p> <p>Processor metadata.</p> Source code in <code>xrlint\\processor.py</code> <pre><code>@dataclass(kw_only=True)\nclass ProcessorMeta(MappingConstructible):\n    \"\"\"Processor metadata.\"\"\"\n\n    name: str\n    \"\"\"Processor name.\"\"\"\n\n    version: str = \"0.0.0\"\n    \"\"\"Processor version.\"\"\"\n\n    ref: str | None = None\n    \"\"\"Processor reference.\n    Specifies the location from where the processor can be\n    dynamically imported.\n    Must have the form \"&lt;module&gt;:&lt;attr&gt;\", if given.\n    \"\"\"\n\n    @classmethod\n    def _get_value_type_name(cls) -&gt; str:\n        return \"ProcessorMeta | dict\"\n</code></pre>"},{"location":"api/#xrlint.processor.ProcessorMeta.name","title":"<code>name</code>  <code>instance-attribute</code>","text":"<p>Processor name.</p>"},{"location":"api/#xrlint.processor.ProcessorMeta.version","title":"<code>version = '0.0.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Processor version.</p>"},{"location":"api/#xrlint.processor.ProcessorMeta.ref","title":"<code>ref = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Processor reference. Specifies the location from where the processor can be dynamically imported. Must have the form \":\", if given."},{"location":"api/#xrlint.processor.ProcessorOp","title":"<code>xrlint.processor.ProcessorOp</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Implements the processor operations.</p> Source code in <code>xrlint\\processor.py</code> <pre><code>class ProcessorOp(ABC):\n    \"\"\"Implements the processor operations.\"\"\"\n\n    @abstractmethod\n    def preprocess(\n        self, file_path: str, opener_options: dict[str, Any]\n    ) -&gt; list[tuple[xr.Dataset, str]]:\n        \"\"\"Pre-process a dataset given by its `file_path` and `opener_options`.\n        In this method you use the `file_path` to read zero, one, or more\n        datasets to lint.\n\n        Args:\n            file_path: A file path\n            opener_options: The configuration's `opener_options`.\n\n        Returns:\n            A list of (dataset, file_path) pairs\n        \"\"\"\n\n    @abstractmethod\n    def postprocess(\n        self, messages: list[list[Message]], file_path: str\n    ) -&gt; list[Message]:\n        \"\"\"Post-process the outputs of each dataset from `preprocess()`.\n\n        Args:\n            messages: contains two-dimensional array of \u00b4Message\u00b4 objects\n                where each top-level array item contains array of lint messages\n                related to the dataset that was returned in array from\n                `preprocess()` method\n            file_path: The corresponding file path\n\n        Returns:\n            A one-dimensional array (list) of the messages you want to keep\n        \"\"\"\n</code></pre>"},{"location":"api/#xrlint.processor.ProcessorOp.preprocess","title":"<code>preprocess(file_path, opener_options)</code>  <code>abstractmethod</code>","text":"<p>Pre-process a dataset given by its <code>file_path</code> and <code>opener_options</code>. In this method you use the <code>file_path</code> to read zero, one, or more datasets to lint.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>A file path</p> required <code>opener_options</code> <code>dict[str, Any]</code> <p>The configuration's <code>opener_options</code>.</p> required <p>Returns:</p> Type Description <code>list[tuple[Dataset, str]]</code> <p>A list of (dataset, file_path) pairs</p> Source code in <code>xrlint\\processor.py</code> <pre><code>@abstractmethod\ndef preprocess(\n    self, file_path: str, opener_options: dict[str, Any]\n) -&gt; list[tuple[xr.Dataset, str]]:\n    \"\"\"Pre-process a dataset given by its `file_path` and `opener_options`.\n    In this method you use the `file_path` to read zero, one, or more\n    datasets to lint.\n\n    Args:\n        file_path: A file path\n        opener_options: The configuration's `opener_options`.\n\n    Returns:\n        A list of (dataset, file_path) pairs\n    \"\"\"\n</code></pre>"},{"location":"api/#xrlint.processor.ProcessorOp.postprocess","title":"<code>postprocess(messages, file_path)</code>  <code>abstractmethod</code>","text":"<p>Post-process the outputs of each dataset from <code>preprocess()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list[list[Message]]</code> <p>contains two-dimensional array of \u00b4Message\u00b4 objects where each top-level array item contains array of lint messages related to the dataset that was returned in array from <code>preprocess()</code> method</p> required <code>file_path</code> <code>str</code> <p>The corresponding file path</p> required <p>Returns:</p> Type Description <code>list[Message]</code> <p>A one-dimensional array (list) of the messages you want to keep</p> Source code in <code>xrlint\\processor.py</code> <pre><code>@abstractmethod\ndef postprocess(\n    self, messages: list[list[Message]], file_path: str\n) -&gt; list[Message]:\n    \"\"\"Post-process the outputs of each dataset from `preprocess()`.\n\n    Args:\n        messages: contains two-dimensional array of \u00b4Message\u00b4 objects\n            where each top-level array item contains array of lint messages\n            related to the dataset that was returned in array from\n            `preprocess()` method\n        file_path: The corresponding file path\n\n    Returns:\n        A one-dimensional array (list) of the messages you want to keep\n    \"\"\"\n</code></pre>"},{"location":"api/#xrlint.result.Result","title":"<code>xrlint.result.Result</code>  <code>dataclass</code>","text":"<p>               Bases: <code>JsonSerializable</code></p> <p>The aggregated information of linting a dataset.</p> Source code in <code>xrlint\\result.py</code> <pre><code>@dataclass()\nclass Result(JsonSerializable):\n    \"\"\"The aggregated information of linting a dataset.\"\"\"\n\n    config: Union[\"Config\", None] = None\n    \"\"\"Configuration.\"\"\"\n\n    file_path: str = MISSING_DATASET_FILE_PATH\n    \"\"\"The absolute path to the file of this result.\n    This is the string \"&lt;dataset&gt;\" if the file path is unknown\n    (when you didn't pass the `file_path` option to the\n    `xrlint.lint_dataset()` method).\n    \"\"\"\n\n    messages: list[Message] = field(default_factory=list)\n    \"\"\"The array of message objects.\"\"\"\n\n    fixable_error_count: int = 0\n    \"\"\"The number of errors that can be fixed automatically\n     by the fix constructor option.\n     \"\"\"\n\n    fixable_warning_count: int = 0\n    \"\"\"The number of warnings that can be fixed automatically\n     by the fix constructor option.\n     \"\"\"\n\n    error_count: int = 0\n    \"\"\"The number of errors. This includes fixable errors\n     and fatal errors.\n     \"\"\"\n\n    fatal_error_count: int = 0\n    \"\"\"The number of fatal errors.\"\"\"\n\n    warning_count: int = 0\n    \"\"\"The number of warnings. This includes fixable warnings.\"\"\"\n\n    @classmethod\n    def new(\n        cls,\n        config: Union[\"Config\", None] = None,\n        file_path: str | None = None,\n        messages: list[Message] | None = None,\n    ):\n        result = Result(\n            config=config,\n            file_path=file_path or MISSING_DATASET_FILE_PATH,\n            messages=messages or [],\n        )\n        for m in messages:\n            result.warning_count += 1 if m.severity == SEVERITY_WARN else 0\n            result.error_count += 1 if m.severity == SEVERITY_ERROR else 0\n            result.fatal_error_count += 1 if m.fatal else 0\n        return result\n\n    def to_html(self) -&gt; str:\n        text = []\n        escaped_path = html.escape(self.file_path)\n        if not self.messages:\n            text.append(f'&lt;p role=\"file\"&gt;{escaped_path} - ok&lt;/p&gt;\\n')\n        else:\n            text.append(f'&lt;p role=\"file\"&gt;{escaped_path}:&lt;/p&gt;\\n')\n            table_data = []\n            for m in self.messages:\n                table_data.append(\n                    [\n                        m.node_path,\n                        SEVERITY_CODE_TO_NAME.get(m.severity),\n                        m.message,\n                        m.rule_id,\n                    ]\n                )\n            text.append(tabulate(table_data, headers=(), tablefmt=\"html\"))\n            text.append(\n                '&lt;p role=\"summary\"&gt;'\n                f\"{format_problems(self.error_count, self.warning_count)}\"\n                \"&lt;/p&gt;\\n\"\n            )\n        return \"\".join(text)\n\n    def _repr_html_(self) -&gt; str:\n        return self.to_html()\n</code></pre>"},{"location":"api/#xrlint.result.Result.config","title":"<code>config = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Configuration.</p>"},{"location":"api/#xrlint.result.Result.file_path","title":"<code>file_path = MISSING_DATASET_FILE_PATH</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The absolute path to the file of this result. This is the string \"\" if the file path is unknown (when you didn't pass the <code>file_path</code> option to the <code>xrlint.lint_dataset()</code> method)."},{"location":"api/#xrlint.result.Result.messages","title":"<code>messages = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The array of message objects.</p>"},{"location":"api/#xrlint.result.Result.fixable_error_count","title":"<code>fixable_error_count = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The number of errors that can be fixed automatically by the fix constructor option.</p>"},{"location":"api/#xrlint.result.Result.fixable_warning_count","title":"<code>fixable_warning_count = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The number of warnings that can be fixed automatically by the fix constructor option.</p>"},{"location":"api/#xrlint.result.Result.error_count","title":"<code>error_count = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The number of errors. This includes fixable errors and fatal errors.</p>"},{"location":"api/#xrlint.result.Result.fatal_error_count","title":"<code>fatal_error_count = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The number of fatal errors.</p>"},{"location":"api/#xrlint.result.Result.warning_count","title":"<code>warning_count = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The number of warnings. This includes fixable warnings.</p>"},{"location":"api/#xrlint.result.Message","title":"<code>xrlint.result.Message</code>  <code>dataclass</code>","text":"<p>               Bases: <code>JsonSerializable</code></p> Source code in <code>xrlint\\result.py</code> <pre><code>@dataclass()\nclass Message(JsonSerializable):\n    message: str\n    \"\"\"The error message.\"\"\"\n\n    node_path: str | None = None\n    \"\"\"Node path within the dataset.\n    This property is None if the message does not\n    apply to a certain dataset node.\n    \"\"\"\n\n    rule_id: str | None = None\n    \"\"\"The rule name that generated this lint message.\n    If this message is generated by the xrlint core\n    rather than rules, this is None.\n    \"\"\"\n\n    severity: Literal[1, 2] | None = None\n    \"\"\"The severity of this message.\n    `1` means warning and `2` means error.\n    \"\"\"\n\n    fatal: bool | None = None\n    \"\"\"True if this is a fatal error unrelated to a rule,\n    like a parsing error.\n    \"\"\"\n\n    fix: EditInfo | None = None\n    \"\"\"The EditInfo object of autofix.\n    This property is None if this\n    message is not fixable.\n\n    Not used yet.\n    \"\"\"\n\n    suggestions: list[Suggestion] | None = None\n    \"\"\"The list of suggestions. Each suggestion is the pair\n    of a description and an EditInfo object to fix the dataset.\n    API users such as editor integrations can choose one of them\n    to fix the problem of this message.\n    This property is None if this message does not have any suggestions.\n    \"\"\"\n</code></pre>"},{"location":"api/#xrlint.result.Message.message","title":"<code>message</code>  <code>instance-attribute</code>","text":"<p>The error message.</p>"},{"location":"api/#xrlint.result.Message.node_path","title":"<code>node_path = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Node path within the dataset. This property is None if the message does not apply to a certain dataset node.</p>"},{"location":"api/#xrlint.result.Message.rule_id","title":"<code>rule_id = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The rule name that generated this lint message. If this message is generated by the xrlint core rather than rules, this is None.</p>"},{"location":"api/#xrlint.result.Message.severity","title":"<code>severity = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The severity of this message. <code>1</code> means warning and <code>2</code> means error.</p>"},{"location":"api/#xrlint.result.Message.fatal","title":"<code>fatal = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>True if this is a fatal error unrelated to a rule, like a parsing error.</p>"},{"location":"api/#xrlint.result.Message.fix","title":"<code>fix = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The EditInfo object of autofix. This property is None if this message is not fixable.</p> <p>Not used yet.</p>"},{"location":"api/#xrlint.result.Message.suggestions","title":"<code>suggestions = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The list of suggestions. Each suggestion is the pair of a description and an EditInfo object to fix the dataset. API users such as editor integrations can choose one of them to fix the problem of this message. This property is None if this message does not have any suggestions.</p>"},{"location":"api/#xrlint.result.Suggestion","title":"<code>xrlint.result.Suggestion</code>  <code>dataclass</code>","text":"<p>               Bases: <code>JsonSerializable</code></p> Source code in <code>xrlint\\result.py</code> <pre><code>@dataclass(frozen=True)\nclass Suggestion(JsonSerializable):\n    desc: str\n    \"\"\"Description of the suggestion.\"\"\"\n\n    data: dict[str, None] | None = None\n    \"\"\"Data that can be referenced in the description.\"\"\"\n\n    fix: EditInfo | None = None\n    \"\"\"Not used yet.\"\"\"\n\n    @classmethod\n    def from_value(cls, value: Any, name: str | None = None) -&gt; \"Suggestion\":\n        \"\"\"Convert given `value` into a `Suggestion` object.\n\n        If `value` is already a `Suggestion` then it is returned as-is.\n\n        Args:\n            value: A `Suggestion` object or a `str` containing the\n                suggestion text.\n\n        Returns:\n            A `Suggestion` object.\n        \"\"\"\n        if isinstance(value, Suggestion):\n            return value\n        if isinstance(value, str):\n            return Suggestion(value)\n        raise TypeError(format_message_type_of(\"value\", value, \"Suggestion|str\"))\n</code></pre>"},{"location":"api/#xrlint.result.Suggestion.desc","title":"<code>desc</code>  <code>instance-attribute</code>","text":"<p>Description of the suggestion.</p>"},{"location":"api/#xrlint.result.Suggestion.data","title":"<code>data = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Data that can be referenced in the description.</p>"},{"location":"api/#xrlint.result.Suggestion.fix","title":"<code>fix = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Not used yet.</p>"},{"location":"api/#xrlint.result.Suggestion.from_value","title":"<code>from_value(value, name=None)</code>  <code>classmethod</code>","text":"<p>Convert given <code>value</code> into a <code>Suggestion</code> object.</p> <p>If <code>value</code> is already a <code>Suggestion</code> then it is returned as-is.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>A <code>Suggestion</code> object or a <code>str</code> containing the suggestion text.</p> required <p>Returns:</p> Type Description <code>Suggestion</code> <p>A <code>Suggestion</code> object.</p> Source code in <code>xrlint\\result.py</code> <pre><code>@classmethod\ndef from_value(cls, value: Any, name: str | None = None) -&gt; \"Suggestion\":\n    \"\"\"Convert given `value` into a `Suggestion` object.\n\n    If `value` is already a `Suggestion` then it is returned as-is.\n\n    Args:\n        value: A `Suggestion` object or a `str` containing the\n            suggestion text.\n\n    Returns:\n        A `Suggestion` object.\n    \"\"\"\n    if isinstance(value, Suggestion):\n        return value\n    if isinstance(value, str):\n        return Suggestion(value)\n    raise TypeError(format_message_type_of(\"value\", value, \"Suggestion|str\"))\n</code></pre>"},{"location":"api/#xrlint.testing.RuleTester","title":"<code>xrlint.testing.RuleTester</code>","text":"<p>Utility that helps to test rules.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any]</code> <p>optional XRLint configuration.</p> <code>{}</code> Source code in <code>xrlint\\testing.py</code> <pre><code>class RuleTester:\n    \"\"\"Utility that helps to test rules.\n\n    Args:\n        config: optional XRLint configuration.\n    \"\"\"\n\n    def __init__(self, **config: dict[str, Any]):\n        self._config = config\n\n    def run(\n        self,\n        rule_name: str,\n        rule_op_class: Type[RuleOp],\n        *,\n        valid: list[RuleTest] | None = None,\n        invalid: list[RuleTest] | None = None,\n    ):\n        \"\"\"Run the given tests in `valid` and `invalid`\n        against the given rule.\n\n        Args:\n            rule_name: the rule's name\n            rule_op_class: a class derived from `RuleOp`\n            valid: list of tests that expect no reported problems\n            invalid: list of tests that expect reported problems\n\n        Raises:\n            AssertionError: if one of the checks fails\n        \"\"\"\n        tests = self._create_tests(\n            rule_name, rule_op_class, valid=valid, invalid=invalid\n        )\n        for test in tests.values():\n            print(f\"Rule {rule_name!r}: running {test.__name__}()...\")\n            # noinspection PyTypeChecker\n            test(None)\n\n    @classmethod\n    def define_test(\n        cls,\n        rule_name: str,\n        rule_op_class: Type[RuleOp],\n        *,\n        valid: list[RuleTest] | None = None,\n        invalid: list[RuleTest] | None = None,\n        config: dict[str, Any] | None = None,\n    ) -&gt; Type[unittest.TestCase]:\n        \"\"\"Create a `unittest.TestCase` class for the given rule and tests.\n\n        The returned class is derived from `unittest.TestCase`\n        and contains a test method for each of the tests in\n        `valid` and `invalid`.\n\n        Args:\n            rule_name: the rule's name\n            rule_op_class: the class derived from `RuleOp`\n            valid: list of tests that expect no reported problems\n            invalid: list of tests that expect reported problems\n            config: optional xrlint configuration\n\n        Returns:\n            A new class derived from `unittest.TestCase`.\n        \"\"\"\n        tester = RuleTester(**(config or {}))\n        tests = tester._create_tests(\n            rule_name, rule_op_class, valid=valid, invalid=invalid\n        )\n        # noinspection PyTypeChecker\n        return type(f\"{rule_op_class.__name__}Test\", (unittest.TestCase,), tests)\n\n    def _create_tests(\n        self,\n        rule_name: str,\n        rule_op_class: Type[RuleOp],\n        valid: list[RuleTest] | None,\n        invalid: list[RuleTest] | None,\n    ) -&gt; dict[str, Callable[[unittest.TestCase | None], None]]:\n        def make_args(tests: list[RuleTest] | None, mode: Literal[\"valid\", \"invalid\"]):\n            return [(test, index, mode) for index, test in enumerate(tests or [])]\n\n        return dict(\n            self._create_test(rule_name, rule_op_class, *args)\n            for args in make_args(valid, \"valid\") + make_args(invalid, \"invalid\")\n        )\n\n    def _create_test(\n        self,\n        rule_name: str,\n        rule_op_class: Type[RuleOp],\n        test: RuleTest,\n        test_index: int,\n        test_mode: Literal[\"valid\", \"invalid\"],\n    ) -&gt; tuple[str, Callable]:\n        test_id = _format_test_id(test, test_index, test_mode)\n\n        def test_fn(_self: unittest.TestCase):\n            error_message = self._test_rule(\n                rule_name, rule_op_class, test, test_id, test_mode\n            )\n            if error_message:\n                raise AssertionError(error_message)\n\n        test_fn.__name__ = test_id\n        return test_id, test_fn\n\n    def _test_rule(\n        self,\n        rule_name: str,\n        rule_op_class: Type[RuleOp],\n        test: RuleTest,\n        test_id: str,\n        test_mode: Literal[\"valid\", \"invalid\"],\n    ) -&gt; str | None:\n        # Note, the rule's code cannot and should not depend\n        # on the currently configured severity.\n        # There is also no way for a rule to obtain the severity.\n        severity = SEVERITY_ERROR\n        linter = Linter(**self._config)\n        result = linter.verify_dataset(\n            test.dataset,\n            plugins={\n                \"test\": (\n                    Plugin(\n                        meta=PluginMeta(name=\"test\"),\n                        rules={\n                            rule_name: Rule(\n                                meta=RuleMeta(name=rule_name), op_class=rule_op_class\n                            )\n                        },\n                    )\n                )\n            },\n            rules={\n                f\"test/{rule_name}\": (\n                    [severity, *(test.args or ()), (test.kwargs or {})]\n                    if test.args or test.kwargs\n                    else severity\n                )\n            },\n        )\n\n        assert_ok = _assert_valid if test_mode == \"valid\" else _assert_invalid\n        if assert_ok(result):\n            return None\n        else:\n            return _format_error_message(rule_name, test_id, test_mode, result)\n</code></pre>"},{"location":"api/#xrlint.testing.RuleTester.run","title":"<code>run(rule_name, rule_op_class, *, valid=None, invalid=None)</code>","text":"<p>Run the given tests in <code>valid</code> and <code>invalid</code> against the given rule.</p> <p>Parameters:</p> Name Type Description Default <code>rule_name</code> <code>str</code> <p>the rule's name</p> required <code>rule_op_class</code> <code>Type[RuleOp]</code> <p>a class derived from <code>RuleOp</code></p> required <code>valid</code> <code>list[RuleTest] | None</code> <p>list of tests that expect no reported problems</p> <code>None</code> <code>invalid</code> <code>list[RuleTest] | None</code> <p>list of tests that expect reported problems</p> <code>None</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>if one of the checks fails</p> Source code in <code>xrlint\\testing.py</code> <pre><code>def run(\n    self,\n    rule_name: str,\n    rule_op_class: Type[RuleOp],\n    *,\n    valid: list[RuleTest] | None = None,\n    invalid: list[RuleTest] | None = None,\n):\n    \"\"\"Run the given tests in `valid` and `invalid`\n    against the given rule.\n\n    Args:\n        rule_name: the rule's name\n        rule_op_class: a class derived from `RuleOp`\n        valid: list of tests that expect no reported problems\n        invalid: list of tests that expect reported problems\n\n    Raises:\n        AssertionError: if one of the checks fails\n    \"\"\"\n    tests = self._create_tests(\n        rule_name, rule_op_class, valid=valid, invalid=invalid\n    )\n    for test in tests.values():\n        print(f\"Rule {rule_name!r}: running {test.__name__}()...\")\n        # noinspection PyTypeChecker\n        test(None)\n</code></pre>"},{"location":"api/#xrlint.testing.RuleTester.define_test","title":"<code>define_test(rule_name, rule_op_class, *, valid=None, invalid=None, config=None)</code>  <code>classmethod</code>","text":"<p>Create a <code>unittest.TestCase</code> class for the given rule and tests.</p> <p>The returned class is derived from <code>unittest.TestCase</code> and contains a test method for each of the tests in <code>valid</code> and <code>invalid</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rule_name</code> <code>str</code> <p>the rule's name</p> required <code>rule_op_class</code> <code>Type[RuleOp]</code> <p>the class derived from <code>RuleOp</code></p> required <code>valid</code> <code>list[RuleTest] | None</code> <p>list of tests that expect no reported problems</p> <code>None</code> <code>invalid</code> <code>list[RuleTest] | None</code> <p>list of tests that expect reported problems</p> <code>None</code> <code>config</code> <code>dict[str, Any] | None</code> <p>optional xrlint configuration</p> <code>None</code> <p>Returns:</p> Type Description <code>Type[TestCase]</code> <p>A new class derived from <code>unittest.TestCase</code>.</p> Source code in <code>xrlint\\testing.py</code> <pre><code>@classmethod\ndef define_test(\n    cls,\n    rule_name: str,\n    rule_op_class: Type[RuleOp],\n    *,\n    valid: list[RuleTest] | None = None,\n    invalid: list[RuleTest] | None = None,\n    config: dict[str, Any] | None = None,\n) -&gt; Type[unittest.TestCase]:\n    \"\"\"Create a `unittest.TestCase` class for the given rule and tests.\n\n    The returned class is derived from `unittest.TestCase`\n    and contains a test method for each of the tests in\n    `valid` and `invalid`.\n\n    Args:\n        rule_name: the rule's name\n        rule_op_class: the class derived from `RuleOp`\n        valid: list of tests that expect no reported problems\n        invalid: list of tests that expect reported problems\n        config: optional xrlint configuration\n\n    Returns:\n        A new class derived from `unittest.TestCase`.\n    \"\"\"\n    tester = RuleTester(**(config or {}))\n    tests = tester._create_tests(\n        rule_name, rule_op_class, valid=valid, invalid=invalid\n    )\n    # noinspection PyTypeChecker\n    return type(f\"{rule_op_class.__name__}Test\", (unittest.TestCase,), tests)\n</code></pre>"},{"location":"api/#xrlint.testing.RuleTest","title":"<code>xrlint.testing.RuleTest</code>  <code>dataclass</code>","text":"<p>A rule test case.</p> Source code in <code>xrlint\\testing.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass RuleTest:\n    \"\"\"A rule test case.\"\"\"\n\n    dataset: xr.Dataset\n    \"\"\"The dataset to verify.\"\"\"\n\n    name: str | None = None\n    \"\"\"A name that helps identifying the test case.\"\"\"\n\n    args: tuple | list | None = None\n    \"\"\"Optional positional arguments passed to the rule operation's constructor.\"\"\"\n\n    kwargs: dict[str, Any] | None = None\n    \"\"\"Optional keyword arguments passed to the rule operation's constructor.\"\"\"\n\n    expected: list[Message] | int | None = 0\n    \"\"\"Expected messages.\n    Either a list of expected message objects or\n    the number of expected message.\n    Must not be provided for valid checks\n    and must be provided for invalid checks.\n    \"\"\"\n</code></pre>"},{"location":"api/#xrlint.testing.RuleTest.dataset","title":"<code>dataset</code>  <code>instance-attribute</code>","text":"<p>The dataset to verify.</p>"},{"location":"api/#xrlint.testing.RuleTest.name","title":"<code>name = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A name that helps identifying the test case.</p>"},{"location":"api/#xrlint.testing.RuleTest.args","title":"<code>args = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional positional arguments passed to the rule operation's constructor.</p>"},{"location":"api/#xrlint.testing.RuleTest.kwargs","title":"<code>kwargs = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional keyword arguments passed to the rule operation's constructor.</p>"},{"location":"api/#xrlint.testing.RuleTest.expected","title":"<code>expected = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Expected messages. Either a list of expected message objects or the number of expected message. Must not be provided for valid checks and must be provided for invalid checks.</p>"},{"location":"cli/","title":"Command Line Interface","text":"<p>After installation, the <code>xrlint</code> command can be used from the terminal.  The following are the command's options and arguments:</p> <pre><code>Usage: xrlint [OPTIONS] [FILES]...\n\n  Validate the given dataset FILES.\n\n  Reads configuration from `./xrlint_config.*` if such file exists and unless\n  `--no_config_lookup` is set or `--config` is provided. Then validates each\n  dataset in FILES against the configuration. The default dataset patters are\n  `**/*.zarr` and `**/.nc`. FILES may comprise also directories. If a\n  directory is not matched by any file pattern, it will be traversed\n  recursively. The validation result is dumped to standard output if not\n  otherwise stated by `--output-file`. The output format is `simple` by\n  default. Other inbuilt formats are `json` and `html` which you can specify\n  using the `--format` option.\n\nOptions:\n  --no-config-lookup      Disable use of default configuration from\n                          xrlint_config.*\n  -c, --config FILE       Use this configuration, overriding xrlint_config.*\n                          config options if present\n  --print-config FILE     Print the configuration for the given file\n  --plugin MODULE         Specify plugins. MODULE is the name of Python module\n                          that defines an 'export_plugin()' function.\n  --rule SPEC             Specify rules. SPEC must have format '&lt;rule-name&gt;:\n                          &lt;rule-config&gt;' (note the space character).\n  -o, --output-file FILE  Specify file to write report to\n  -f, --format NAME       Use a specific output format - default: simple\n  --color / --no-color    Force enabling/disabling of color\n  --max-warnings COUNT    Number of warnings to trigger nonzero exit code -\n                          default: 5\n  --init                  Write initial configuration file and exit.\n  --version               Show the version and exit.\n  --help                  Show this message and exit.\n</code></pre>"},{"location":"config/","title":"Configure XRLint","text":"<p>Note: this chapter's material is based on the documentation of how to configure ESLint. Many parts have been copied and adjusted as it applies in many similar ways to XRLint. </p>"},{"location":"config/#configuration-file","title":"Configuration File","text":"<p>The XRLint configuration file may be named any of the following:</p> <ul> <li><code>xrlint_config.yaml</code></li> <li><code>xrlint_config.json</code></li> <li><code>xrlint_config.py</code></li> </ul> <p>It should be placed in the root directory of your project and export  an array of configuration objects or  references to predefined configuration objects. </p> <p>Here\u2019s a YAML example:</p> <pre><code>- files: [\"**/*.zarr\", \"**/*.nc\"]\n- plugins:\n    xcube: xrlint.plugins.xcube\n- recommended\n- xcube/recommended\n</code></pre> <p>Same using JSON:</p> <pre><code>[\n  {\"files\": [\"**/*.zarr\", \"**/*.nc\"]},\n  {\n    \"plugins\": {\n      \"xcube\": \"xrlint.plugins.xcube\"\n    }\n  },\n  \"recommended\",\n  \"xcube/recommended\"\n]\n</code></pre> <p>And as Python script:</p> <pre><code>def export_configs():\n    return [\n      {\"files\": [\"**/*.zarr\", \"**/*.nc\"]},\n      {\n        \"plugins\": {\n          \"xcube\": \"xrlint.plugins.xcube\"\n        }\n      },\n      \"recommended\",\n      \"xcube/recommended\"\n    ]\n</code></pre>"},{"location":"config/#configuration-objects","title":"Configuration Objects","text":"<p>Each configuration object contains all of the information XRLint needs  to execute on a set of files. Each configuration object is made up of  these properties:</p> <ul> <li><code>name</code> - A name for the configuration object.    This is used in error messages and config inspector to help identify which    configuration object is being used.</li> <li><code>files</code> - A list of glob patterns indicating the files that the    configuration object should apply to. If not specified, the configuration    object applies to all files matched by any other configuration object.</li> <li><code>ignores</code> - A list of glob patterns indicating the files that the    configuration object should not apply to. If not specified, the configuration    object applies to all files matched by files. If ignores is used without any    other keys in the configuration object, then the patterns act as global ignores.</li> <li><code>opener_options</code> - A dictionary specifying keyword-arguments that are passed    directly to the <code>xarray.open_dataset()</code> function. The available options are    dependent on the xarray backend selected by the <code>engine</code> option.</li> <li><code>linter_options</code> - A dictionary containing settings related to    the linting process. (Currently not used.)</li> <li><code>processor</code> - A string indicating the name of a processor inside of a plugin,    i.e., <code>\"&lt;plugin-name&gt;/&lt;processor-name&gt;\"</code>. In Python configurations    it can also be an object of type <code>ProcessorOp</code> containing   <code>preprocess()</code> and <code>postprocess()</code> methods.</li> <li><code>plugins</code> - A dictionary containing a name-value mapping of plugin names    to either plugin module names or <code>Plugin</code> objects. When <code>files</code> is specified,    these plugins are only available to the matching files.</li> <li><code>rules</code> - An object containing the configured rules.    When <code>files</code> or <code>ignores</code> are specified, these rule configurations are only    available to the matching files.</li> <li><code>settings</code> - An object containing name-value pairs of information that should    be available to all rules.</li> </ul>"},{"location":"rule-ref/","title":"Rule Reference","text":"<p>This page is auto-generated from XRLint's builtin rules (<code>python -m mkruleref</code>). New rules will be added by upcoming XRLint releases.</p>"},{"location":"rule-ref/#core-rules","title":"Core Rules","text":""},{"location":"rule-ref/#coords-for-dims","title":"<code>coords-for-dims</code>","text":"<p>Dimensions of data variables should have corresponding coordinates.</p> <p>Contained in:  <code>all</code>- <code>recommended</code>-</p>"},{"location":"rule-ref/#dataset-title-attr","title":"<code>dataset-title-attr</code>","text":"<p>Datasets should be given a non-empty title.</p> <p>Contained in:  <code>all</code>- <code>recommended</code>-</p>"},{"location":"rule-ref/#grid-mappings","title":"<code>grid-mappings</code>","text":"<p>Grid mappings, if any, shall have valid grid mapping coordinate variables.</p> <p>Contained in:  <code>all</code>- <code>recommended</code>-</p>"},{"location":"rule-ref/#no-empty-attrs","title":"<code>no-empty-attrs</code>","text":"<p>Every dataset element should have metadata that describes it.</p> <p>Contained in:  <code>all</code>- <code>recommended</code>-</p>"},{"location":"rule-ref/#var-units-attr","title":"<code>var-units-attr</code>","text":"<p>Every variable should have a valid 'units' attribute.</p> <p>Contained in:  <code>all</code>- <code>recommended</code>-</p>"},{"location":"rule-ref/#xcube-rules","title":"xcube Rules","text":""},{"location":"rule-ref/#any-spatial-data-var","title":"<code>any-spatial-data-var</code>","text":"<p>A datacube should have spatial data variables. More information.</p> <p>Contained in:  <code>all</code>- <code>recommended</code>-</p>"},{"location":"rule-ref/#cube-dims-order","title":"<code>cube-dims-order</code>","text":"<p>Order of dimensions in spatio-temporal datacube variables should be [time, ..., y, x]. More information.</p> <p>Contained in:  <code>all</code>- <code>recommended</code>-</p>"},{"location":"rule-ref/#data-var-colors","title":"<code>data-var-colors</code>","text":"<p>Spatial data variables should encode xcube color mappings in their metadata. More information.</p> <p>Contained in:  <code>all</code>- <code>recommended</code>-</p>"},{"location":"rule-ref/#grid-mapping-naming","title":"<code>grid-mapping-naming</code>","text":"<p>Grid mapping variables should be called 'spatial_ref' or 'crs' for compatibility with rioxarray and other packages. More information.</p> <p>Contained in:  <code>all</code>- <code>recommended</code>-</p>"},{"location":"rule-ref/#increasing-time","title":"<code>increasing-time</code>","text":"<p>Time coordinate labels should be monotonically increasing. More information.</p> <p>Contained in:  <code>all</code>- <code>recommended</code>-</p>"},{"location":"rule-ref/#lat-lon-naming","title":"<code>lat-lon-naming</code>","text":"<p>Latitude and longitude coordinates and dimensions should be called 'lat' and 'lon'. More information.</p> <p>Contained in:  <code>all</code>- <code>recommended</code>-</p>"},{"location":"rule-ref/#single-grid-mapping","title":"<code>single-grid-mapping</code>","text":"<p>A single grid mapping shall be used for all spatial data variables of a datacube. More information.</p> <p>Contained in:  <code>all</code>- <code>recommended</code>-</p>"},{"location":"start/","title":"Getting Started","text":""},{"location":"start/#installation","title":"Installation","text":"<pre><code>pip install xrlint\n</code></pre> <p>or</p> <pre><code>conda install -c conda-forge xrlint\n</code></pre>"},{"location":"start/#command-line-interface","title":"Command line interface","text":"<p>Get basic help:</p> <pre><code>xrlint --help\n</code></pre> <p>Initializing a new project with</p> <pre><code>xrlint --init\n</code></pre> <p>writes a configuration file <code>xrlint.config.yaml</code>  into the current working directory:</p> <pre><code>- recommended\n</code></pre> <p>This configuration file tells XRLint to use the predefined configuration named <code>recommeded</code>.  </p> <p>Create a dataset to test XRLint:</p> <pre><code>python\n&gt;&gt;&gt; import xarray as xr\n&gt;&gt;&gt; test_ds = xr.Dataset(attrs={\"title\": \"Test Dataset\"})\n&gt;&gt;&gt; test_ds.to_zarr(\"test.zarr\") \n&gt;&gt;&gt; exit()\n</code></pre> <p>And run XRLint:</p> <pre><code>xrlint test.zarr \n</code></pre> <p>You can now override the predefined settings by adding your custom rule configurations:</p> <pre><code>- recommended\n- rules:\n    no-empty-attrs: off\n    var-units-attr: warn\n    grid-mappings: error\n</code></pre> <p>You can add rules from plugins as well:</p> <pre><code>- recommended\n- plugins:\n    xcube: xrlint.plugins.xcube\n- xcube/recommended  \n</code></pre> <p>And customize its rules, if desired:</p> <pre><code>- recommended\n- plugins:\n    xcube: xrlint.plugins.xcube\n- xcube/recommended  \n- rules:\n    xcube/grid-mapping-naming: off\n    xcube/lat-lon-naming: warn\n</code></pre> <p>Note the prefix <code>xcube/</code> used for the rule names.</p>"},{"location":"start/#python-api","title":"Python API","text":"<p>The easiest approach to use the Python API is to import <code>xrlint.all</code>. It contains all the public definitions from the <code>xrlint</code> package.</p> <pre><code>import xrlint.all as xrl\n</code></pre> <p>Start by creating a linter with recommended settings  using the <code>new_linter()</code> function .</p> <pre><code>import xarray as xr\nimport xrlint.all as xrl\n\ntest_ds = xr.Dataset(attrs={\"title\": \"Test Dataset\"})\n\nlinter = xrl.new_linter(\"recommended\")\nlinter.verify_dataset(test_ds)\n</code></pre>"},{"location":"todo/","title":"To Do","text":""},{"location":"todo/#required","title":"Required","text":"<ul> <li>populate <code>core</code> plugin by more rules, see CF site and <code>cf-check</code> tool</li> <li>populate <code>xcube</code> plugin by more rules</li> <li>add <code>docs</code></li> <li>use mkdocstrings ref syntax in docstrings</li> <li>provide configuration examples (use as tests?)</li> </ul>"},{"location":"todo/#desired","title":"Desired","text":"<ul> <li>project logo</li> <li>support validating xcube 'levels' format. Options:<ul> <li>implement xarray backend so we can open them using <code>xr.open_dataset</code>   with <code>opener_options: {\"engine\": \"xc-levels\"}</code>.</li> <li>implement a <code>xrlint.processor.Processor</code> for that purpose.</li> </ul> </li> <li>add some more tests so we reach 99% coverage</li> <li>support rule op args/kwargs schema validation</li> <li>Support <code>RuleTest.expected</code>, it is currently unused</li> </ul>"},{"location":"todo/#nice-to-have","title":"Nice to have","text":"<ul> <li>support <code>autofix</code> feature</li> <li>support <code>md</code> (markdown) output format</li> <li>support formatter op args/kwargs schema validation</li> </ul>"},{"location":"todo/#ideas","title":"Ideas","text":""},{"location":"todo/#allow-for-different-dataset-openers","title":"Allow for different dataset openers","text":"<ul> <li>introduce <code>dataset_options</code> config:</li> <li><code>opener: OpenerOp</code></li> <li><code>opener_options: dict[str, Any]</code></li> </ul>"},{"location":"todo/#other-plugins","title":"Other plugins","text":"<ul> <li><code>sgrid</code>: https://sgrid.github.io/sgrid/</li> <li><code>ugrid</code>: https://ugrid-conventions.github.io/ugrid-conventions/</li> </ul>"},{"location":"todo/#generalize-data-linting","title":"Generalize data linting","text":"<p>Do not limit verification to <code>xr.Dataset</code>. However, this requires new rule sets.</p> <p>To allow for other data models, we need to allow  for a specific verifier type for a given data type.</p> <p>The verifier verifies specific node types that are characteristic for a data type.</p> <p>To do so a traverser must traverse the elements of the data and pass each node to the verifier.</p> <p>Note, this is the Visitor Pattern,  where the verifier is the Visitor and a node refers to Element.</p> <p>To support the CLI mode, we need different data opener  types that can read the data from a file path.</p> <ol> <li>open data, if given data is a file path: </li> <li>find opener for file path</li> <li>open data </li> <li>verify data</li> <li>find root element type and visitor type for data </li> <li>call the root element <code>accept(verifier)</code> that verifies the       root element <code>verify.root()</code> and starts traversal of       child elements.</li> </ol>"}]}