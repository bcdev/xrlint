{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"XRLint - A linter for xarray datasets","text":"<p>XRLint is a linting  tool and library for xarray datasets. Its design is heavily inspired by ESLint.</p> <p>IMPORTANT NOTE: This project just started and is under development,  there is no stable release yet. See to-do list.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Flexible validation for <code>xarray.Dataset</code> objects by configurable rules.</li> <li>Available from CLI and Python API.</li> <li>Custom plugins providing custom rule sets allow addressing    different dataset conventions.</li> <li>Project-specific configurations including configuration of individual    rules and file-specific settings.</li> </ul>"},{"location":"#inbuilt-rules","title":"Inbuilt Rules","text":"<p>The following rule plugins are currently built into the code base:</p> <ul> <li><code>core</code>: Implementing the rules for   tiny data   and the    CF-Conventions.</li> <li><code>xcube</code>: Implementing the rules for    xcube datasets.   Note this plugins will be moved into a separate GitHub repo later    once XRLint is mature enough. </li> </ul>"},{"location":"about/","title":"About XRLint","text":""},{"location":"about/#changelog","title":"Changelog","text":"<p>You can find the complete XRLint changelog  here. </p>"},{"location":"about/#reporting","title":"Reporting","text":"<p>If you have suggestions, ideas, feature requests, or if you have identified a malfunction or error, then please  post an issue. </p>"},{"location":"about/#contributions","title":"Contributions","text":"<p>The XRLint project welcomes contributions of any form as long as you respect our  code of conduct and follow our  contribution guide.</p> <p>If you'd like to submit code or documentation changes, we ask you to provide a  pull request (PR)  here.  For code and configuration changes, your PR must be linked to a  corresponding issue. </p>"},{"location":"about/#development","title":"Development","text":"<p>To set up development environment, with repository root as current working directory:</p> <pre><code>pip install .[dev,doc]\n</code></pre>"},{"location":"about/#testing-and-coverage","title":"Testing and Coverage","text":"<p>XRLint uses pytest for unit-level testing  and code coverage analysis.</p> <pre><code>pytest --cov=xrlint --cov-report html\n</code></pre>"},{"location":"about/#code-style","title":"Code Style","text":"<p>XRLint source code is formatted using the black tool.</p> <pre><code>black .\n</code></pre>"},{"location":"about/#documentation","title":"Documentation","text":"<p>XRLint documentation is built using the mkdocs tool.</p> <p>With repository root as current working directory:</p> <pre><code>pip install .[doc]\n\nmkdocs build\nmkdocs serve\nmkdocs gh-deploy\n</code></pre>"},{"location":"about/#license","title":"License","text":"<p>XRLint is open source made available under the terms and conditions of the  MIT License.</p> <p>Copyright \u00a9 2025 Brockmann Consult Development</p>"},{"location":"api/","title":"Python API","text":"<p>All described objects can be imported from the <code>xrlint.all</code> module.</p>"},{"location":"api/#function-new_linter","title":"Function <code>new_linter()</code>","text":"<p>Create a new <code>Linter</code> with all built-in plugins configured.</p> <p>Parameters:</p> Name Type Description Default <code>recommended</code> <code>bool</code> <p><code>True</code> (the default) if the recommended rule configurations of the built-in plugins should be used. If set to <code>False</code>, you should configure the <code>rules</code> option either in <code>config</code> or <code>config_kwargs</code>. Otherwise, calling <code>verify_dataset()</code> will never succeed for any given dataset.</p> <code>True</code> <code>config</code> <code>Config | dict | None</code> <p>The <code>config</code> keyword argument passed to the <code>Linter</code> class</p> <code>None</code> <code>config_kwargs</code> <code>dict[str, Any]</code> <p>The <code>config_kwargs</code> keyword arguments passed to the <code>Linter</code> class</p> <code>{}</code> <p>Returns:     A new linter instance</p>"},{"location":"api/#class-linter","title":"Class <code>Linter</code>","text":"<p>The linter.</p> <p>You should not use the constructor directly. Instead, use the <code>new_linter()</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config | dict[str, Any] | None</code> <p>The linter's configuration.</p> <code>None</code> <code>config_kwargs</code> <code>dict[str, Any]</code> <p>Individual linter configuration options. All options of the <code>Config</code> object are possible. If <code>config</code> is given too, provided given individual linter configuration options merged the ones given in <code>config</code>.</p> <code>{}</code>"},{"location":"api/#xrlint.linter.Linter.config","title":"<code>config: Config</code>  <code>property</code>","text":"<p>Get this linter's configuration.</p>"},{"location":"api/#xrlint.linter.Linter.verify_dataset","title":"<code>verify_dataset(dataset, *, file_path=None, config=None, **config_kwargs)</code>","text":"<p>Verify a dataset.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>str | Path | Dataset</code> <p>The dataset. Can be a <code>xr.Dataset</code> instance or a file path from which the dataset will be opened.</p> required <code>file_path</code> <code>str | None</code> <p>Optional file path used for formatting messages. Useful if <code>dataset</code> is not a file path.</p> <code>None</code> <code>config</code> <code>Config | dict[str, Any] | None</code> <p>Configuration tbe merged with the linter's configuration.</p> <code>None</code> <code>config_kwargs</code> <code>dict[str, Any]</code> <p>Individual linter configuration options to be merged with <code>config</code> if any. The merged result will be merged with the linter's configuration.</p> <code>{}</code> <p>Returns:     Result of the verification.</p>"},{"location":"api/#class-config","title":"Class <code>Config</code>","text":"<p>               Bases: <code>ToDictMixin</code></p> <p>Configuration object. A configuration object contains all the information XRLint needs to execute on a set of dataset files.</p> <p>You should not use the class constructor directly. Instead, use the <code>Config.from_value()</code> function.</p>"},{"location":"api/#xrlint.config.Config.files","title":"<code>files: list[str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An array of glob patterns indicating the files that the  configuration object should apply to. If not specified,  the configuration object applies to all files matched  by any other configuration object.</p>"},{"location":"api/#xrlint.config.Config.ignores","title":"<code>ignores: list[str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An array of glob patterns indicating the files that the  configuration object should not apply to. If not specified,  the configuration object applies to all files matched by <code>files</code>.  If <code>ignores</code> is used without any other keys in the configuration  object, then the patterns act as global ignores.</p>"},{"location":"api/#xrlint.config.Config.linter_options","title":"<code>linter_options: dict[str, Any] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary containing options related to the linting process.</p>"},{"location":"api/#xrlint.config.Config.name","title":"<code>name: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A name for the configuration object.  This is used in error messages and config inspector to help identify  which configuration object is being used.</p>"},{"location":"api/#xrlint.config.Config.opener_options","title":"<code>opener_options: dict[str, Any] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary containing options that are passed to  the dataset opener.</p>"},{"location":"api/#xrlint.config.Config.plugins","title":"<code>plugins: dict[str, Plugin] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary containing a name-value mapping of plugin names to  plugin objects. When <code>files</code> is specified, these plugins are only  available to the matching files.</p>"},{"location":"api/#xrlint.config.Config.processor","title":"<code>processor: Union[ProcessorOp, str, None] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Either an object compatible with the <code>ProcessorOp</code>  interface or a string indicating the name of a processor inside  of a plugin (i.e., <code>\"pluginName/processorName\"</code>).</p>"},{"location":"api/#xrlint.config.Config.rules","title":"<code>rules: dict[str, RuleConfig] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary containing the configured rules.  When <code>files</code> or <code>ignores</code> are specified, these rule configurations  are only available to the matching files.</p>"},{"location":"api/#xrlint.config.Config.settings","title":"<code>settings: dict[str, Any] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary containing name-value pairs of information  that should be available to all rules.</p>"},{"location":"api/#xrlint.config.Config.from_value","title":"<code>from_value(value)</code>  <code>classmethod</code>","text":"<p>Convert given <code>value</code> into a <code>Config</code> object.</p> <p>If <code>value</code> is already a <code>Config</code> then it is returned as-is.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>A <code>Config</code> object, a <code>dict</code> containing the configuration properties, or <code>None</code> which converts into an empty configuration.</p> required <p>Returns:     A <code>Config</code> object.</p>"},{"location":"api/#xrlint.config.Config.get_rule","title":"<code>get_rule(rule_id)</code>","text":"<p>Get the rule for the given rule identifier <code>rule_id</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rule_id</code> <code>str</code> <p>The rule identifier including plugin namespace, if any. Format <code>&lt;rule-name&gt;</code> (builtin rules) or <code>&lt;plugin-name&gt;/&lt;rule-name&gt;</code>.</p> required <p>Returns:     A <code>Rule</code> object. Raises:     ValueError: If either the plugin is unknown in this configuration         or the rule name is unknown.</p>"},{"location":"api/#class-ruleconfig","title":"Class <code>RuleConfig</code>","text":"<p>A rule configuration.</p> <p>You should not use the class constructor directly. Instead, use the <code>RuleConfig.from_value()</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>severity</code> <code>Literal[0, 1, 2]</code> <p>rule severity, one of <code>2</code> (error), <code>1</code> (warn), or <code>0</code> (off)</p> required <code>args</code> <code>tuple[Any, ...]</code> <p>rule operation arguments.</p> <code>tuple()</code> <code>kwargs</code> <code>dict[str, Any]</code> <p>rule operation keyword-arguments.</p> <code>dict()</code>"},{"location":"api/#xrlint.rule.RuleConfig.args","title":"<code>args: tuple[Any, ...] = field(default_factory=tuple)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rule operation arguments.</p>"},{"location":"api/#xrlint.rule.RuleConfig.kwargs","title":"<code>kwargs: dict[str, Any] = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rule operation keyword-arguments.</p>"},{"location":"api/#xrlint.rule.RuleConfig.severity","title":"<code>severity: Literal[0, 1, 2]</code>  <code>instance-attribute</code>","text":"<p>Rule severity.</p>"},{"location":"api/#xrlint.rule.RuleConfig.from_value","title":"<code>from_value(value)</code>  <code>classmethod</code>","text":"<p>Convert <code>value</code> into a <code>RuleConfig</code> object.</p> <p>A rule configuration value can either be a rule severity, or a list where the first element is a rule severity and subsequent elements are rule arguments:</p> <ul> <li>severity</li> <li><code>[</code>severity<code>]</code></li> <li><code>[</code>severity<code>,</code> arg-1 | kwargs <code>]</code></li> <li><code>[</code>severity<code>,</code> arg-1<code>,</code> arg-2<code>,</code> ...<code>,</code> arg-n | kwargs<code>]</code></li> </ul> <p>The rule severity is either</p> <ul> <li>one of <code>\"error\"</code>, <code>\"warn\"</code>, <code>\"off\"</code> or</li> <li>one of <code>2</code> (error), <code>1</code> (warn), <code>0</code> (off)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>A rule severity or a list where the first element is a rule severity and subsequent elements are rule arguments. If the value is already of type <code>RuleConfig</code>it is returned as-is.</p> required <p>Returns:     A <code>RuleConfig</code> object.</p>"},{"location":"api/#class-rule","title":"Class <code>Rule</code>","text":"<p>A rule.</p>"},{"location":"api/#xrlint.rule.Rule.meta","title":"<code>meta: RuleMeta</code>  <code>instance-attribute</code>","text":"<p>Rule metadata of type <code>RuleMeta</code>.</p>"},{"location":"api/#xrlint.rule.Rule.op_class","title":"<code>op_class: Type[RuleOp]</code>  <code>instance-attribute</code>","text":"<p>The class the implements the rule's verification operation. The class must implement the <code>RuleOp</code> interface.</p>"},{"location":"api/#class-rulemeta","title":"Class <code>RuleMeta</code>","text":"<p>               Bases: <code>ToDictMixin</code></p> <p>Rule metadata.</p>"},{"location":"api/#xrlint.rule.RuleMeta.description","title":"<code>description: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rule description.</p>"},{"location":"api/#xrlint.rule.RuleMeta.docs_url","title":"<code>docs_url: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rule documentation URL.</p>"},{"location":"api/#xrlint.rule.RuleMeta.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>Rule name. Mandatory.</p>"},{"location":"api/#xrlint.rule.RuleMeta.schema","title":"<code>schema: dict[str, Any] | list[dict[str, Any]] | bool | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>JSON Schema used to specify and validate the rule verifier's  options.</p> <p>It can take the following values:</p> <ul> <li>Use <code>None</code> (the default) to indicate that the rule verifier    as no options at all.</li> <li>Use a schema to indicate that the rule verifier    takes keyword arguments only.   The schema's type must be <code>\"object\"</code>.</li> <li>Use a list of schemas to indicate that the rule verifier   takes positional arguments only.    If given, the number of schemas in the list specifies the    number of positional arguments that must be configured.</li> </ul>"},{"location":"api/#xrlint.rule.RuleMeta.type","title":"<code>type: Literal['problem', 'suggestion'] = 'problem'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rule type. Defaults to <code>\"problem\"</code>.</p>"},{"location":"api/#xrlint.rule.RuleMeta.version","title":"<code>version: str = '0.0.0'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rule version. Defaults to <code>0.0.0</code>.</p>"},{"location":"api/#class-ruleop","title":"Class <code>RuleOp</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Define the specific rule verification operation.</p>"},{"location":"api/#xrlint.rule.RuleOp.attr","title":"<code>attr(context, node)</code>","text":"<p>Verify the given attribute node.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>RuleContext</code> <p>The current rule context.</p> required <code>node</code> <code>AttrNode</code> <p>The attribute node.</p> required"},{"location":"api/#xrlint.rule.RuleOp.attrs","title":"<code>attrs(context, node)</code>","text":"<p>Verify the given attributes node.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>RuleContext</code> <p>The current rule context.</p> required <code>node</code> <code>AttrsNode</code> <p>The attributes node.</p> required"},{"location":"api/#xrlint.rule.RuleOp.data_array","title":"<code>data_array(context, node)</code>","text":"<p>Verify the given data array (variable) node.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>RuleContext</code> <p>The current rule context.</p> required <code>node</code> <code>DataArrayNode</code> <p>The data array (variable) node.</p> required"},{"location":"api/#xrlint.rule.RuleOp.dataset","title":"<code>dataset(context, node)</code>","text":"<p>Verify the given dataset node.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>RuleContext</code> <p>The current rule context.</p> required <code>node</code> <code>DatasetNode</code> <p>The dataset node.</p> required"},{"location":"api/#class-rulecontext","title":"Class <code>RuleContext</code>","text":"<p>               Bases: <code>ABC</code></p> <p>The context passed to the verifier of a rule.</p> <p>You should never create instances of this class yourself. Instances of this interface are passed to the <code>RuleOp</code>'s methods.</p>"},{"location":"api/#xrlint.rule.RuleContext.dataset","title":"<code>dataset: xr.Dataset</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the current dataset.</p>"},{"location":"api/#xrlint.rule.RuleContext.file_path","title":"<code>file_path: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the current dataset's file path.</p>"},{"location":"api/#xrlint.rule.RuleContext.settings","title":"<code>settings: dict[str, Any]</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Configuration settings.</p>"},{"location":"api/#xrlint.rule.RuleContext.report","title":"<code>report(message, *, fatal=None, suggestions=None)</code>  <code>abstractmethod</code>","text":"<p>Report an issue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>mandatory message text</p> required <code>fatal</code> <code>bool | None</code> <p>True, if a fatal error is reported.</p> <code>None</code> <code>suggestions</code> <code>list[Suggestion] | None</code> <p>A list of suggestions for the user on how to fix the reported issue.</p> <code>None</code>"},{"location":"cli/","title":"Command Line Interface","text":"<p>After installation, the <code>xrlint</code> command can be used from the terminal.  The following are the command's options and arguments:</p> <pre><code>Usage: xrlint [OPTIONS] [FILES]...\n\n  Lint the given dataset FILES.\n\n  Reads configuration from `./xrlint.config.py` if `--no-default-config` is\n  not set and `--config PATH` is not provided, then validates each dataset in\n  FILES against the configuration. The validation result is dumped to standard\n  output if not otherwise stated by `--output-file PATH`. The output format is\n  `simple`. Other inbuilt formats are `json` and `html` which can by setting\n  the `--format NAME` option.\n\nOptions:\n  --no-default-config     Disable use of default configuration from\n                          xrlint.config.*\n  -c, --config PATH       Use this configuration, overriding xrlint.config.*\n                          config options if present\n  -f, --format NAME       Use a specific output format - default: simple\n  -o, --output-file PATH  Specify file to write report to\n  --max-warnings COUNT    Number of warnings to trigger nonzero exit code -\n                          default: -1\n  --version               Show the version and exit.\n  --help                  Show this message and exit.\n</code></pre>"},{"location":"todo/","title":"To Do","text":""},{"location":"todo/#required","title":"Required","text":"<ul> <li>populate <code>core</code> plugin by more rules</li> <li>populate <code>xcube</code> plugin by more rules</li> <li>add <code>docs</code></li> <li>use mkdocstrings ref syntax in docstrings</li> <li>provide configuration examples (use as tests?)</li> <li>generate markdown rule reference for the docs</li> </ul>"},{"location":"todo/#desired","title":"Desired","text":"<ul> <li>add some more tests so we reach 99% coverage</li> <li>introduce <code>dataset_options</code> config:<ul> <li><code>opener: OpenerOp</code></li> <li><code>opener_options: dict[str, Any]</code></li> </ul> </li> <li>implement <code>autofix</code> feature</li> </ul>"},{"location":"todo/#nice-to-have","title":"Nice to have","text":"<p>Currently unused - <code>RuleMeta.type</code> - <code>RuleTest.expected</code> - <code>processor: ProcessorOp</code> </p>"},{"location":"todo/#ideas","title":"Ideas","text":""},{"location":"todo/#other-plugins","title":"Other plugins","text":"<ul> <li><code>sgrid</code>: https://sgrid.github.io/sgrid/</li> <li><code>ugrid</code>: https://ugrid-conventions.github.io/ugrid-conventions/</li> </ul>"},{"location":"todo/#generalize-data-linting","title":"Generalize data linting","text":"<p>Do not limit verification to <code>xr.Dataset</code>. However, this requires new rule sets.</p> <p>To allow for other data models, we need to allow  for a specific verifier type for a given data type.</p> <p>The verifier verifies specific node types that are characteristic for a data type.</p> <p>To do so a traverser must traverse the elements of the data and pass each node to the verifier.</p> <p>Note, this is the Visitor Pattern,  where the verifier is the Visitor and a node refers to Element.</p> <p>To support the CLI mode, we need different data opener  types that can read the data from a file path.</p> <ol> <li>open data, if given data is a file path: </li> <li>find opener for file path</li> <li>open data </li> <li>verify data</li> <li>find root element type and visitor type for data </li> <li>call the root element <code>accept(verifier)</code> that verifies the       root element <code>verify.root()</code> and starts traversal of       child elements.</li> </ol>"}]}